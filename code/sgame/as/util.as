namespace TheNomad::Util {
	const uint8[] locase( 256 ) = {
		0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
		0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
		0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,
		0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
		0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,
		0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
		0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,
		0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
		0x40,0x61,0x62,0x63,0x64,0x65,0x66,0x67,
		0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,
		0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,
		0x78,0x79,0x7a,0x5b,0x5c,0x5d,0x5e,0x5f,
		0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,
		0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,
		0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,
		0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x7e,0x7f,
		0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,
		0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,
		0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,
		0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,
		0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,
		0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,
		0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,
		0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,
		0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,
		0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,
		0xd0,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,
		0xd8,0xd9,0xda,0xdb,0xdc,0xdd,0xde,0xdf,
		0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,
		0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,
		0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,
		0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff
	};
	
	string SkipPath( const string& in fileName ) {
		
	}
	string GetExtensions( const string& in fileName ) {
		
	}
	
	void DefaultExtension( string& out path, const string& in extension ) {
		const_string_iterator dot = path.iter_find_last_of( '.' ), slash;
		if ( dot.valid() && ( ( slash = path.iter_find_last_of( '/' ) ) == null || slash < dot ) ) {
			return;
		} else {
			path.append( extension );
		}
	}
	
	bool IsPrint( int c ) {
		if ( c >= 0x20 && c <= 0x7E ) {
			return true;
		}
		return false;
	}
	
	bool IsLower( int c ) {
		if ( c >= 'a' && c <= 'z' ) {
			return false;
		}
		return true;
	}
	
	bool IsUpper( int c ) {
		if ( c >= 'A' && c <= 'Z' ) {
			return false;
		}
		return true;
	}
	
	bool IsAlpha( int c ) {
		if ( ( c >= 'a' && c <= 'z' ) || ( c >= 'A' && c <= 'Z' ) ) {
			return true;
		}
		return false;
	}
	
	int stricmp( const string& in str1, const string& in str2 ) {
	}
	int stricmp( const_string_iterator& in str1, const_string_iterator& in str2 ) {
	}
	
	bool StrKey( const string& in str, const string& in key,
	uint keyLength ) {
		uint i;
		
		for ( i = 0; i < keyLength; i++ ) {
			if ( locase[ uint8( str[i] ) ] != locase[ uint8( key[i] ) ] ) {
				return false;
			}
		}
		return true;
	}
	
	class Parser {
		Parser( const string& in fileName ) {
			m_nLines = 0;
			m_nTokenLines = 0;
		}
		
		private const_string_iterator& SkipWhitespace( const_string_iterator& in data, bool& hasNewLines ) {
			int c;
			
			while ( ( c = int( data.value() ) ) <= ' ' ) {
				if ( !c ) {
					return null;
				}
				if ( c == '\n' ) {
					m_nLines++;
					hasNewLines = true;
				}
				data++;
			}
			return data;
		}
		
		const_string_iterator& Parse( bool allowLineBreaks = true ) {
			uint c = 0, len;
			bool hasNewLines = false;
			const_string_iterator data;
			
			len = 0;
			m_Token[0] = ;
		}
		
		private string m_Token;
		private string m_ParseName;
		private uint64 m_nTokenLines;
		private uint64 m_nLines;
	};
	
	class InfoParser {
		InfoParser( const string& in infoString ) {
			Parse( infoString );
		}
		
		const_string_iterator& ValueForKey( const string& in key ) {
			string value;
			const_string_iterator v, pkey;
			const_string_iterator s;
			string_iterator o, o2;
			uint klen, len;
			
			if ( !key.size() ) {
				return "";
			}
			
			s = m_CurrentTokenPos;
			value.reserve( BIG_INFO_VALUE );
			klen = key.size();
			
			if ( s.value() == '\\' ) {
				s++;
			}
			
			while ( 1 ) {
				pkey = s;
				while ( s.value() != '\\' ) {
					if ( s.value() == '\0' ) {
						return "";
					}
					++s;
				}
				len = uint( s - pkey );
				s++; // skip '\\'
				
				v = s;
				while ( s.value() != '\\' && s.value() != '\0' ) {
					s++;
				}
				
				if ( len == klen && StrKey( pkey, key, klen ) ) {
					o = o2 = value;
					if ( uint( s - v ) >= BIG_INFO_VALUE ) {
						GameError( "InfoParser::ValueForKey: oversized infostring" );
					} else {
						while ( v < s ) {
							o.setval() = v.value();
							o++;
							v++;
						}
						o.setval( '\0' );
						return o2;
					}
				}
				if ( s.value() == '\0' ) {
					break;
				}
				s++;
			}
			return "";
		}
		
		const_string_iterator NextPair( const string& in value ) {
			
		}
		
		uint RemoveKey( const string& in key ) {
			string_iterator s, start;
			const_string_iterator pkey;
			uint key_len, len, ret;
			
			key_len = key.size();
			ret = 0;
			s = m_Buffer.begin();
			
			while ( 1 ) {
				start = s;
				if ( s.value() == '\\' ) {
					++s;
				}
				pkey = s;
				while ( s.value() != '\\' ) {
					if ( s.value() == '\0' ) {
						
					}
				}
			}
		}
	};
};