export Com_Clamp
code
proc Com_Clamp 0 0
file "../../engine/n_shared.c"
line 12
;1:#ifdef Q3_VM
;2:#include "../engine/n_shared.h"
;3:#else
;4:#include "code/engine/n_shared.h"
;5:#endif
;6:
;7:// undefined symbol: CPU_flags when compiling dlls
;8:#if defined(GDR_DLLCOMPILE) || defined(UI_HARD_LINKED) || defined(SGAME_HARD_LINKED)
;9:int CPU_flags;
;10:#endif
;11:
;12:float Com_Clamp( float min, float max, float value ) {
line 13
;13:	if ( value < min ) {
ADDRFP4 8
INDIRF4
ADDRFP4 0
INDIRF4
GEF4 $35
line 14
;14:		return min;
ADDRFP4 0
INDIRF4
RETF4
ADDRGP4 $34
JUMPV
LABELV $35
line 16
;15:	}
;16:	if ( value > max ) {
ADDRFP4 8
INDIRF4
ADDRFP4 4
INDIRF4
LEF4 $37
line 17
;17:		return max;
ADDRFP4 4
INDIRF4
RETF4
ADDRGP4 $34
JUMPV
LABELV $37
line 19
;18:	}
;19:	return value;
ADDRFP4 8
INDIRF4
RETF4
LABELV $34
endproc Com_Clamp 0 0
lit
export locase
align 1
LABELV locase
byte 1 0
byte 1 1
byte 1 2
byte 1 3
byte 1 4
byte 1 5
byte 1 6
byte 1 7
byte 1 8
byte 1 9
byte 1 10
byte 1 11
byte 1 12
byte 1 13
byte 1 14
byte 1 15
byte 1 16
byte 1 17
byte 1 18
byte 1 19
byte 1 20
byte 1 21
byte 1 22
byte 1 23
byte 1 24
byte 1 25
byte 1 26
byte 1 27
byte 1 28
byte 1 29
byte 1 30
byte 1 31
byte 1 32
byte 1 33
byte 1 34
byte 1 35
byte 1 36
byte 1 37
byte 1 38
byte 1 39
byte 1 40
byte 1 41
byte 1 42
byte 1 43
byte 1 44
byte 1 45
byte 1 46
byte 1 47
byte 1 48
byte 1 49
byte 1 50
byte 1 51
byte 1 52
byte 1 53
byte 1 54
byte 1 55
byte 1 56
byte 1 57
byte 1 58
byte 1 59
byte 1 60
byte 1 61
byte 1 62
byte 1 63
byte 1 64
byte 1 97
byte 1 98
byte 1 99
byte 1 100
byte 1 101
byte 1 102
byte 1 103
byte 1 104
byte 1 105
byte 1 106
byte 1 107
byte 1 108
byte 1 109
byte 1 110
byte 1 111
byte 1 112
byte 1 113
byte 1 114
byte 1 115
byte 1 116
byte 1 117
byte 1 118
byte 1 119
byte 1 120
byte 1 121
byte 1 122
byte 1 91
byte 1 92
byte 1 93
byte 1 94
byte 1 95
byte 1 96
byte 1 97
byte 1 98
byte 1 99
byte 1 100
byte 1 101
byte 1 102
byte 1 103
byte 1 104
byte 1 105
byte 1 106
byte 1 107
byte 1 108
byte 1 109
byte 1 110
byte 1 111
byte 1 112
byte 1 113
byte 1 114
byte 1 115
byte 1 116
byte 1 117
byte 1 118
byte 1 119
byte 1 120
byte 1 121
byte 1 122
byte 1 123
byte 1 124
byte 1 125
byte 1 126
byte 1 127
byte 1 128
byte 1 129
byte 1 130
byte 1 131
byte 1 132
byte 1 133
byte 1 134
byte 1 135
byte 1 136
byte 1 137
byte 1 138
byte 1 139
byte 1 140
byte 1 141
byte 1 142
byte 1 143
byte 1 144
byte 1 145
byte 1 146
byte 1 147
byte 1 148
byte 1 149
byte 1 150
byte 1 151
byte 1 152
byte 1 153
byte 1 154
byte 1 155
byte 1 156
byte 1 157
byte 1 158
byte 1 159
byte 1 160
byte 1 161
byte 1 162
byte 1 163
byte 1 164
byte 1 165
byte 1 166
byte 1 167
byte 1 168
byte 1 169
byte 1 170
byte 1 171
byte 1 172
byte 1 173
byte 1 174
byte 1 175
byte 1 176
byte 1 177
byte 1 178
byte 1 179
byte 1 180
byte 1 181
byte 1 182
byte 1 183
byte 1 184
byte 1 185
byte 1 186
byte 1 187
byte 1 188
byte 1 189
byte 1 190
byte 1 191
byte 1 192
byte 1 193
byte 1 194
byte 1 195
byte 1 196
byte 1 197
byte 1 198
byte 1 199
byte 1 200
byte 1 201
byte 1 202
byte 1 203
byte 1 204
byte 1 205
byte 1 206
byte 1 207
byte 1 208
byte 1 209
byte 1 210
byte 1 211
byte 1 212
byte 1 213
byte 1 214
byte 1 215
byte 1 216
byte 1 217
byte 1 218
byte 1 219
byte 1 220
byte 1 221
byte 1 222
byte 1 223
byte 1 224
byte 1 225
byte 1 226
byte 1 227
byte 1 228
byte 1 229
byte 1 230
byte 1 231
byte 1 232
byte 1 233
byte 1 234
byte 1 235
byte 1 236
byte 1 237
byte 1 238
byte 1 239
byte 1 240
byte 1 241
byte 1 242
byte 1 243
byte 1 244
byte 1 245
byte 1 246
byte 1 247
byte 1 248
byte 1 249
byte 1 250
byte 1 251
byte 1 252
byte 1 253
byte 1 254
byte 1 255
bss
align 4
LABELV $40
skip 1024
data
align 4
LABELV $41
byte 4 0
export crc32_buffer
code
proc crc32_buffer 20 0
line 58
;20:}
;21:
;22:const byte locase[ 256 ] = {
;23:	0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
;24:	0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
;25:	0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,
;26:	0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
;27:	0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,
;28:	0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
;29:	0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,
;30:	0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
;31:	0x40,0x61,0x62,0x63,0x64,0x65,0x66,0x67,
;32:	0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,
;33:	0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,
;34:	0x78,0x79,0x7a,0x5b,0x5c,0x5d,0x5e,0x5f,
;35:	0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,
;36:	0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,
;37:	0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,
;38:	0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x7e,0x7f,
;39:	0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,
;40:	0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,
;41:	0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,
;42:	0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,
;43:	0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,
;44:	0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,
;45:	0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,
;46:	0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,
;47:	0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,
;48:	0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,
;49:	0xd0,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,
;50:	0xd8,0xd9,0xda,0xdb,0xdc,0xdd,0xde,0xdf,
;51:	0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,
;52:	0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,
;53:	0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,
;54:	0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff
;55:};
;56:
;57:uint32_t crc32_buffer(const byte *buf, uint32_t len)
;58:{
line 62
;59:	static uint32_t crc32_table[256];
;60:	static qboolean crc32_inited = qfalse;
;61:
;62:	uint32_t crc = UINT_MAX;
ADDRLP4 0
CNSTU4 4294967295
ASGNU4
line 64
;63:
;64:	if (!crc32_inited) {
ADDRGP4 $41
INDIRI4
CNSTI4 0
NEI4 $56
line 68
;65:		uint32_t c;
;66:		int i, j;
;67:
;68:		for (i = 0; i < 256; i++) {
ADDRLP4 12
CNSTI4 0
ASGNI4
LABELV $44
line 69
;69:			c = i;
ADDRLP4 4
ADDRLP4 12
INDIRI4
CVIU4 4
ASGNU4
line 70
;70:			for (j = 0; j < 8; j++)
ADDRLP4 8
CNSTI4 0
ASGNI4
LABELV $48
line 71
;71:				c = (c & 1) ? (c >> 1) ^ 0xEDB88320UL : c >> 1;
ADDRLP4 4
INDIRU4
CNSTU4 1
BANDU4
CNSTU4 0
EQU4 $53
ADDRLP4 16
ADDRLP4 4
INDIRU4
CNSTI4 1
RSHU4
CNSTU4 3988292384
BXORU4
ASGNU4
ADDRGP4 $54
JUMPV
LABELV $53
ADDRLP4 16
ADDRLP4 4
INDIRU4
CNSTI4 1
RSHU4
ASGNU4
LABELV $54
ADDRLP4 4
ADDRLP4 16
INDIRU4
ASGNU4
LABELV $49
line 70
ADDRLP4 8
ADDRLP4 8
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 8
LTI4 $48
line 73
;72:			
;73:			crc32_table[i] = c;
ADDRLP4 12
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 $40
ADDP4
ADDRLP4 4
INDIRU4
ASGNU4
line 74
;74:		}
LABELV $45
line 68
ADDRLP4 12
ADDRLP4 12
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 256
LTI4 $44
line 75
;75:		crc32_inited = qtrue;
ADDRGP4 $41
CNSTI4 1
ASGNI4
line 76
;76:	}
ADDRGP4 $56
JUMPV
LABELV $55
line 79
;77:
;78:	while (len--)
;79:		crc = crc32_table[(crc ^ *buf++) & 0xFF] ^ (crc >> 8);
ADDRLP4 4
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 4
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 0
ADDRLP4 0
INDIRU4
ADDRLP4 4
INDIRP4
INDIRU1
CVUI4 1
CVIU4 4
BXORU4
CNSTU4 255
BANDU4
CNSTI4 2
LSHU4
ADDRGP4 $40
ADDP4
INDIRU4
ADDRLP4 0
INDIRU4
CNSTI4 8
RSHU4
BXORU4
ASGNU4
LABELV $56
line 78
ADDRLP4 12
ADDRFP4 4
INDIRU4
ASGNU4
ADDRFP4 4
ADDRLP4 12
INDIRU4
CNSTU4 1
SUBU4
ASGNU4
ADDRLP4 12
INDIRU4
CNSTU4 0
NEU4 $55
line 81
;80:
;81:	return crc ^ UINT_MAX;
ADDRLP4 0
INDIRU4
CNSTU4 4294967295
BXORU4
RETU4
LABELV $39
endproc crc32_buffer 20 0
lit
align 1
LABELV hash_locase
byte 1 0
byte 1 1
byte 1 2
byte 1 3
byte 1 4
byte 1 5
byte 1 6
byte 1 7
byte 1 8
byte 1 9
byte 1 10
byte 1 11
byte 1 12
byte 1 13
byte 1 14
byte 1 15
byte 1 16
byte 1 17
byte 1 18
byte 1 19
byte 1 20
byte 1 21
byte 1 22
byte 1 23
byte 1 24
byte 1 25
byte 1 26
byte 1 27
byte 1 28
byte 1 29
byte 1 30
byte 1 31
byte 1 32
byte 1 33
byte 1 34
byte 1 35
byte 1 36
byte 1 37
byte 1 38
byte 1 39
byte 1 40
byte 1 41
byte 1 42
byte 1 43
byte 1 44
byte 1 45
byte 1 0
byte 1 47
byte 1 48
byte 1 49
byte 1 50
byte 1 51
byte 1 52
byte 1 53
byte 1 54
byte 1 55
byte 1 56
byte 1 57
byte 1 58
byte 1 59
byte 1 60
byte 1 61
byte 1 62
byte 1 63
byte 1 64
byte 1 97
byte 1 98
byte 1 99
byte 1 100
byte 1 101
byte 1 102
byte 1 103
byte 1 104
byte 1 105
byte 1 106
byte 1 107
byte 1 108
byte 1 109
byte 1 110
byte 1 111
byte 1 112
byte 1 113
byte 1 114
byte 1 115
byte 1 116
byte 1 117
byte 1 118
byte 1 119
byte 1 120
byte 1 121
byte 1 122
byte 1 91
byte 1 47
byte 1 93
byte 1 94
byte 1 95
byte 1 96
byte 1 97
byte 1 98
byte 1 99
byte 1 100
byte 1 101
byte 1 102
byte 1 103
byte 1 104
byte 1 105
byte 1 106
byte 1 107
byte 1 108
byte 1 109
byte 1 110
byte 1 111
byte 1 112
byte 1 113
byte 1 114
byte 1 115
byte 1 116
byte 1 117
byte 1 118
byte 1 119
byte 1 120
byte 1 121
byte 1 122
byte 1 123
byte 1 124
byte 1 125
byte 1 126
byte 1 127
byte 1 128
byte 1 129
byte 1 130
byte 1 131
byte 1 132
byte 1 133
byte 1 134
byte 1 135
byte 1 136
byte 1 137
byte 1 138
byte 1 139
byte 1 140
byte 1 141
byte 1 142
byte 1 143
byte 1 144
byte 1 145
byte 1 146
byte 1 147
byte 1 148
byte 1 149
byte 1 150
byte 1 151
byte 1 152
byte 1 153
byte 1 154
byte 1 155
byte 1 156
byte 1 157
byte 1 158
byte 1 159
byte 1 160
byte 1 161
byte 1 162
byte 1 163
byte 1 164
byte 1 165
byte 1 166
byte 1 167
byte 1 168
byte 1 169
byte 1 170
byte 1 171
byte 1 172
byte 1 173
byte 1 174
byte 1 175
byte 1 176
byte 1 177
byte 1 178
byte 1 179
byte 1 180
byte 1 181
byte 1 182
byte 1 183
byte 1 184
byte 1 185
byte 1 186
byte 1 187
byte 1 188
byte 1 189
byte 1 190
byte 1 191
byte 1 192
byte 1 193
byte 1 194
byte 1 195
byte 1 196
byte 1 197
byte 1 198
byte 1 199
byte 1 200
byte 1 201
byte 1 202
byte 1 203
byte 1 204
byte 1 205
byte 1 206
byte 1 207
byte 1 208
byte 1 209
byte 1 210
byte 1 211
byte 1 212
byte 1 213
byte 1 214
byte 1 215
byte 1 216
byte 1 217
byte 1 218
byte 1 219
byte 1 220
byte 1 221
byte 1 222
byte 1 223
byte 1 224
byte 1 225
byte 1 226
byte 1 227
byte 1 228
byte 1 229
byte 1 230
byte 1 231
byte 1 232
byte 1 233
byte 1 234
byte 1 235
byte 1 236
byte 1 237
byte 1 238
byte 1 239
byte 1 240
byte 1 241
byte 1 242
byte 1 243
byte 1 244
byte 1 245
byte 1 246
byte 1 247
byte 1 248
byte 1 249
byte 1 250
byte 1 251
byte 1 252
byte 1 253
byte 1 254
byte 1 255
export Com_GenerateHashValue
code
proc Com_GenerateHashValue 24 0
ADDRFP4 4
ADDRFP4 4
INDIRU4
ASGNU4
line 126
;82:}
;83:
;84:
;85:/*
;86:Com_GenerateHashValue: used in renderer and filesystem
;87:*/
;88:// ASCII lowcase conversion table with '\\' turned to '/' and '.' to '\0'
;89:static const byte hash_locase[ 256 ] =
;90:{
;91:	0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
;92:	0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
;93:	0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,
;94:	0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
;95:	0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,
;96:	0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x00,0x2f,
;97:	0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,
;98:	0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
;99:	0x40,0x61,0x62,0x63,0x64,0x65,0x66,0x67,
;100:	0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,
;101:	0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,
;102:	0x78,0x79,0x7a,0x5b,0x2f,0x5d,0x5e,0x5f,
;103:	0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,
;104:	0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,
;105:	0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,
;106:	0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x7e,0x7f,
;107:	0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,
;108:	0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,
;109:	0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,
;110:	0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,
;111:	0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,
;112:	0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,
;113:	0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,
;114:	0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,
;115:	0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,
;116:	0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,
;117:	0xd0,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,
;118:	0xd8,0xd9,0xda,0xdb,0xdc,0xdd,0xde,0xdf,
;119:	0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,
;120:	0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,
;121:	0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,
;122:	0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff
;123:};
;124:
;125:uint64_t Com_GenerateHashValue( const char *fname, const uint64_t size )
;126:{
line 131
;127:	const byte *s;
;128:	uint64_t hash;
;129:	int c;
;130:
;131:	s = (byte *)fname;
ADDRLP4 8
ADDRFP4 0
INDIRP4
ASGNP4
line 132
;132:	hash = 0;
ADDRLP4 0
CNSTU4 0
ASGNU4
ADDRGP4 $60
JUMPV
LABELV $59
line 134
;133:	
;134:	while ( (c = hash_locase[(byte)*s++]) != '\0' ) {
line 135
;135:		hash = hash * 101 + c;
ADDRLP4 0
ADDRLP4 0
INDIRU4
CNSTU4 101
MULU4
ADDRLP4 4
INDIRI4
CVIU4 4
ADDU4
ASGNU4
line 136
;136:	}
LABELV $60
line 134
ADDRLP4 12
ADDRLP4 8
INDIRP4
ASGNP4
ADDRLP4 8
ADDRLP4 12
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 16
ADDRLP4 12
INDIRP4
INDIRU1
CVUI4 1
ADDRGP4 hash_locase
ADDP4
INDIRU1
CVUI4 1
ASGNI4
ADDRLP4 4
ADDRLP4 16
INDIRI4
ASGNI4
ADDRLP4 16
INDIRI4
CNSTI4 0
NEI4 $59
line 138
;137:	
;138:	hash = (hash ^ (hash >> 10) ^ (hash >> 20));
ADDRLP4 0
ADDRLP4 0
INDIRU4
ADDRLP4 0
INDIRU4
CNSTI4 10
RSHU4
BXORU4
ADDRLP4 0
INDIRU4
CNSTI4 20
RSHU4
BXORU4
ASGNU4
line 139
;139:	hash &= (size-1);
ADDRLP4 0
ADDRLP4 0
INDIRU4
ADDRFP4 4
INDIRU4
CNSTU4 1
SUBU4
BANDU4
ASGNU4
line 141
;140:
;141:	return hash;
ADDRLP4 0
INDIRU4
RETU4
LABELV $58
endproc Com_GenerateHashValue 24 0
export Com_StringContains
proc Com_StringContains 24 4
line 145
;142:}
;143:
;144:const char *Com_StringContains( const char *str1, const char *str2, uint64_t len2 )
;145:{
line 148
;146:	int64_t len, i, j;
;147:
;148:	len = strlen(str1) - len2;
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 12
ADDRGP4 strlen
CALLU4
ASGNU4
ADDRLP4 8
ADDRLP4 12
INDIRU4
ADDRFP4 8
INDIRU4
SUBU4
CVUI4 4
ASGNI4
line 149
;149:	for (i = 0; i <= len; i++, str1++) {
ADDRLP4 4
CNSTI4 0
ASGNI4
ADDRGP4 $66
JUMPV
LABELV $63
line 150
;150:		for (j = 0; str2[j]; j++) {
ADDRLP4 0
CNSTI4 0
ASGNI4
ADDRGP4 $70
JUMPV
LABELV $67
line 151
;151:			if (locase[(byte)str1[j]] != locase[(byte)str2[j]]) {
ADDRLP4 20
ADDRGP4 locase
ASGNP4
ADDRLP4 0
INDIRI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRI1
CVII4 1
CVIU4 4
CVUU1 4
CVUI4 1
ADDRLP4 20
INDIRP4
ADDP4
INDIRU1
CVUI4 1
ADDRLP4 0
INDIRI4
ADDRFP4 4
INDIRP4
ADDP4
INDIRI1
CVII4 1
CVIU4 4
CVUU1 4
CVUI4 1
ADDRLP4 20
INDIRP4
ADDP4
INDIRU1
CVUI4 1
EQI4 $71
line 152
;152:				break;
ADDRGP4 $69
JUMPV
LABELV $71
line 154
;153:			}
;154:		}
LABELV $68
line 150
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $70
ADDRLP4 0
INDIRI4
ADDRFP4 4
INDIRP4
ADDP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $67
LABELV $69
line 155
;155:		if (!str2[j]) {
ADDRLP4 0
INDIRI4
ADDRFP4 4
INDIRP4
ADDP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $73
line 156
;156:			return str1;
ADDRFP4 0
INDIRP4
RETP4
ADDRGP4 $62
JUMPV
LABELV $73
line 158
;157:		}
;158:	}
LABELV $64
line 149
ADDRLP4 4
ADDRLP4 4
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
LABELV $66
ADDRLP4 4
INDIRI4
ADDRLP4 8
INDIRI4
LEI4 $63
line 159
;159:	return NULL;
CNSTP4 0
RETP4
LABELV $62
endproc Com_StringContains 24 4
export Com_FilterExt
proc Com_FilterExt 1040 12
line 163
;160:}
;161:
;162:qboolean Com_FilterExt( const char *filter, const char *name )
;163:{
ADDRGP4 $77
JUMPV
LABELV $76
line 168
;164:	char buf[ MAX_TOKEN_CHARS ];
;165:	const char *ptr;
;166:	uint32_t i;
;167:
;168:	while ( *filter ) {
line 169
;169:		if ( *filter == '*' ) {
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 42
NEI4 $79
line 170
;170:			filter++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 171
;171:			for ( i = 0; *filter != '\0' && i < sizeof(buf)-1; i++ ) {
ADDRLP4 0
CNSTU4 0
ASGNU4
ADDRGP4 $84
JUMPV
LABELV $81
line 172
;172:				if ( *filter == '*' || *filter == '?' )
ADDRLP4 1032
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 1032
INDIRI4
CNSTI4 42
EQI4 $87
ADDRLP4 1032
INDIRI4
CNSTI4 63
NEI4 $85
LABELV $87
line 173
;173:					break;
ADDRGP4 $83
JUMPV
LABELV $85
line 174
;174:				buf[i] = *filter++;
ADDRLP4 1036
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 1036
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 0
INDIRU4
ADDRLP4 4
ADDP4
ADDRLP4 1036
INDIRP4
INDIRI1
ASGNI1
line 175
;175:			}
LABELV $82
line 171
ADDRLP4 0
ADDRLP4 0
INDIRU4
CNSTU4 1
ADDU4
ASGNU4
LABELV $84
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
EQI4 $88
ADDRLP4 0
INDIRU4
CNSTU4 1023
LTU4 $81
LABELV $88
LABELV $83
line 176
;176:			buf[ i ] = '\0';
ADDRLP4 0
INDIRU4
ADDRLP4 4
ADDP4
CNSTI1 0
ASGNI1
line 177
;177:			if ( i ) {
ADDRLP4 0
INDIRU4
CNSTU4 0
EQU4 $89
line 178
;178:				ptr = Com_StringContains( name, buf, i );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 4
ARGP4
ADDRLP4 0
INDIRU4
ARGU4
ADDRLP4 1032
ADDRGP4 Com_StringContains
CALLP4
ASGNP4
ADDRLP4 1028
ADDRLP4 1032
INDIRP4
ASGNP4
line 179
;179:				if ( !ptr )
ADDRLP4 1028
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $91
line 180
;180:					return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $75
JUMPV
LABELV $91
line 181
;181:				name = ptr + i;
ADDRFP4 4
ADDRLP4 0
INDIRU4
ADDRLP4 1028
INDIRP4
ADDP4
ASGNP4
line 182
;182:			} else if ( *filter == '\0' ) {
ADDRGP4 $80
JUMPV
LABELV $89
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $80
line 183
;183:				return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $75
JUMPV
line 185
;184:			}
;185:		}
LABELV $79
line 186
;186:		else if ( *filter == '?' ) {
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 63
NEI4 $95
line 187
;187:			if ( *name == '\0' )
ADDRFP4 4
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $97
line 188
;188:				return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $75
JUMPV
LABELV $97
line 189
;189:			filter++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 190
;190:			name++;
ADDRFP4 4
ADDRFP4 4
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 191
;191:		}
ADDRGP4 $96
JUMPV
LABELV $95
line 192
;192:		else {
line 193
;193:			if ( locase[(byte)*filter] != locase[(byte)*name] )
ADDRLP4 1032
ADDRGP4 locase
ASGNP4
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CVIU4 4
CVUU1 4
CVUI4 1
ADDRLP4 1032
INDIRP4
ADDP4
INDIRU1
CVUI4 1
ADDRFP4 4
INDIRP4
INDIRI1
CVII4 1
CVIU4 4
CVUU1 4
CVUI4 1
ADDRLP4 1032
INDIRP4
ADDP4
INDIRU1
CVUI4 1
EQI4 $99
line 194
;194:				return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $75
JUMPV
LABELV $99
line 195
;195:			filter++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 196
;196:			name++;
ADDRFP4 4
ADDRFP4 4
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 197
;197:		}
LABELV $96
LABELV $80
line 198
;198:	}
LABELV $77
line 168
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $76
line 199
;199:	if ( *name ) {
ADDRFP4 4
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
EQI4 $101
line 200
;200:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $75
JUMPV
LABELV $101
line 202
;201:	}
;202:	return qtrue;
CNSTI4 1
RETI4
LABELV $75
endproc Com_FilterExt 1040 12
export Com_Filter
proc Com_Filter 1060 12
line 207
;203:}
;204:
;205:
;206:int Com_Filter( const char *filter, const char *name )
;207:{
ADDRGP4 $105
JUMPV
LABELV $104
line 212
;208:	char buf[ MAX_TOKEN_CHARS ];
;209:	const char *ptr;
;210:	int i, found;
;211:
;212:	while (*filter) {
line 213
;213:		if (*filter == '*') {
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 42
NEI4 $107
line 214
;214:			filter++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 215
;215:			for (i = 0; *filter; i++) {
ADDRLP4 0
CNSTI4 0
ASGNI4
ADDRGP4 $112
JUMPV
LABELV $109
line 216
;216:				if (*filter == '*' || *filter == '?')
ADDRLP4 1036
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 1036
INDIRI4
CNSTI4 42
EQI4 $115
ADDRLP4 1036
INDIRI4
CNSTI4 63
NEI4 $113
LABELV $115
line 217
;217:					break;
ADDRGP4 $111
JUMPV
LABELV $113
line 218
;218:				buf[i] = *filter;
ADDRLP4 0
INDIRI4
ADDRLP4 4
ADDP4
ADDRFP4 0
INDIRP4
INDIRI1
ASGNI1
line 219
;219:				filter++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 220
;220:			}
LABELV $110
line 215
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $112
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $109
LABELV $111
line 221
;221:			buf[i] = '\0';
ADDRLP4 0
INDIRI4
ADDRLP4 4
ADDP4
CNSTI1 0
ASGNI1
line 222
;222:			if ( i ) {
ADDRLP4 0
INDIRI4
CNSTI4 0
EQI4 $108
line 223
;223:				ptr = Com_StringContains( name, buf, i );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 4
ARGP4
ADDRLP4 0
INDIRI4
CVIU4 4
ARGU4
ADDRLP4 1036
ADDRGP4 Com_StringContains
CALLP4
ASGNP4
ADDRLP4 1032
ADDRLP4 1036
INDIRP4
ASGNP4
line 224
;224:				if ( !ptr )
ADDRLP4 1032
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $118
line 225
;225:					return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $103
JUMPV
LABELV $118
line 226
;226:				name = ptr + i;
ADDRFP4 4
ADDRLP4 0
INDIRI4
ADDRLP4 1032
INDIRP4
ADDP4
ASGNP4
line 227
;227:			}
line 228
;228:		}
ADDRGP4 $108
JUMPV
LABELV $107
line 229
;229:		else if (*filter == '?') {
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 63
NEI4 $120
line 230
;230:			filter++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 231
;231:			name++;
ADDRFP4 4
ADDRFP4 4
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 232
;232:		}
ADDRGP4 $121
JUMPV
LABELV $120
line 233
;233:		else if (*filter == '[' && *(filter+1) == '[') {
ADDRLP4 1036
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 1036
INDIRP4
INDIRI1
CVII4 1
CNSTI4 91
NEI4 $122
ADDRLP4 1036
INDIRP4
CNSTI4 1
ADDP4
INDIRI1
CVII4 1
CNSTI4 91
NEI4 $122
line 234
;234:			filter++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 235
;235:		}
ADDRGP4 $123
JUMPV
LABELV $122
line 236
;236:		else if (*filter == '[') {
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 91
NEI4 $124
line 237
;237:			filter++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 238
;238:			found = qfalse;
ADDRLP4 1028
CNSTI4 0
ASGNI4
ADDRGP4 $127
JUMPV
LABELV $126
line 239
;239:			while(*filter && !found) {
line 240
;240:				if (*filter == ']' && *(filter+1) != ']') break;
ADDRLP4 1040
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 1040
INDIRP4
INDIRI1
CVII4 1
CNSTI4 93
NEI4 $129
ADDRLP4 1040
INDIRP4
CNSTI4 1
ADDP4
INDIRI1
CVII4 1
CNSTI4 93
EQI4 $129
ADDRGP4 $128
JUMPV
LABELV $129
line 241
;241:				if (*(filter+1) == '-' && *(filter+2) && (*(filter+2) != ']' || *(filter+3) == ']')) {
ADDRLP4 1044
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 1044
INDIRP4
CNSTI4 1
ADDP4
INDIRI1
CVII4 1
CNSTI4 45
NEI4 $131
ADDRLP4 1044
INDIRP4
CNSTI4 2
ADDP4
INDIRI1
CVII4 1
CNSTI4 0
EQI4 $131
ADDRLP4 1044
INDIRP4
CNSTI4 2
ADDP4
INDIRI1
CVII4 1
CNSTI4 93
NEI4 $133
ADDRLP4 1044
INDIRP4
CNSTI4 3
ADDP4
INDIRI1
CVII4 1
CNSTI4 93
NEI4 $131
LABELV $133
line 242
;242:					if (locase[(byte)*name] >= locase[(byte)*filter] &&
ADDRLP4 1048
ADDRGP4 locase
ASGNP4
ADDRLP4 1052
ADDRFP4 4
INDIRP4
INDIRI1
CVII4 1
CVIU4 4
CVUU1 4
CVUI4 1
ADDRLP4 1048
INDIRP4
ADDP4
INDIRU1
CVUI4 1
ASGNI4
ADDRLP4 1056
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 1052
INDIRI4
ADDRLP4 1056
INDIRP4
INDIRI1
CVII4 1
CVIU4 4
CVUU1 4
CVUI4 1
ADDRLP4 1048
INDIRP4
ADDP4
INDIRU1
CVUI4 1
LTI4 $134
ADDRLP4 1052
INDIRI4
ADDRLP4 1056
INDIRP4
CNSTI4 2
ADDP4
INDIRI1
CVII4 1
CVIU4 4
CVUU1 4
CVUI4 1
ADDRLP4 1048
INDIRP4
ADDP4
INDIRU1
CVUI4 1
GTI4 $134
line 244
;243:						locase[(byte)*name] <= locase[(byte)*(filter+2)])
;244:							found = qtrue;
ADDRLP4 1028
CNSTI4 1
ASGNI4
LABELV $134
line 245
;245:					filter += 3;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 3
ADDP4
ASGNP4
line 246
;246:				}
ADDRGP4 $132
JUMPV
LABELV $131
line 247
;247:				else {
line 248
;248:					if (locase[(byte)*filter] == locase[(byte)*name])
ADDRLP4 1048
ADDRGP4 locase
ASGNP4
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CVIU4 4
CVUU1 4
CVUI4 1
ADDRLP4 1048
INDIRP4
ADDP4
INDIRU1
CVUI4 1
ADDRFP4 4
INDIRP4
INDIRI1
CVII4 1
CVIU4 4
CVUU1 4
CVUI4 1
ADDRLP4 1048
INDIRP4
ADDP4
INDIRU1
CVUI4 1
NEI4 $136
line 249
;249:						found = qtrue;
ADDRLP4 1028
CNSTI4 1
ASGNI4
LABELV $136
line 250
;250:					filter++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 251
;251:				}
LABELV $132
line 252
;252:			}
LABELV $127
line 239
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
EQI4 $138
ADDRLP4 1028
INDIRI4
CNSTI4 0
EQI4 $126
LABELV $138
LABELV $128
line 253
;253:			if (!found) return qfalse;
ADDRLP4 1028
INDIRI4
CNSTI4 0
NEI4 $142
CNSTI4 0
RETI4
ADDRGP4 $103
JUMPV
LABELV $141
line 254
;254:			while (*filter) {
line 255
;255:				if (*filter == ']' && *(filter+1) != ']') break;
ADDRLP4 1040
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 1040
INDIRP4
INDIRI1
CVII4 1
CNSTI4 93
NEI4 $144
ADDRLP4 1040
INDIRP4
CNSTI4 1
ADDP4
INDIRI1
CVII4 1
CNSTI4 93
EQI4 $144
ADDRGP4 $143
JUMPV
LABELV $144
line 256
;256:				filter++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 257
;257:			}
LABELV $142
line 254
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $141
LABELV $143
line 258
;258:			filter++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 259
;259:			name++;
ADDRFP4 4
ADDRFP4 4
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 260
;260:		}
ADDRGP4 $125
JUMPV
LABELV $124
line 261
;261:		else {
line 262
;262:			if (locase[(byte)*filter] != locase[(byte)*name])
ADDRLP4 1040
ADDRGP4 locase
ASGNP4
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CVIU4 4
CVUU1 4
CVUI4 1
ADDRLP4 1040
INDIRP4
ADDP4
INDIRU1
CVUI4 1
ADDRFP4 4
INDIRP4
INDIRI1
CVII4 1
CVIU4 4
CVUU1 4
CVUI4 1
ADDRLP4 1040
INDIRP4
ADDP4
INDIRU1
CVUI4 1
EQI4 $146
line 263
;263:				return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $103
JUMPV
LABELV $146
line 264
;264:			filter++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 265
;265:			name++;
ADDRFP4 4
ADDRFP4 4
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 266
;266:		}
LABELV $125
LABELV $123
LABELV $121
LABELV $108
line 267
;267:	}
LABELV $105
line 212
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $104
line 268
;268:	return qtrue;
CNSTI4 1
RETI4
LABELV $103
endproc Com_Filter 1060 12
export Com_FilterPath
proc Com_FilterPath 144 8
line 272
;269:}
;270:
;271:int Com_FilterPath( const char *filter, const char *name )
;272:{
line 277
;273:	int i;
;274:	char new_filter[MAX_GDR_PATH];
;275:	char new_name[MAX_GDR_PATH];
;276:
;277:	for (i = 0; i < MAX_GDR_PATH-1 && filter[i]; i++) {
ADDRLP4 0
CNSTI4 0
ASGNI4
ADDRGP4 $152
JUMPV
LABELV $149
line 278
;278:		if ( filter[i] == '\\' || filter[i] == ':' ) {
ADDRLP4 132
ADDRLP4 0
INDIRI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 132
INDIRI4
CNSTI4 92
EQI4 $155
ADDRLP4 132
INDIRI4
CNSTI4 58
NEI4 $153
LABELV $155
line 279
;279:			new_filter[i] = '/';
ADDRLP4 0
INDIRI4
ADDRLP4 4
ADDP4
CNSTI1 47
ASGNI1
line 280
;280:		}
ADDRGP4 $154
JUMPV
LABELV $153
line 281
;281:		else {
line 282
;282:			new_filter[i] = filter[i];
ADDRLP4 0
INDIRI4
ADDRLP4 4
ADDP4
ADDRLP4 0
INDIRI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRI1
ASGNI1
line 283
;283:		}
LABELV $154
line 284
;284:	}
LABELV $150
line 277
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $152
ADDRLP4 0
INDIRI4
CNSTI4 63
GEI4 $156
ADDRLP4 0
INDIRI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $149
LABELV $156
line 285
;285:	new_filter[i] = '\0';
ADDRLP4 0
INDIRI4
ADDRLP4 4
ADDP4
CNSTI1 0
ASGNI1
line 286
;286:	for (i = 0; i < MAX_GDR_PATH-1 && name[i]; i++) {
ADDRLP4 0
CNSTI4 0
ASGNI4
ADDRGP4 $160
JUMPV
LABELV $157
line 287
;287:		if ( name[i] == '\\' || name[i] == ':' ) {
ADDRLP4 136
ADDRLP4 0
INDIRI4
ADDRFP4 4
INDIRP4
ADDP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 136
INDIRI4
CNSTI4 92
EQI4 $163
ADDRLP4 136
INDIRI4
CNSTI4 58
NEI4 $161
LABELV $163
line 288
;288:			new_name[i] = '/';
ADDRLP4 0
INDIRI4
ADDRLP4 68
ADDP4
CNSTI1 47
ASGNI1
line 289
;289:		}
ADDRGP4 $162
JUMPV
LABELV $161
line 290
;290:		else {
line 291
;291:			new_name[i] = name[i];
ADDRLP4 0
INDIRI4
ADDRLP4 68
ADDP4
ADDRLP4 0
INDIRI4
ADDRFP4 4
INDIRP4
ADDP4
INDIRI1
ASGNI1
line 292
;292:		}
LABELV $162
line 293
;293:	}
LABELV $158
line 286
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $160
ADDRLP4 0
INDIRI4
CNSTI4 63
GEI4 $164
ADDRLP4 0
INDIRI4
ADDRFP4 4
INDIRP4
ADDP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $157
LABELV $164
line 294
;294:	new_name[i] = '\0';
ADDRLP4 0
INDIRI4
ADDRLP4 68
ADDP4
CNSTI1 0
ASGNI1
line 295
;295:	return Com_Filter( new_filter, new_name );
ADDRLP4 4
ARGP4
ADDRLP4 68
ARGP4
ADDRLP4 140
ADDRGP4 Com_Filter
CALLI4
ASGNI4
ADDRLP4 140
INDIRI4
RETI4
LABELV $148
endproc Com_FilterPath 144 8
export Com_HasPatterns
proc Com_HasPatterns 12 0
line 299
;296:}
;297:
;298:qboolean Com_HasPatterns( const char *str )
;299:{
ADDRGP4 $167
JUMPV
LABELV $166
line 302
;300:	int c;
;301:
;302:	while ( (c = *str++) != '\0' ) {
line 303
;303:		if ( c == '*' || c == '?' ) {
ADDRLP4 0
INDIRI4
CNSTI4 42
EQI4 $171
ADDRLP4 0
INDIRI4
CNSTI4 63
NEI4 $169
LABELV $171
line 304
;304:			return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $165
JUMPV
LABELV $169
line 306
;305:		}
;306:	}
LABELV $167
line 302
ADDRLP4 4
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 4
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 8
ADDRLP4 4
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 0
ADDRLP4 8
INDIRI4
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 0
NEI4 $166
line 308
;307:
;308:	return qfalse;
CNSTI4 0
RETI4
LABELV $165
endproc Com_HasPatterns 12 0
export COM_DefaultExtension
proc COM_DefaultExtension 20 12
line 320
;309:}
;310:
;311:/*
;312:==================
;313:COM_DefaultExtension
;314:
;315:if path doesn't have an extension, then append
;316: the specified one (which should include the .)
;317:==================
;318:*/
;319:void COM_DefaultExtension( char *path, uint64_t maxSize, const char *extension )
;320:{
line 321
;321:	const char *dot = (const char *)strrchr(path, '.'), *slash;
ADDRFP4 0
INDIRP4
ARGP4
CNSTI4 46
ARGI4
ADDRLP4 8
ADDRGP4 strrchr
CALLI4
ASGNI4
ADDRLP4 0
ADDRLP4 8
INDIRI4
CVIU4 4
CVUP4 4
ASGNP4
line 322
;322:	if (dot && ((slash = (const char *)strrchr(path, '/')) == NULL || slash < dot))
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $173
ADDRFP4 0
INDIRP4
ARGP4
CNSTI4 47
ARGI4
ADDRLP4 12
ADDRGP4 strrchr
CALLI4
ASGNI4
ADDRLP4 16
ADDRLP4 12
INDIRI4
CVIU4 4
CVUP4 4
ASGNP4
ADDRLP4 4
ADDRLP4 16
INDIRP4
ASGNP4
ADDRLP4 16
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $175
ADDRLP4 4
INDIRP4
CVPU4 4
ADDRLP4 0
INDIRP4
CVPU4 4
GEU4 $173
LABELV $175
line 323
;323:		return;
ADDRGP4 $172
JUMPV
LABELV $173
line 325
;324:	else
;325:		N_strcat(path, maxSize, extension);
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRU4
ARGU4
ADDRFP4 8
INDIRP4
ARGP4
ADDRGP4 N_strcat
CALLV
pop
line 326
;326:}
LABELV $172
endproc COM_DefaultExtension 20 12
export COM_StripExtension
proc COM_StripExtension 24 12
line 330
;327:
;328:
;329:void COM_StripExtension(const char *in, char *out, uint64_t destsize)
;330:{
line 331
;331:	const char *dot = (char *)strrchr(in, '.'), *slash;
ADDRFP4 0
INDIRP4
ARGP4
CNSTI4 46
ARGI4
ADDRLP4 8
ADDRGP4 strrchr
CALLI4
ASGNI4
ADDRLP4 0
ADDRLP4 8
INDIRI4
CVIU4 4
CVUP4 4
ASGNP4
line 333
;332:
;333:	if (dot && ((slash = (char *)strrchr(in, '/')) == NULL || slash < dot))
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $177
ADDRFP4 0
INDIRP4
ARGP4
CNSTI4 47
ARGI4
ADDRLP4 12
ADDRGP4 strrchr
CALLI4
ASGNI4
ADDRLP4 16
ADDRLP4 12
INDIRI4
CVIU4 4
CVUP4 4
ASGNP4
ADDRLP4 4
ADDRLP4 16
INDIRP4
ASGNP4
ADDRLP4 16
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $179
ADDRLP4 4
INDIRP4
CVPU4 4
ADDRLP4 0
INDIRP4
CVPU4 4
GEU4 $177
LABELV $179
line 334
;334:		destsize = (destsize < dot-in+1 ? destsize : dot-in+1);
ADDRFP4 8
INDIRU4
ADDRLP4 0
INDIRP4
CVPU4 4
ADDRFP4 0
INDIRP4
CVPU4 4
SUBU4
CVUI4 4
CNSTI4 1
ADDI4
CVIU4 4
GEU4 $181
ADDRLP4 20
ADDRFP4 8
INDIRU4
ASGNU4
ADDRGP4 $182
JUMPV
LABELV $181
ADDRLP4 20
ADDRLP4 0
INDIRP4
CVPU4 4
ADDRFP4 0
INDIRP4
CVPU4 4
SUBU4
CVUI4 4
CNSTI4 1
ADDI4
CVIU4 4
ASGNU4
LABELV $182
ADDRFP4 8
ADDRLP4 20
INDIRU4
ASGNU4
LABELV $177
line 336
;335:
;336:	if ( in == out && destsize > 1 )
ADDRFP4 0
INDIRP4
CVPU4 4
ADDRFP4 4
INDIRP4
CVPU4 4
NEU4 $183
ADDRFP4 8
INDIRU4
CNSTU4 1
LEU4 $183
line 337
;337:		out[destsize-1] = '\0';
ADDRFP4 8
INDIRU4
CNSTU4 1
SUBU4
ADDRFP4 4
INDIRP4
ADDP4
CNSTI1 0
ASGNI1
ADDRGP4 $184
JUMPV
LABELV $183
line 339
;338:	else
;339:		N_strncpy(out, in, destsize);
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 8
INDIRU4
ARGU4
ADDRGP4 N_strncpy
CALLV
pop
LABELV $184
line 340
;340:}
LABELV $176
endproc COM_StripExtension 24 12
export Com_Split
proc Com_Split 20 0
line 348
;341:
;342:/*
;343:============
;344:Com_Split
;345:============
;346:*/
;347:int Com_Split( char *in, char **out, uint64_t outsz, int delim )
;348:{
line 350
;349:	int c;
;350:	char **o = out, **end = out + outsz;
ADDRLP4 8
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 4
ADDRFP4 8
INDIRU4
CNSTI4 2
LSHU4
ADDRFP4 4
INDIRP4
ADDP4
ASGNP4
line 352
;351:	// skip leading spaces
;352:	if ( delim >= ' ' ) {
ADDRFP4 12
INDIRI4
CNSTI4 32
LTI4 $186
ADDRGP4 $189
JUMPV
LABELV $188
line 354
;353:		while( (c = *in) != '\0' && c <= ' ' )
;354:			in++; 
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
LABELV $189
line 353
ADDRLP4 12
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 0
ADDRLP4 12
INDIRI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 0
EQI4 $191
ADDRLP4 0
INDIRI4
CNSTI4 32
LEI4 $188
LABELV $191
line 355
;355:	}
LABELV $186
line 356
;356:	*out = in; out++;
ADDRFP4 4
INDIRP4
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 4
ADDRFP4 4
INDIRP4
CNSTI4 4
ADDP4
ASGNP4
ADDRGP4 $193
JUMPV
line 357
;357:	while( out < end ) {
LABELV $195
line 359
;358:		while( (c = *in) != '\0' && c != delim )
;359:			in++; 
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
LABELV $196
line 358
ADDRLP4 12
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 0
ADDRLP4 12
INDIRI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 0
EQI4 $198
ADDRLP4 0
INDIRI4
ADDRFP4 12
INDIRI4
NEI4 $195
LABELV $198
line 360
;360:		*in = '\0';
ADDRFP4 0
INDIRP4
CNSTI1 0
ASGNI1
line 361
;361:		if ( !c ) {
ADDRLP4 0
INDIRI4
CNSTI4 0
NEI4 $199
line 363
;362:			// don't count last null value
;363:			if ( out[-1][0] == '\0' )
ADDRFP4 4
INDIRP4
CNSTI4 -4
ADDP4
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $210
line 364
;364:				out--;
ADDRFP4 4
ADDRFP4 4
INDIRP4
CNSTI4 -4
ADDP4
ASGNP4
line 365
;365:			break;
ADDRGP4 $210
JUMPV
LABELV $199
line 367
;366:		}
;367:		in++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 369
;368:		// skip leading spaces
;369:		if ( delim >= ' ' ) {
ADDRFP4 12
INDIRI4
CNSTI4 32
LTI4 $203
ADDRGP4 $206
JUMPV
LABELV $205
line 371
;370:			while( (c = *in) != '\0' && c <= ' ' )
;371:				in++; 
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
LABELV $206
line 370
ADDRLP4 16
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 0
ADDRLP4 16
INDIRI4
ASGNI4
ADDRLP4 16
INDIRI4
CNSTI4 0
EQI4 $208
ADDRLP4 0
INDIRI4
CNSTI4 32
LEI4 $205
LABELV $208
line 372
;372:		}
LABELV $203
line 373
;373:		*out = in; out++;
ADDRFP4 4
INDIRP4
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 4
ADDRFP4 4
INDIRP4
CNSTI4 4
ADDP4
ASGNP4
line 374
;374:	}
LABELV $193
line 357
ADDRFP4 4
INDIRP4
CVPU4 4
ADDRLP4 4
INDIRP4
CVPU4 4
LTU4 $196
ADDRGP4 $210
JUMPV
LABELV $209
line 377
;375:	// sanitize last value
;376:	while( (c = *in) != '\0' && c != delim )
;377:		in++; 
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
LABELV $210
line 376
ADDRLP4 12
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 0
ADDRLP4 12
INDIRI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 0
EQI4 $212
ADDRLP4 0
INDIRI4
ADDRFP4 12
INDIRI4
NEI4 $209
LABELV $212
line 378
;378:	*in = '\0';
ADDRFP4 0
INDIRP4
CNSTI1 0
ASGNI1
line 379
;379:	c = out - o;
ADDRLP4 0
ADDRFP4 4
INDIRP4
CVPU4 4
ADDRLP4 8
INDIRP4
CVPU4 4
SUBU4
CVUI4 4
CNSTI4 4
DIVI4
ASGNI4
ADDRGP4 $214
JUMPV
LABELV $213
line 381
;380:	// set remaining out pointers
;381:	while( out < end ) {
line 382
;382:		*out = in; out++;
ADDRFP4 4
INDIRP4
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 4
ADDRFP4 4
INDIRP4
CNSTI4 4
ADDP4
ASGNP4
line 383
;383:	}
LABELV $214
line 381
ADDRFP4 4
INDIRP4
CVPU4 4
ADDRLP4 4
INDIRP4
CVPU4 4
LTU4 $213
line 384
;384:	return c;
ADDRLP4 0
INDIRI4
RETI4
LABELV $185
endproc Com_Split 20 0
export CopyShortSwap
proc CopyShortSwap 8 0
line 389
;385:}
;386:
;387:
;388:void CopyShortSwap(void *dest, void *src)
;389:{
line 390
;390:	byte *to = (byte *)dest, *from = (byte *)src;
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 4
ADDRFP4 4
INDIRP4
ASGNP4
line 392
;391:
;392:	to[0] = from[1];
ADDRLP4 0
INDIRP4
ADDRLP4 4
INDIRP4
CNSTI4 1
ADDP4
INDIRU1
ASGNU1
line 393
;393:	to[1] = from[0];
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ADDRLP4 4
INDIRP4
INDIRU1
ASGNU1
line 394
;394:}
LABELV $216
endproc CopyShortSwap 8 0
export CopyIntSwap
proc CopyIntSwap 8 0
line 397
;395:
;396:void CopyIntSwap(void *dest, void *src)
;397:{
line 398
;398:	byte *to = (byte *)dest, *from = (byte *)src;
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 4
ADDRFP4 4
INDIRP4
ASGNP4
line 400
;399:
;400:	to[0] = from[3];
ADDRLP4 0
INDIRP4
ADDRLP4 4
INDIRP4
CNSTI4 3
ADDP4
INDIRU1
ASGNU1
line 401
;401:	to[1] = from[2];
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ADDRLP4 4
INDIRP4
CNSTI4 2
ADDP4
INDIRU1
ASGNU1
line 402
;402:	to[2] = from[1];
ADDRLP4 0
INDIRP4
CNSTI4 2
ADDP4
ADDRLP4 4
INDIRP4
CNSTI4 1
ADDP4
INDIRU1
ASGNU1
line 403
;403:	to[3] = from[0];
ADDRLP4 0
INDIRP4
CNSTI4 3
ADDP4
ADDRLP4 4
INDIRP4
INDIRU1
ASGNU1
line 404
;404:}
LABELV $217
endproc CopyIntSwap 8 0
export CopyLongSwap
proc CopyLongSwap 8 0
line 407
;405:
;406:void CopyLongSwap(void *dest, void *src)
;407:{
line 408
;408:	byte *to = (byte *)dest, *from = (byte *)src;
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 4
ADDRFP4 4
INDIRP4
ASGNP4
line 410
;409:
;410:	to[0] = from[7];
ADDRLP4 0
INDIRP4
ADDRLP4 4
INDIRP4
CNSTI4 7
ADDP4
INDIRU1
ASGNU1
line 411
;411:	to[1] = from[6];
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ADDRLP4 4
INDIRP4
CNSTI4 6
ADDP4
INDIRU1
ASGNU1
line 412
;412:	to[2] = from[5];
ADDRLP4 0
INDIRP4
CNSTI4 2
ADDP4
ADDRLP4 4
INDIRP4
CNSTI4 5
ADDP4
INDIRU1
ASGNU1
line 413
;413:	to[3] = from[4];
ADDRLP4 0
INDIRP4
CNSTI4 3
ADDP4
ADDRLP4 4
INDIRP4
CNSTI4 4
ADDP4
INDIRU1
ASGNU1
line 414
;414:	to[4] = from[3];
ADDRLP4 0
INDIRP4
CNSTI4 4
ADDP4
ADDRLP4 4
INDIRP4
CNSTI4 3
ADDP4
INDIRU1
ASGNU1
line 415
;415:	to[5] = from[2];
ADDRLP4 0
INDIRP4
CNSTI4 5
ADDP4
ADDRLP4 4
INDIRP4
CNSTI4 2
ADDP4
INDIRU1
ASGNU1
line 416
;416:	to[6] = from[1];
ADDRLP4 0
INDIRP4
CNSTI4 6
ADDP4
ADDRLP4 4
INDIRP4
CNSTI4 1
ADDP4
INDIRU1
ASGNU1
line 417
;417:	to[7] = from[0];
ADDRLP4 0
INDIRP4
CNSTI4 7
ADDP4
ADDRLP4 4
INDIRP4
INDIRU1
ASGNU1
line 418
;418:}
LABELV $218
endproc CopyLongSwap 8 0
export N_memset
proc N_memset 8 0
line 429
;419:
;420:/*
;421:=====================================================================
;422:
;423:Library Replacement Functions
;424:
;425:=====================================================================
;426:*/
;427:
;428:void* N_memset (void *dest, int fill, size_t count)
;429:{
line 432
;430:	size_t i;
;431:	
;432:	if ( (((uintptr_t)dest | count) & 3) == 0) {
ADDRFP4 0
INDIRP4
CVPU4 4
ADDRFP4 8
INDIRU4
BORU4
CNSTU4 3
BANDU4
CNSTU4 0
NEU4 $220
line 433
;433:		count >>= 2;
ADDRFP4 8
ADDRFP4 8
INDIRU4
CNSTI4 2
RSHU4
ASGNU4
line 434
;434:		fill = fill | (fill<<8) | (fill<<16) | (fill<<24);
ADDRLP4 4
ADDRFP4 4
INDIRI4
ASGNI4
ADDRFP4 4
ADDRLP4 4
INDIRI4
ADDRLP4 4
INDIRI4
CNSTI4 8
LSHI4
BORI4
ADDRLP4 4
INDIRI4
CNSTI4 16
LSHI4
BORI4
ADDRLP4 4
INDIRI4
CNSTI4 24
LSHI4
BORI4
ASGNI4
line 435
;435:		for (i = 0; i < count; i++)
ADDRLP4 0
CNSTU4 0
ASGNU4
ADDRGP4 $225
JUMPV
LABELV $222
line 436
;436:			((int *)dest)[i] = fill;
ADDRLP4 0
INDIRU4
CNSTI4 2
LSHU4
ADDRFP4 0
INDIRP4
ADDP4
ADDRFP4 4
INDIRI4
ASGNI4
LABELV $223
line 435
ADDRLP4 0
ADDRLP4 0
INDIRU4
CNSTU4 1
ADDU4
ASGNU4
LABELV $225
ADDRLP4 0
INDIRU4
ADDRFP4 8
INDIRU4
LTU4 $222
line 437
;437:	}
ADDRGP4 $221
JUMPV
LABELV $220
line 439
;438:	else
;439:		for (i = 0; i < count; i++)
ADDRLP4 0
CNSTU4 0
ASGNU4
ADDRGP4 $229
JUMPV
LABELV $226
line 440
;440:			((char *)dest)[i] = fill;
ADDRLP4 0
INDIRU4
ADDRFP4 0
INDIRP4
ADDP4
ADDRFP4 4
INDIRI4
CVII1 4
ASGNI1
LABELV $227
line 439
ADDRLP4 0
ADDRLP4 0
INDIRU4
CNSTU4 1
ADDU4
ASGNU4
LABELV $229
ADDRLP4 0
INDIRU4
ADDRFP4 8
INDIRU4
LTU4 $226
LABELV $221
line 442
;441:    
;442:    return dest;
ADDRFP4 0
INDIRP4
RETP4
LABELV $219
endproc N_memset 8 0
export N_memchr
proc N_memchr 4 0
line 446
;443:}
;444:
;445:void* N_memchr (void *ptr, int c, size_t count)
;446:{
ADDRGP4 $232
JUMPV
LABELV $231
line 447
;447:	while (--count) {
line 448
;448:		if (((char *)ptr)[count] == c)
ADDRFP4 8
INDIRU4
ADDRFP4 0
INDIRP4
ADDP4
INDIRI1
CVII4 1
ADDRFP4 4
INDIRI4
NEI4 $234
line 449
;449:			return (void *)&((char *)ptr)[count];
ADDRFP4 8
INDIRU4
ADDRFP4 0
INDIRP4
ADDP4
RETP4
ADDRGP4 $230
JUMPV
LABELV $234
line 450
;450:	}
LABELV $232
line 447
ADDRLP4 0
ADDRFP4 8
INDIRU4
CNSTU4 1
SUBU4
ASGNU4
ADDRFP4 8
ADDRLP4 0
INDIRU4
ASGNU4
ADDRLP4 0
INDIRU4
CNSTU4 0
NEU4 $231
line 451
;451:	return NULL;
CNSTP4 0
RETP4
LABELV $230
endproc N_memchr 4 0
export N_memcpy
proc N_memcpy 8 0
line 455
;452:}
;453:
;454:void N_memcpy (void *dest, const void *src, size_t count)
;455:{
line 457
;456:	size_t i;
;457:	if (( ( (uintptr_t)dest | (uintptr_t)src | count) & 7) == 0) {
ADDRFP4 0
INDIRP4
CVPU4 4
ADDRFP4 4
INDIRP4
CVPU4 4
BORU4
ADDRFP4 8
INDIRU4
BORU4
CNSTU4 7
BANDU4
CNSTU4 0
NEU4 $237
ADDRGP4 $240
JUMPV
LABELV $239
line 458
;458:		while (count >= 4) {
line 459
;459:			((intptr_t *)dest)[count] = ((intptr_t *)src)[count];
ADDRLP4 4
ADDRFP4 8
INDIRU4
ASGNU4
ADDRLP4 4
INDIRU4
CNSTI4 2
LSHU4
ADDRFP4 0
INDIRP4
ADDP4
ADDRLP4 4
INDIRU4
CNSTI4 2
LSHU4
ADDRFP4 4
INDIRP4
ADDP4
INDIRI4
ASGNI4
line 460
;460:			count -= 4;
ADDRFP4 8
ADDRFP4 8
INDIRU4
CNSTU4 4
SUBU4
ASGNU4
line 461
;461:		}
LABELV $240
line 458
ADDRFP4 8
INDIRU4
CNSTU4 4
GEU4 $239
line 462
;462:	}
ADDRGP4 $238
JUMPV
LABELV $237
line 463
;463:	else if (( ( (uintptr_t)dest | (uintptr_t)src | count) & 3) == 0 ) {
ADDRFP4 0
INDIRP4
CVPU4 4
ADDRFP4 4
INDIRP4
CVPU4 4
BORU4
ADDRFP4 8
INDIRU4
BORU4
CNSTU4 3
BANDU4
CNSTU4 0
NEU4 $242
line 464
;464:		count>>=2;
ADDRFP4 8
ADDRFP4 8
INDIRU4
CNSTI4 2
RSHU4
ASGNU4
line 465
;465:		for (i = 0; i < count; i++)
ADDRLP4 0
CNSTU4 0
ASGNU4
ADDRGP4 $247
JUMPV
LABELV $244
line 466
;466:			((int *)dest)[i] = ((int *)src)[i];
ADDRLP4 0
INDIRU4
CNSTI4 2
LSHU4
ADDRFP4 0
INDIRP4
ADDP4
ADDRLP4 0
INDIRU4
CNSTI4 2
LSHU4
ADDRFP4 4
INDIRP4
ADDP4
INDIRI4
ASGNI4
LABELV $245
line 465
ADDRLP4 0
ADDRLP4 0
INDIRU4
CNSTU4 1
ADDU4
ASGNU4
LABELV $247
ADDRLP4 0
INDIRU4
ADDRFP4 8
INDIRU4
LTU4 $244
line 467
;467:	}
ADDRGP4 $243
JUMPV
LABELV $242
line 469
;468:	else
;469:		for (i = 0; i < count; i++)
ADDRLP4 0
CNSTU4 0
ASGNU4
ADDRGP4 $251
JUMPV
LABELV $248
line 470
;470:			((char *)dest)[i] = ((char *)src)[i];
ADDRLP4 0
INDIRU4
ADDRFP4 0
INDIRP4
ADDP4
ADDRLP4 0
INDIRU4
ADDRFP4 4
INDIRP4
ADDP4
INDIRI1
ASGNI1
LABELV $249
line 469
ADDRLP4 0
ADDRLP4 0
INDIRU4
CNSTU4 1
ADDU4
ASGNU4
LABELV $251
ADDRLP4 0
INDIRU4
ADDRFP4 8
INDIRU4
LTU4 $248
LABELV $243
LABELV $238
line 471
;471:}
LABELV $236
endproc N_memcpy 8 0
export N_memcmp
proc N_memcmp 4 0
line 474
;472:
;473:int N_memcmp (const void *ptr1, const void *ptr2, size_t count)
;474:{
ADDRGP4 $254
JUMPV
LABELV $253
line 475
;475:	while (count--) {
line 476
;476:		if (((char *)ptr1)[count] != ((char *)ptr2)[count])
ADDRLP4 0
ADDRFP4 8
INDIRU4
ASGNU4
ADDRLP4 0
INDIRU4
ADDRFP4 0
INDIRP4
ADDP4
INDIRI1
CVII4 1
ADDRLP4 0
INDIRU4
ADDRFP4 4
INDIRP4
ADDP4
INDIRI1
CVII4 1
EQI4 $256
line 477
;477:			return -1;
CNSTI4 -1
RETI4
ADDRGP4 $252
JUMPV
LABELV $256
line 478
;478:	}
LABELV $254
line 475
ADDRLP4 0
ADDRFP4 8
INDIRU4
ASGNU4
ADDRFP4 8
ADDRLP4 0
INDIRU4
CNSTU4 1
SUBU4
ASGNU4
ADDRLP4 0
INDIRU4
CNSTU4 0
NEU4 $253
line 479
;479:	return 1;
CNSTI4 1
RETI4
LABELV $252
endproc N_memcmp 4 0
export N_isprint
proc N_isprint 4 0
line 519
;480:}
;481:
;482:
;483:#ifdef _WIN32
;484:/*
;485:=============
;486:N_vsnprintf
;487: 
;488:Special wrapper function for Microsoft's broken _vsnprintf() function. mingw-w64
;489:however, uses Microsoft's broken _vsnprintf() function.
;490:=============
;491:*/
;492:int N_vsnprintf( char *str, size_t size, const char *format, va_list ap )
;493:{
;494:	int retval;
;495:	
;496:#ifndef Q3_VM
;497:	retval = _vsnprintf( str, size, format, ap );
;498:#else
;499:	retval = vsprintf( str, format, ap );
;500:#endif
;501:
;502:	if ( retval < 0 || (size_t)retval == size ) {
;503:		// Microsoft doesn't adhere to the C99 standard of vsnprintf,
;504:		// which states that the return value must be the number of
;505:		// bytes written if the output string had sufficient length.
;506:		//
;507:		// Obviously we cannot determine that value from Microsoft's
;508:		// implementation, so we have no choice but to return size.
;509:		
;510:		str[size - 1] = '\0';
;511:		return size;
;512:	}
;513:	
;514:	return retval;
;515:}
;516:#endif
;517:
;518:int N_isprint( int c )
;519:{
line 520
;520:	if ( c >= 0x20 && c <= 0x7E )
ADDRLP4 0
ADDRFP4 0
INDIRI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 32
LTI4 $259
ADDRLP4 0
INDIRI4
CNSTI4 126
GTI4 $259
line 521
;521:		return ( 1 );
CNSTI4 1
RETI4
ADDRGP4 $258
JUMPV
LABELV $259
line 522
;522:	return ( 0 );
CNSTI4 0
RETI4
LABELV $258
endproc N_isprint 4 0
export N_islower
proc N_islower 4 0
line 527
;523:}
;524:
;525:
;526:int N_islower( int c )
;527:{
line 528
;528:	if (c >= 'a' && c <= 'z')
ADDRLP4 0
ADDRFP4 0
INDIRI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 97
LTI4 $262
ADDRLP4 0
INDIRI4
CNSTI4 122
GTI4 $262
line 529
;529:		return ( 1 );
CNSTI4 1
RETI4
ADDRGP4 $261
JUMPV
LABELV $262
line 530
;530:	return ( 0 );
CNSTI4 0
RETI4
LABELV $261
endproc N_islower 4 0
export N_isupper
proc N_isupper 4 0
line 535
;531:}
;532:
;533:
;534:int N_isupper( int c )
;535:{
line 536
;536:	if (c >= 'A' && c <= 'Z')
ADDRLP4 0
ADDRFP4 0
INDIRI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 65
LTI4 $265
ADDRLP4 0
INDIRI4
CNSTI4 90
GTI4 $265
line 537
;537:		return ( 1 );
CNSTI4 1
RETI4
ADDRGP4 $264
JUMPV
LABELV $265
line 538
;538:	return ( 0 );
CNSTI4 0
RETI4
LABELV $264
endproc N_isupper 4 0
export N_isalpha
proc N_isalpha 8 0
line 543
;539:}
;540:
;541:
;542:int N_isalpha( int c )
;543:{
line 544
;544:	if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'))
ADDRLP4 0
ADDRFP4 0
INDIRI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 97
LTI4 $271
ADDRLP4 0
INDIRI4
CNSTI4 122
LEI4 $270
LABELV $271
ADDRLP4 4
ADDRFP4 0
INDIRI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 65
LTI4 $268
ADDRLP4 4
INDIRI4
CNSTI4 90
GTI4 $268
LABELV $270
line 545
;545:		return ( 1 );
CNSTI4 1
RETI4
ADDRGP4 $267
JUMPV
LABELV $268
line 546
;546:	return ( 0 );
CNSTI4 0
RETI4
LABELV $267
endproc N_isalpha 8 0
export N_isintegral
proc N_isintegral 8 0
line 550
;547:}
;548:
;549:qboolean N_isintegral(float f)
;550:{
line 551
;551:	return (qboolean)((int)f == f);
ADDRLP4 4
ADDRFP4 0
INDIRF4
ASGNF4
ADDRLP4 4
INDIRF4
CVFI4 4
CVIF4 4
ADDRLP4 4
INDIRF4
NEF4 $274
ADDRLP4 0
CNSTI4 1
ASGNI4
ADDRGP4 $275
JUMPV
LABELV $274
ADDRLP4 0
CNSTI4 0
ASGNI4
LABELV $275
ADDRLP4 0
INDIRI4
RETI4
LABELV $272
endproc N_isintegral 8 0
export N_isanumber
proc N_isanumber 0 0
line 556
;552:}
;553:
;554:
;555:qboolean N_isanumber( const char *s )
;556:{
line 559
;557:#ifdef Q3_VM
;558:    //FIXME: implement
;559:    return qfalse;
CNSTI4 0
RETI4
LABELV $276
endproc N_isanumber 0 0
export N_strcpy
proc N_strcpy 20 0
line 574
;560:#else
;561:    char *p;
;562:
;563:	if( *s == '\0' )
;564:        return qfalse;
;565:
;566:	strtod( s, &p );
;567:
;568:    return (qboolean)(*p == '\0');
;569:#endif
;570:}
;571:
;572:
;573:void N_strcpy (char *dest, const char *src)
;574:{
line 575
;575:	char *d = dest;
ADDRLP4 4
ADDRFP4 0
INDIRP4
ASGNP4
line 576
;576:	const char *s = src;
ADDRLP4 0
ADDRFP4 4
INDIRP4
ASGNP4
ADDRGP4 $279
JUMPV
LABELV $278
line 578
;577:	while (*s)
;578:		*d++ = *s++;
ADDRLP4 8
ADDRLP4 4
INDIRP4
ASGNP4
ADDRLP4 4
ADDRLP4 8
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 12
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 12
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 8
INDIRP4
ADDRLP4 12
INDIRP4
INDIRI1
ASGNI1
LABELV $279
line 577
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $278
line 580
;579:	
;580:	*d++ = 0;
ADDRLP4 16
ADDRLP4 4
INDIRP4
ASGNP4
ADDRLP4 4
ADDRLP4 16
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 16
INDIRP4
CNSTI1 0
ASGNI1
line 581
;581:}
LABELV $277
endproc N_strcpy 20 0
export Com_TruncateLongString
proc Com_TruncateLongString 8 12
line 584
;582:
;583:void Com_TruncateLongString( char *buffer, const char *s )
;584:{
line 585
;585:	uint64_t length = strlen( s );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 4
ADDRGP4 strlen
CALLU4
ASGNU4
ADDRLP4 0
ADDRLP4 4
INDIRU4
ASGNU4
line 587
;586:
;587:	if( length <= TRUNCATE_LENGTH )
ADDRLP4 0
INDIRU4
CNSTU4 64
GTU4 $282
line 588
;588:		N_strncpyz( buffer, s, TRUNCATE_LENGTH );
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
CNSTU4 64
ARGU4
ADDRGP4 N_strncpyz
CALLV
pop
ADDRGP4 $283
JUMPV
LABELV $282
line 589
;589:	else {
line 590
;590:		N_strncpyz( buffer, s, ( TRUNCATE_LENGTH / 2 ) - 3 );
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
CNSTU4 29
ARGU4
ADDRGP4 N_strncpyz
CALLV
pop
line 591
;591:		N_strcat( buffer, TRUNCATE_LENGTH, " ... " );
ADDRFP4 0
INDIRP4
ARGP4
CNSTU4 64
ARGU4
ADDRGP4 $284
ARGP4
ADDRGP4 N_strcat
CALLV
pop
line 592
;592:		N_strcat( buffer, TRUNCATE_LENGTH, s + length - ( TRUNCATE_LENGTH / 2 ) + 3 );
ADDRFP4 0
INDIRP4
ARGP4
CNSTU4 64
ARGU4
ADDRLP4 0
INDIRU4
ADDRFP4 4
INDIRP4
ADDP4
CNSTI4 -29
ADDP4
ARGP4
ADDRGP4 N_strcat
CALLV
pop
line 593
;593:	}
LABELV $283
line 594
;594:}
LABELV $281
endproc Com_TruncateLongString 8 12
export N_strncpyz
proc N_strncpyz 0 12
line 598
;595:
;596:
;597:void N_strncpyz (char *dest, const char *src, size_t count)
;598:{
line 599
;599:	if (!dest)
ADDRFP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $286
line 600
;600:		N_Error(ERR_FATAL, "N_strncpyz: NULL dest");
CNSTI4 0
ARGI4
ADDRGP4 $288
ARGP4
ADDRGP4 N_Error
CALLV
pop
LABELV $286
line 601
;601:	if (!src)
ADDRFP4 4
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $289
line 602
;602:		N_Error(ERR_FATAL, "N_strncpyz: NULL src");
CNSTI4 0
ARGI4
ADDRGP4 $291
ARGP4
ADDRGP4 N_Error
CALLV
pop
LABELV $289
line 603
;603:	if (count < 1)
ADDRFP4 8
INDIRU4
CNSTU4 1
GEU4 $292
line 604
;604:		N_Error(ERR_FATAL, "N_strncpyz: bad count");
CNSTI4 0
ARGI4
ADDRGP4 $294
ARGP4
ADDRGP4 N_Error
CALLV
pop
LABELV $292
line 614
;605:	
;606:#if 0 // [glnomad] this ain't quake 3
;607:	// do not fill whole remaining buffer with zeros
;608:	// this is obvious behavior change but actually it may affect only buggy QVMs
;609:	// which passes overlapping or short buffers to cvar reading routines
;610:	// what is rather good than bad because it will no longer cause overwrites, maybe
;611:	while ( --count > 0 && (*dest++ = *src++) != '\0' );
;612:	*dest = '\0';
;613:#else
;614:	strncpy( dest, src, count-1 );
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRU4
CNSTU4 1
SUBU4
ARGU4
ADDRGP4 strncpy
CALLI4
pop
line 615
;615:	dest[ count-1 ] = '\0';
ADDRFP4 8
INDIRU4
CNSTU4 1
SUBU4
ADDRFP4 0
INDIRP4
ADDP4
CNSTI1 0
ASGNI1
line 617
;616:#endif
;617:}
LABELV $285
endproc N_strncpyz 0 12
export N_strncpy
proc N_strncpy 16 0
line 620
;618:
;619:void N_strncpy (char *dest, const char *src, size_t count)
;620:{
ADDRGP4 $297
JUMPV
LABELV $296
line 622
;621:	while (*src && count--)
;622:		*dest++ = *src++;
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
ADDRFP4 4
INDIRP4
ASGNP4
ADDRFP4 4
ADDRLP4 4
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 0
INDIRP4
ADDRLP4 4
INDIRP4
INDIRI1
ASGNI1
LABELV $297
line 621
ADDRFP4 4
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
EQI4 $299
ADDRLP4 8
ADDRFP4 8
INDIRU4
ASGNU4
ADDRFP4 8
ADDRLP4 8
INDIRU4
CNSTU4 1
SUBU4
ASGNU4
ADDRLP4 8
INDIRU4
CNSTU4 0
NEU4 $296
LABELV $299
line 624
;623:
;624:	if (count)
ADDRFP4 8
INDIRU4
CNSTU4 0
EQU4 $300
line 625
;625:		*dest++ = 0;
ADDRLP4 12
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 12
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 12
INDIRP4
CNSTI1 0
ASGNI1
LABELV $300
line 626
;626:}
LABELV $295
endproc N_strncpy 16 0
proc Com_CharIsOneOfCharset 12 4
ADDRFP4 0
ADDRFP4 0
INDIRI4
CVII1 4
ASGNI1
line 634
;627:
;628:/*
;629:==================
;630:Com_CharIsOneOfCharset
;631:==================
;632:*/
;633:static qboolean Com_CharIsOneOfCharset( char c, const char *set )
;634:{
line 635
;635:	uint64_t i, n = (uint64_t)(strlen(set));
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 8
ADDRGP4 strlen
CALLU4
ASGNU4
ADDRLP4 4
ADDRLP4 8
INDIRU4
ASGNU4
line 637
;636:
;637:	for( i = 0; i < n; i++ ) {
ADDRLP4 0
CNSTU4 0
ASGNU4
ADDRGP4 $306
JUMPV
LABELV $303
line 638
;638:		if( set[ i ] == c )
ADDRLP4 0
INDIRU4
ADDRFP4 4
INDIRP4
ADDP4
INDIRI1
CVII4 1
ADDRFP4 0
INDIRI1
CVII4 1
NEI4 $307
line 639
;639:			return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $302
JUMPV
LABELV $307
line 640
;640:	}
LABELV $304
line 637
ADDRLP4 0
ADDRLP4 0
INDIRU4
CNSTU4 1
ADDU4
ASGNU4
LABELV $306
ADDRLP4 0
INDIRU4
ADDRLP4 4
INDIRU4
LTU4 $303
line 642
;641:
;642:	return qfalse;
CNSTI4 0
RETI4
LABELV $302
endproc Com_CharIsOneOfCharset 12 4
export Com_SkipCharset
proc Com_SkipCharset 8 8
line 651
;643:}
;644:
;645:/*
;646:==================
;647:Com_SkipCharset
;648:==================
;649:*/
;650:const char *Com_SkipCharset( const char *s, const char *sep )
;651:{
line 652
;652:	const char	*p = s;
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
ADDRGP4 $311
JUMPV
LABELV $310
line 654
;653:
;654:	while( p ) {
line 655
;655:		if( Com_CharIsOneOfCharset( *p, sep ) )
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
ARGI4
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 4
ADDRGP4 Com_CharIsOneOfCharset
CALLI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $312
line 656
;656:			p++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 658
;657:		else
;658:			break;
LABELV $314
line 659
;659:	}
LABELV $311
line 654
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $310
LABELV $312
line 661
;660:
;661:	return p;
ADDRLP4 0
INDIRP4
RETP4
LABELV $309
endproc Com_SkipCharset 8 8
data
align 4
LABELV $316
byte 4 0
bss
align 1
LABELV $317
skip 64000
export va
code
proc va 12 12
line 669
;662:}
;663:
;664:
;665:/*
;666:Not thread safe
;667:*/
;668:const char* GDR_ATTRIBUTE((format(printf, 1, 2))) GDR_DECL va(const char *format, ...)
;669:{
line 675
;670:	char *buf;
;671:	va_list argptr;
;672:	static uint32_t index = 0;
;673:	static char string[2][32000];	// in case va is called by nested functions
;674:
;675:	buf = string[ index ];
ADDRLP4 0
ADDRGP4 $316
INDIRU4
CNSTU4 32000
MULU4
ADDRGP4 $317
ADDP4
ASGNP4
line 676
;676:	index ^= 1;
ADDRLP4 8
ADDRGP4 $316
ASGNP4
ADDRLP4 8
INDIRP4
ADDRLP4 8
INDIRP4
INDIRU4
CNSTU4 1
BXORU4
ASGNU4
line 678
;677:
;678:	va_start( argptr, format );
ADDRLP4 4
ADDRFP4 0+4
ASGNP4
line 679
;679:	vsprintf( buf, format, argptr );
ADDRLP4 0
INDIRP4
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 4
INDIRP4
ARGP4
ADDRGP4 vsprintf
CALLI4
pop
line 680
;680:	va_end( argptr );
ADDRLP4 4
CNSTP4 0
ASGNP4
line 682
;681:
;682:	return buf;
ADDRLP4 0
INDIRP4
RETP4
LABELV $315
endproc va 12 12
export Com_SkipTokens
proc Com_SkipTokens 20 8
line 691
;683:}
;684:
;685:/*
;686:==================
;687:Com_SkipTokens
;688:==================
;689:*/
;690:const char *Com_SkipTokens( const char *s, uint64_t numTokens, const char *sep )
;691:{
line 692
;692:	uint64_t sepCount = 0;
ADDRLP4 4
CNSTU4 0
ASGNU4
line 693
;693:	const char	*p = s;
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
ADDRGP4 $321
JUMPV
LABELV $320
line 695
;694:
;695:	while( sepCount < numTokens ) {
line 696
;696:		if( Com_CharIsOneOfCharset( *p++, sep ) ) {
ADDRLP4 8
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 8
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 8
INDIRP4
INDIRI1
CVII4 1
ARGI4
ADDRFP4 8
INDIRP4
ARGP4
ADDRLP4 12
ADDRGP4 Com_CharIsOneOfCharset
CALLI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 0
EQI4 $323
line 697
;697:			sepCount++;
ADDRLP4 4
ADDRLP4 4
INDIRU4
CNSTU4 1
ADDU4
ASGNU4
ADDRGP4 $326
JUMPV
LABELV $325
line 699
;698:			while( Com_CharIsOneOfCharset( *p, sep ) )
;699:				p++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
LABELV $326
line 698
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
ARGI4
ADDRFP4 8
INDIRP4
ARGP4
ADDRLP4 16
ADDRGP4 Com_CharIsOneOfCharset
CALLI4
ASGNI4
ADDRLP4 16
INDIRI4
CNSTI4 0
NEI4 $325
line 700
;700:		}
ADDRGP4 $324
JUMPV
LABELV $323
line 701
;701:		else if( *p == '\0' )
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $328
line 702
;702:			break;
ADDRGP4 $322
JUMPV
LABELV $328
LABELV $324
line 703
;703:	}
LABELV $321
line 695
ADDRLP4 4
INDIRU4
ADDRFP4 4
INDIRU4
LTU4 $320
LABELV $322
line 705
;704:
;705:	if( sepCount == numTokens )
ADDRLP4 4
INDIRU4
ADDRFP4 4
INDIRU4
NEU4 $330
line 706
;706:		return p;
ADDRLP4 0
INDIRP4
RETP4
ADDRGP4 $319
JUMPV
LABELV $330
line 708
;707:	else
;708:		return s;
ADDRFP4 0
INDIRP4
RETP4
LABELV $319
endproc Com_SkipTokens 20 8
export N_strlwr
proc N_strlwr 8 0
line 713
;709:}
;710:
;711:
;712:char *N_strlwr(char *s1)
;713:{
line 716
;714:	char	*s;
;715:
;716:	s = s1;
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
ADDRGP4 $334
JUMPV
LABELV $333
line 717
;717:	while ( *s ) {
line 718
;718:		*s = locase[(byte)*s];
ADDRLP4 0
INDIRP4
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CVIU4 4
CVUU1 4
CVUI4 1
ADDRGP4 locase
ADDP4
INDIRU1
CVUI4 1
CVII1 4
ASGNI1
line 719
;719:		s++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 720
;720:	}
LABELV $334
line 717
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $333
line 721
;721:	return s1;
ADDRFP4 0
INDIRP4
RETP4
LABELV $332
endproc N_strlwr 8 0
export N_strupr
proc N_strupr 12 0
line 725
;722:}
;723:
;724:char *N_strupr(char *s1)
;725:{
line 728
;726:	char *s;
;727:
;728:	s = s1;
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
ADDRGP4 $338
JUMPV
LABELV $337
line 729
;729:	while (*s) {
line 730
;730:		if (*s >= 'a' && *s <= 'z')
ADDRLP4 4
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 97
LTI4 $340
ADDRLP4 4
INDIRI4
CNSTI4 122
GTI4 $340
line 731
;731:			*s = *s - 'a' + 'A';
ADDRLP4 0
INDIRP4
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 97
SUBI4
CNSTI4 65
ADDI4
CVII1 4
ASGNI1
LABELV $340
line 732
;732:		s++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 733
;733:	}
LABELV $338
line 729
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $337
line 734
;734:	return s1;
ADDRFP4 0
INDIRP4
RETP4
LABELV $336
endproc N_strupr 12 0
export N_strcat
proc N_strcat 12 12
line 739
;735:}
;736:
;737:// never goes past bounds or leaves without a terminating 0
;738:void N_strcat(char *dest, size_t size, const char *src)
;739:{
line 742
;740:	size_t l1;
;741:
;742:	l1 = strlen(dest);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 4
ADDRGP4 strlen
CALLU4
ASGNU4
ADDRLP4 0
ADDRLP4 4
INDIRU4
ASGNU4
line 743
;743:	if (l1 >= size)
ADDRLP4 0
INDIRU4
ADDRFP4 4
INDIRU4
LTU4 $343
line 744
;744:		N_Error( ERR_FATAL, "N_strcat: already overflowed" );
CNSTI4 0
ARGI4
ADDRGP4 $345
ARGP4
ADDRGP4 N_Error
CALLV
pop
LABELV $343
line 746
;745:	
;746:	N_strncpy( dest + l1, src, size - l1 );
ADDRLP4 0
INDIRU4
ADDRFP4 0
INDIRP4
ADDP4
ARGP4
ADDRFP4 8
INDIRP4
ARGP4
ADDRFP4 4
INDIRU4
ADDRLP4 0
INDIRU4
SUBU4
ARGU4
ADDRGP4 N_strncpy
CALLV
pop
line 747
;747:}
LABELV $342
endproc N_strcat 12 12
export N_stradd
proc N_stradd 13 0
line 750
;748:
;749:char *N_stradd(char *dst, const char *src)
;750:{
ADDRGP4 $348
JUMPV
LABELV $347
line 753
;751:	char c;
;752:	while ( (c = *src++) != '\0' )
;753:		*dst++ = c;
ADDRLP4 4
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 4
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
INDIRP4
ADDRLP4 0
INDIRI1
ASGNI1
LABELV $348
line 752
ADDRLP4 8
ADDRFP4 4
INDIRP4
ASGNP4
ADDRFP4 4
ADDRLP4 8
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 12
ADDRLP4 8
INDIRP4
INDIRI1
ASGNI1
ADDRLP4 0
ADDRLP4 12
INDIRI1
ASGNI1
ADDRLP4 12
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $347
line 754
;754:	*dst = '\0';
ADDRFP4 0
INDIRP4
CNSTI1 0
ASGNI1
line 755
;755:	return dst;
ADDRFP4 0
INDIRP4
RETP4
LABELV $346
endproc N_stradd 13 0
export N_stristr
proc N_stristr 36 12
line 763
;756:}
;757:
;758:
;759:/*
;760:* Find the first occurrence of find in s.
;761:*/
;762:const char *N_stristr(const char *s, const char *find)
;763:{
line 767
;764:	char c, sc;
;765:	size_t len;
;766:
;767:	if ((c = *find++) != 0) {
ADDRLP4 8
ADDRFP4 4
INDIRP4
ASGNP4
ADDRFP4 4
ADDRLP4 8
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 12
ADDRLP4 8
INDIRP4
INDIRI1
ASGNI1
ADDRLP4 1
ADDRLP4 12
INDIRI1
ASGNI1
ADDRLP4 12
INDIRI1
CVII4 1
CNSTI4 0
EQI4 $351
line 768
;768:		if (c >= 'a' && c <= 'z') {
ADDRLP4 16
ADDRLP4 1
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 16
INDIRI4
CNSTI4 97
LTI4 $353
ADDRLP4 16
INDIRI4
CNSTI4 122
GTI4 $353
line 769
;769:	    	c -= ('a' - 'A');
ADDRLP4 1
ADDRLP4 1
INDIRI1
CVII4 1
CNSTI4 32
SUBI4
CVII1 4
ASGNI1
line 770
;770:		}
LABELV $353
line 771
;771: 	   	len = strlen(find);
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 20
ADDRGP4 strlen
CALLU4
ASGNU4
ADDRLP4 4
ADDRLP4 20
INDIRU4
ASGNU4
LABELV $355
line 772
;772:    	do {
LABELV $358
line 773
;773:    		do {
line 774
;774:        		if ((sc = *s++) == 0)
ADDRLP4 24
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 24
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 28
ADDRLP4 24
INDIRP4
INDIRI1
ASGNI1
ADDRLP4 0
ADDRLP4 28
INDIRI1
ASGNI1
ADDRLP4 28
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $361
line 775
;775:          			return NULL;
CNSTP4 0
RETP4
ADDRGP4 $350
JUMPV
LABELV $361
line 776
;776:        		if (sc >= 'a' && sc <= 'z') {
ADDRLP4 32
ADDRLP4 0
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 32
INDIRI4
CNSTI4 97
LTI4 $363
ADDRLP4 32
INDIRI4
CNSTI4 122
GTI4 $363
line 777
;777:          			sc -= ('a' - 'A');
ADDRLP4 0
ADDRLP4 0
INDIRI1
CVII4 1
CNSTI4 32
SUBI4
CVII1 4
ASGNI1
line 778
;778:        		}
LABELV $363
line 779
;779:      		} while (sc != c);
LABELV $359
ADDRLP4 0
INDIRI1
CVII4 1
ADDRLP4 1
INDIRI1
CVII4 1
NEI4 $358
line 780
;780:    	} while (N_stricmpn(s, find, len) != 0);
LABELV $356
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 4
INDIRU4
ARGU4
ADDRLP4 24
ADDRGP4 N_stricmpn
CALLI4
ASGNI4
ADDRLP4 24
INDIRI4
CNSTI4 0
NEI4 $355
line 781
;781:   		s--;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 -1
ADDP4
ASGNP4
line 782
;782:  	}
LABELV $351
line 783
;783:  	return s;
ADDRFP4 0
INDIRP4
RETP4
LABELV $350
endproc N_stristr 36 12
export N_replace
proc N_replace 76 8
line 787
;784:}
;785:
;786:int N_replace(const char *str1, const char *str2, char *src, size_t max_len)
;787:{
line 793
;788:	size_t len1, len2, count;
;789:	ssize_t d;
;790:	const char *s0, *s1, *s2, *max;
;791:	char *match, *dst;
;792:
;793:	match = strstr(src, str1);
ADDRFP4 8
INDIRP4
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 40
ADDRGP4 strstr
CALLP4
ASGNP4
ADDRLP4 4
ADDRLP4 40
INDIRP4
ASGNP4
line 795
;794:
;795:	if (!match)
ADDRLP4 4
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $366
line 796
;796:		return 0;
CNSTI4 0
RETI4
ADDRGP4 $365
JUMPV
LABELV $366
line 798
;797:
;798:	count = 0; // replace count
ADDRLP4 20
CNSTU4 0
ASGNU4
line 800
;799:
;800:    len1 = strlen(str1);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 44
ADDRGP4 strlen
CALLU4
ASGNU4
ADDRLP4 24
ADDRLP4 44
INDIRU4
ASGNU4
line 801
;801:    len2 = strlen(str2);
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 48
ADDRGP4 strlen
CALLU4
ASGNU4
ADDRLP4 36
ADDRLP4 48
INDIRU4
ASGNU4
line 802
;802:    d = len2 - len1;
ADDRLP4 28
ADDRLP4 36
INDIRU4
ADDRLP4 24
INDIRU4
SUBU4
CVUI4 4
ASGNI4
line 804
;803:
;804:    if (d > 0) { // expand and replace mode
ADDRLP4 28
INDIRI4
CNSTI4 0
LEI4 $368
line 805
;805:        max = src + max_len;
ADDRLP4 32
ADDRFP4 12
INDIRU4
ADDRFP4 8
INDIRP4
ADDP4
ASGNP4
line 806
;806:        src += strlen(src);
ADDRFP4 8
INDIRP4
ARGP4
ADDRLP4 52
ADDRGP4 strlen
CALLU4
ASGNU4
ADDRFP4 8
ADDRLP4 52
INDIRU4
ADDRFP4 8
INDIRP4
ADDP4
ASGNP4
LABELV $370
line 808
;807:
;808:        do { // expand source string
line 809
;809:			s1 = src;
ADDRLP4 8
ADDRFP4 8
INDIRP4
ASGNP4
line 810
;810:            src += d;
ADDRFP4 8
ADDRLP4 28
INDIRI4
ADDRFP4 8
INDIRP4
ADDP4
ASGNP4
line 811
;811:            if (src >= max)
ADDRFP4 8
INDIRP4
CVPU4 4
ADDRLP4 32
INDIRP4
CVPU4 4
LTU4 $373
line 812
;812:                return count;
ADDRLP4 20
INDIRU4
CVUI4 4
RETI4
ADDRGP4 $365
JUMPV
LABELV $373
line 813
;813:            dst = src;
ADDRLP4 12
ADDRFP4 8
INDIRP4
ASGNP4
line 815
;814:            
;815:            s0 = match + len1;
ADDRLP4 16
ADDRLP4 24
INDIRU4
ADDRLP4 4
INDIRP4
ADDP4
ASGNP4
ADDRGP4 $376
JUMPV
LABELV $375
line 818
;816:
;817:            while (s1 >= s0)
;818:                *dst-- = *s1--;
ADDRLP4 56
ADDRLP4 12
INDIRP4
ASGNP4
ADDRLP4 12
ADDRLP4 56
INDIRP4
CNSTI4 -1
ADDP4
ASGNP4
ADDRLP4 60
ADDRLP4 8
INDIRP4
ASGNP4
ADDRLP4 8
ADDRLP4 60
INDIRP4
CNSTI4 -1
ADDP4
ASGNP4
ADDRLP4 56
INDIRP4
ADDRLP4 60
INDIRP4
INDIRI1
ASGNI1
LABELV $376
line 817
ADDRLP4 8
INDIRP4
CVPU4 4
ADDRLP4 16
INDIRP4
CVPU4 4
GEU4 $375
line 821
;819:			
;820:			// replace match
;821:            s2 = str2;
ADDRLP4 0
ADDRFP4 4
INDIRP4
ASGNP4
ADDRGP4 $379
JUMPV
LABELV $378
line 823
;822:			while (*s2)
;823:                *match++ = *s2++;
ADDRLP4 64
ADDRLP4 4
INDIRP4
ASGNP4
ADDRLP4 4
ADDRLP4 64
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 68
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 68
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 64
INDIRP4
ADDRLP4 68
INDIRP4
INDIRI1
ASGNI1
LABELV $379
line 822
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $378
line 825
;824:			
;825:            match = strstr(match, str1);
ADDRLP4 4
INDIRP4
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 72
ADDRGP4 strstr
CALLP4
ASGNP4
ADDRLP4 4
ADDRLP4 72
INDIRP4
ASGNP4
line 827
;826:
;827:            count++;
ADDRLP4 20
ADDRLP4 20
INDIRU4
CNSTU4 1
ADDU4
ASGNU4
line 828
;828:		} while (match);
LABELV $371
ADDRLP4 4
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $370
line 830
;829:
;830:        return count;
ADDRLP4 20
INDIRU4
CVUI4 4
RETI4
ADDRGP4 $365
JUMPV
LABELV $368
line 832
;831:    } 
;832:    else if (d < 0) { // shrink and replace mode
ADDRLP4 28
INDIRI4
CNSTI4 0
GEI4 $381
LABELV $383
line 833
;833:        do  { // shrink source string
line 834
;834:            s1 = match + len1;
ADDRLP4 8
ADDRLP4 24
INDIRU4
ADDRLP4 4
INDIRP4
ADDP4
ASGNP4
line 835
;835:            dst = match + len2;
ADDRLP4 12
ADDRLP4 36
INDIRU4
ADDRLP4 4
INDIRP4
ADDP4
ASGNP4
LABELV $386
line 836
;836:            while ( (*dst++ = *s1++) != '\0' );
LABELV $387
ADDRLP4 52
ADDRLP4 12
INDIRP4
ASGNP4
ADDRLP4 12
ADDRLP4 52
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 56
ADDRLP4 8
INDIRP4
ASGNP4
ADDRLP4 8
ADDRLP4 56
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 60
ADDRLP4 56
INDIRP4
INDIRI1
ASGNI1
ADDRLP4 52
INDIRP4
ADDRLP4 60
INDIRI1
ASGNI1
ADDRLP4 60
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $386
line 839
;837:			
;838:			//replace match
;839:            s2 = str2;
ADDRLP4 0
ADDRFP4 4
INDIRP4
ASGNP4
ADDRGP4 $390
JUMPV
LABELV $389
line 840
;840:			while ( *s2 ) {
line 841
;841:				*match++ = *s2++;
ADDRLP4 64
ADDRLP4 4
INDIRP4
ASGNP4
ADDRLP4 4
ADDRLP4 64
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 68
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 68
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 64
INDIRP4
ADDRLP4 68
INDIRP4
INDIRI1
ASGNI1
line 842
;842:			}
LABELV $390
line 840
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $389
line 844
;843:
;844:            match = strstr( match, str1 );
ADDRLP4 4
INDIRP4
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 64
ADDRGP4 strstr
CALLP4
ASGNP4
ADDRLP4 4
ADDRLP4 64
INDIRP4
ASGNP4
line 846
;845:
;846:            count++;
ADDRLP4 20
ADDRLP4 20
INDIRU4
CNSTU4 1
ADDU4
ASGNU4
line 847
;847:        } 
LABELV $384
line 848
;848:        while ( match );
ADDRLP4 4
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $383
line 850
;849:
;850:        return count;
ADDRLP4 20
INDIRU4
CVUI4 4
RETI4
ADDRGP4 $365
JUMPV
LABELV $381
line 852
;851:    }
;852:    else {
LABELV $392
line 853
;853:	    do { // just replace match
line 854
;854:    	    s2 = str2;
ADDRLP4 0
ADDRFP4 4
INDIRP4
ASGNP4
ADDRGP4 $396
JUMPV
LABELV $395
line 856
;855:			while (*s2)
;856:				*match++ = *s2++;
ADDRLP4 52
ADDRLP4 4
INDIRP4
ASGNP4
ADDRLP4 4
ADDRLP4 52
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 56
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 56
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 52
INDIRP4
ADDRLP4 56
INDIRP4
INDIRI1
ASGNI1
LABELV $396
line 855
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $395
line 858
;857:
;858:    	    match = strstr(match, str1);
ADDRLP4 4
INDIRP4
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 60
ADDRGP4 strstr
CALLP4
ASGNP4
ADDRLP4 4
ADDRLP4 60
INDIRP4
ASGNP4
line 859
;859:    	    count++;
ADDRLP4 20
ADDRLP4 20
INDIRU4
CNSTU4 1
ADDU4
ASGNU4
line 860
;860:		}  while (match);
LABELV $393
ADDRLP4 4
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $392
line 861
;861:	}
line 863
;862:
;863:	return count;
ADDRLP4 20
INDIRU4
CVUI4 4
RETI4
LABELV $365
endproc N_replace 76 8
export N_strlen
proc N_strlen 4 0
line 867
;864:}
;865:
;866:size_t N_strlen (const char *str)
;867:{
line 868
;868:	size_t count = 0;
ADDRLP4 0
CNSTU4 0
ASGNU4
ADDRGP4 $400
JUMPV
LABELV $399
line 869
;869:    while (str[count]) {
line 870
;870:        ++count;
ADDRLP4 0
ADDRLP4 0
INDIRU4
CNSTU4 1
ADDU4
ASGNU4
line 871
;871:    }
LABELV $400
line 869
ADDRLP4 0
INDIRU4
ADDRFP4 0
INDIRP4
ADDP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $399
line 872
;872:	return count;
ADDRLP4 0
INDIRU4
RETU4
LABELV $398
endproc N_strlen 4 0
export N_strrchr
proc N_strrchr 20 4
ADDRFP4 4
ADDRFP4 4
INDIRI4
CVII1 4
ASGNI1
line 876
;873:}
;874:
;875:char *N_strrchr(char *str, char c)
;876:{
line 877
;877:    char *s = str;
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
line 878
;878:    size_t len = N_strlen(s);
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 8
ADDRGP4 N_strlen
CALLU4
ASGNU4
ADDRLP4 4
ADDRLP4 8
INDIRU4
ASGNU4
line 879
;879:    s += len;
ADDRLP4 0
ADDRLP4 4
INDIRU4
ADDRLP4 0
INDIRP4
ADDP4
ASGNP4
ADDRGP4 $404
JUMPV
LABELV $403
line 881
;880:    while (len--)
;881:    	if (*--s == c) return s;
ADDRLP4 12
ADDRLP4 0
INDIRP4
CNSTI4 -1
ADDP4
ASGNP4
ADDRLP4 0
ADDRLP4 12
INDIRP4
ASGNP4
ADDRLP4 12
INDIRP4
INDIRI1
CVII4 1
ADDRFP4 4
INDIRI1
CVII4 1
NEI4 $406
ADDRLP4 0
INDIRP4
RETP4
ADDRGP4 $402
JUMPV
LABELV $406
LABELV $404
line 880
ADDRLP4 16
ADDRLP4 4
INDIRU4
ASGNU4
ADDRLP4 4
ADDRLP4 16
INDIRU4
CNSTU4 1
SUBU4
ASGNU4
ADDRLP4 16
INDIRU4
CNSTU4 0
NEU4 $403
line 882
;882:    return 0;
CNSTP4 0
RETP4
LABELV $402
endproc N_strrchr 20 4
export N_strcmp
proc N_strcmp 8 0
line 886
;883:}
;884:
;885:int N_strcmp (const char *str1, const char *str2)
;886:{
line 887
;887:    const char *s1 = str1;
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
line 888
;888:    const char *s2 = str2;
ADDRLP4 4
ADDRFP4 4
INDIRP4
ASGNP4
ADDRGP4 $410
JUMPV
LABELV $409
line 889
;889:	while (1) {
line 890
;890:		if (*s1 != *s2)
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
ADDRLP4 4
INDIRP4
INDIRI1
CVII4 1
EQI4 $412
line 891
;891:			return -1;              // strings not equal    
CNSTI4 -1
RETI4
ADDRGP4 $408
JUMPV
LABELV $412
line 892
;892:		if (!*s1)
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $414
line 893
;893:			return 1;               // strings are equal
CNSTI4 1
RETI4
ADDRGP4 $408
JUMPV
LABELV $414
line 894
;894:		s1++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 895
;895:		s2++;
ADDRLP4 4
ADDRLP4 4
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 896
;896:	}
LABELV $410
line 889
ADDRGP4 $409
JUMPV
line 898
;897:	
;898:	return 0;
CNSTI4 0
RETI4
LABELV $408
endproc N_strcmp 8 0
export N_streq
proc N_streq 16 0
line 902
;899:}
;900:
;901:qboolean N_streq(const char *str1, const char *str2)
;902:{
line 903
;903:	const char *s1 = str1;
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
line 904
;904:	const char *s2 = str2;
ADDRLP4 4
ADDRFP4 4
INDIRP4
ASGNP4
ADDRGP4 $418
JUMPV
LABELV $417
line 906
;905:	
;906:	while (*s2 && *s1) {
line 907
;907:		if (*s1++ != *s2++)
ADDRLP4 8
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 8
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 12
ADDRLP4 4
INDIRP4
ASGNP4
ADDRLP4 4
ADDRLP4 12
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 8
INDIRP4
INDIRI1
CVII4 1
ADDRLP4 12
INDIRP4
INDIRI1
CVII4 1
EQI4 $420
line 908
;908:			return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $416
JUMPV
LABELV $420
line 909
;909:	}
LABELV $418
line 906
ADDRLP4 4
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
EQI4 $422
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $417
LABELV $422
line 910
;910:	return qtrue;
CNSTI4 1
RETI4
LABELV $416
endproc N_streq 16 0
export N_strneq
proc N_strneq 16 0
line 914
;911:}
;912:
;913:qboolean N_strneq(const char *str1, const char *str2, size_t n)
;914:{
line 915
;915:	const char *s1 = str1;
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
line 916
;916:	const char *s2 = str2;
ADDRLP4 4
ADDRFP4 4
INDIRP4
ASGNP4
ADDRGP4 $425
JUMPV
LABELV $424
line 918
;917:
;918:	while (*s1 && n) {
line 919
;919:		if (*s1++ != *s2++)
ADDRLP4 8
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 8
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 12
ADDRLP4 4
INDIRP4
ASGNP4
ADDRLP4 4
ADDRLP4 12
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 8
INDIRP4
INDIRI1
CVII4 1
ADDRLP4 12
INDIRP4
INDIRI1
CVII4 1
EQI4 $427
line 920
;920:			return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $423
JUMPV
LABELV $427
line 921
;921:		n--;
ADDRFP4 8
ADDRFP4 8
INDIRU4
CNSTU4 1
SUBU4
ASGNU4
line 922
;922:	}
LABELV $425
line 918
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
EQI4 $429
ADDRFP4 8
INDIRU4
CNSTU4 0
NEU4 $424
LABELV $429
line 923
;923:	return qtrue;
CNSTI4 1
RETI4
LABELV $423
endproc N_strneq 16 0
export N_strncmp
proc N_strncmp 24 0
line 927
;924:}
;925:
;926:int N_strncmp( const char *s1, const char *s2, size_t n )
;927:{
LABELV $431
line 930
;928:	int c1, c2;
;929:	
;930:	do {
line 931
;931:		c1 = *s1++;
ADDRLP4 8
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 8
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 0
ADDRLP4 8
INDIRP4
INDIRI1
CVII4 1
ASGNI4
line 932
;932:		c2 = *s2++;
ADDRLP4 12
ADDRFP4 4
INDIRP4
ASGNP4
ADDRFP4 4
ADDRLP4 12
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
ADDRLP4 12
INDIRP4
INDIRI1
CVII4 1
ASGNI4
line 934
;933:
;934:		if (!n--) {
ADDRLP4 16
ADDRFP4 8
INDIRU4
ASGNU4
ADDRFP4 8
ADDRLP4 16
INDIRU4
CNSTU4 1
SUBU4
ASGNU4
ADDRLP4 16
INDIRU4
CNSTU4 0
NEU4 $434
line 935
;935:			return 0;		// strings are equal until end point
CNSTI4 0
RETI4
ADDRGP4 $430
JUMPV
LABELV $434
line 938
;936:		}
;937:		
;938:		if (c1 != c2) {
ADDRLP4 0
INDIRI4
ADDRLP4 4
INDIRI4
EQI4 $436
line 939
;939:			return c1 < c2 ? -1 : 1;
ADDRLP4 0
INDIRI4
ADDRLP4 4
INDIRI4
GEI4 $439
ADDRLP4 20
CNSTI4 -1
ASGNI4
ADDRGP4 $440
JUMPV
LABELV $439
ADDRLP4 20
CNSTI4 1
ASGNI4
LABELV $440
ADDRLP4 20
INDIRI4
RETI4
ADDRGP4 $430
JUMPV
LABELV $436
line 941
;940:		}
;941:	} while (c1);
LABELV $432
ADDRLP4 0
INDIRI4
CNSTI4 0
NEI4 $431
line 943
;942:	
;943:	return 0;		// strings are equal
CNSTI4 0
RETI4
LABELV $430
endproc N_strncmp 24 0
export N_stricmpn
proc N_stricmpn 32 0
line 947
;944:}
;945:
;946:int N_stricmpn (const char *str1, const char *str2, size_t n)
;947:{
line 951
;948:	int c1, c2;
;949:
;950:	// bk001129 - moved in 1.17 fix not in id codebase
;951:    if (str1 == NULL) {
ADDRFP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $442
line 952
;952:    	if (str2 == NULL) {
ADDRFP4 4
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $444
line 953
;953:            return 0;
CNSTI4 0
RETI4
ADDRGP4 $441
JUMPV
LABELV $444
line 955
;954:		}
;955:        else {
line 956
;956:            return -1;
CNSTI4 -1
RETI4
ADDRGP4 $441
JUMPV
LABELV $442
line 959
;957:		}
;958:    }
;959:    else if (str2 == NULL) {
ADDRFP4 4
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $446
line 960
;960:        return 1;
CNSTI4 1
RETI4
ADDRGP4 $441
JUMPV
LABELV $446
LABELV $448
line 963
;961:	}
;962:	
;963:	do {
line 964
;964:		c1 = *str1++;
ADDRLP4 8
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 8
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 0
ADDRLP4 8
INDIRP4
INDIRI1
CVII4 1
ASGNI4
line 965
;965:		c2 = *str2++;
ADDRLP4 12
ADDRFP4 4
INDIRP4
ASGNP4
ADDRFP4 4
ADDRLP4 12
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
ADDRLP4 12
INDIRP4
INDIRI1
CVII4 1
ASGNI4
line 967
;966:
;967:		if (!n--) {
ADDRLP4 16
ADDRFP4 8
INDIRU4
ASGNU4
ADDRFP4 8
ADDRLP4 16
INDIRU4
CNSTU4 1
SUBU4
ASGNU4
ADDRLP4 16
INDIRU4
CNSTU4 0
NEU4 $451
line 968
;968:			return 0;		// strings are equal until end point
CNSTI4 0
RETI4
ADDRGP4 $441
JUMPV
LABELV $451
line 971
;969:		}
;970:		
;971:		if (c1 != c2) {
ADDRLP4 0
INDIRI4
ADDRLP4 4
INDIRI4
EQI4 $453
line 972
;972:			if (c1 >= 'a' && c1 <= 'z') {
ADDRLP4 0
INDIRI4
CNSTI4 97
LTI4 $455
ADDRLP4 0
INDIRI4
CNSTI4 122
GTI4 $455
line 973
;973:				c1 -= ('a' - 'A');
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 32
SUBI4
ASGNI4
line 974
;974:			}
LABELV $455
line 975
;975:			if (c2 >= 'a' && c2 <= 'z') {
ADDRLP4 4
INDIRI4
CNSTI4 97
LTI4 $457
ADDRLP4 4
INDIRI4
CNSTI4 122
GTI4 $457
line 976
;976:				c2 -= ('a' - 'A');
ADDRLP4 4
ADDRLP4 4
INDIRI4
CNSTI4 32
SUBI4
ASGNI4
line 977
;977:			}
LABELV $457
line 978
;978:			if (c1 != c2) {
ADDRLP4 0
INDIRI4
ADDRLP4 4
INDIRI4
EQI4 $459
line 979
;979:				return c1 < c2 ? -1 : 1;
ADDRLP4 0
INDIRI4
ADDRLP4 4
INDIRI4
GEI4 $462
ADDRLP4 28
CNSTI4 -1
ASGNI4
ADDRGP4 $463
JUMPV
LABELV $462
ADDRLP4 28
CNSTI4 1
ASGNI4
LABELV $463
ADDRLP4 28
INDIRI4
RETI4
ADDRGP4 $441
JUMPV
LABELV $459
line 981
;980:			}
;981:		}
LABELV $453
line 982
;982:	} while (c1);
LABELV $449
ADDRLP4 0
INDIRI4
CNSTI4 0
NEI4 $448
line 984
;983:	
;984:	return 0;		// strings are equal
CNSTI4 0
RETI4
LABELV $441
endproc N_stricmpn 32 0
export N_stricmp
proc N_stricmp 24 0
line 988
;985:}
;986:
;987:int N_stricmp( const char *s1, const char *s2 ) 
;988:{
line 991
;989:	unsigned char c1, c2;
;990:
;991:	if (s1 == NULL)  {
ADDRFP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $465
line 992
;992:		if (s2 == NULL)
ADDRFP4 4
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $467
line 993
;993:			return 0;
CNSTI4 0
RETI4
ADDRGP4 $464
JUMPV
LABELV $467
line 995
;994:		else
;995:			return -1;
CNSTI4 -1
RETI4
ADDRGP4 $464
JUMPV
LABELV $465
line 997
;996:	}
;997:	else if (s2 == NULL)
ADDRFP4 4
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $469
line 998
;998:		return 1;
CNSTI4 1
RETI4
ADDRGP4 $464
JUMPV
LABELV $469
LABELV $471
line 1000
;999:	
;1000:	do {
line 1001
;1001:		c1 = *s1++;
ADDRLP4 4
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 4
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 0
ADDRLP4 4
INDIRP4
INDIRI1
CVII4 1
CVIU4 4
CVUU1 4
ASGNU1
line 1002
;1002:		c2 = *s2++;
ADDRLP4 8
ADDRFP4 4
INDIRP4
ASGNP4
ADDRFP4 4
ADDRLP4 8
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 1
ADDRLP4 8
INDIRP4
INDIRI1
CVII4 1
CVIU4 4
CVUU1 4
ASGNU1
line 1004
;1003:
;1004:		if (c1 != c2) {
ADDRLP4 0
INDIRU1
CVUI4 1
ADDRLP4 1
INDIRU1
CVUI4 1
EQI4 $474
line 1005
;1005:			if ( c1 <= 'Z' && c1 >= 'A' )
ADDRLP4 12
ADDRLP4 0
INDIRU1
CVUI4 1
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 90
GTI4 $476
ADDRLP4 12
INDIRI4
CNSTI4 65
LTI4 $476
line 1006
;1006:				c1 += ('a' - 'A');
ADDRLP4 0
ADDRLP4 0
INDIRU1
CVUI4 1
CNSTI4 32
ADDI4
CVIU4 4
CVUU1 4
ASGNU1
LABELV $476
line 1008
;1007:
;1008:			if ( c2 <= 'Z' && c2 >= 'A' )
ADDRLP4 16
ADDRLP4 1
INDIRU1
CVUI4 1
ASGNI4
ADDRLP4 16
INDIRI4
CNSTI4 90
GTI4 $478
ADDRLP4 16
INDIRI4
CNSTI4 65
LTI4 $478
line 1009
;1009:				c2 += ('a' - 'A');
ADDRLP4 1
ADDRLP4 1
INDIRU1
CVUI4 1
CNSTI4 32
ADDI4
CVIU4 4
CVUU1 4
ASGNU1
LABELV $478
line 1011
;1010:
;1011:			if ( c1 != c2 ) 
ADDRLP4 0
INDIRU1
CVUI4 1
ADDRLP4 1
INDIRU1
CVUI4 1
EQI4 $480
line 1012
;1012:				return c1 < c2 ? -1 : 1;
ADDRLP4 0
INDIRU1
CVUI4 1
ADDRLP4 1
INDIRU1
CVUI4 1
GEI4 $483
ADDRLP4 20
CNSTI4 -1
ASGNI4
ADDRGP4 $484
JUMPV
LABELV $483
ADDRLP4 20
CNSTI4 1
ASGNI4
LABELV $484
ADDRLP4 20
INDIRI4
RETI4
ADDRGP4 $464
JUMPV
LABELV $480
line 1013
;1013:		}
LABELV $474
line 1014
;1014:	} while ( c1 != '\0' );
LABELV $472
ADDRLP4 0
INDIRU1
CVUI4 1
CNSTI4 0
NEI4 $471
line 1016
;1015:
;1016:	return 0;
CNSTI4 0
RETI4
LABELV $464
endproc N_stricmp 24 0
export N_atoi
proc N_atoi 36 0
line 1020
;1017:}
;1018:
;1019:int N_atoi (const char *s)
;1020:{
line 1024
;1021:	int val;
;1022:	int sign;
;1023:	int c;
;1024:    const char* str = s;
ADDRLP4 8
ADDRFP4 0
INDIRP4
ASGNP4
line 1026
;1025:	
;1026:	if (*str == '-') {
ADDRLP4 8
INDIRP4
INDIRI1
CVII4 1
CNSTI4 45
NEI4 $486
line 1027
;1027:		sign = -1;
ADDRLP4 12
CNSTI4 -1
ASGNI4
line 1028
;1028:		str++;
ADDRLP4 8
ADDRLP4 8
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1029
;1029:	}
ADDRGP4 $487
JUMPV
LABELV $486
line 1031
;1030:	else
;1031:		sign = 1;
ADDRLP4 12
CNSTI4 1
ASGNI4
LABELV $487
line 1033
;1032:		
;1033:	val = 0;
ADDRLP4 4
CNSTI4 0
ASGNI4
line 1038
;1034:
;1035:    //
;1036:    // check for hex
;1037:    //
;1038:	if (str[0] == '0' && (str[1] == 'x' || str[1] == 'X') ) {
ADDRLP4 8
INDIRP4
INDIRI1
CVII4 1
CNSTI4 48
NEI4 $488
ADDRLP4 8
INDIRP4
CNSTI4 1
ADDP4
INDIRI1
CVII4 1
CNSTI4 120
EQI4 $490
ADDRLP4 8
INDIRP4
CNSTI4 1
ADDP4
INDIRI1
CVII4 1
CNSTI4 88
NEI4 $488
LABELV $490
line 1039
;1039:		str += 2;
ADDRLP4 8
ADDRLP4 8
INDIRP4
CNSTI4 2
ADDP4
ASGNP4
ADDRGP4 $492
JUMPV
LABELV $491
line 1040
;1040:		while (1) {
line 1041
;1041:			c = *str++;
ADDRLP4 20
ADDRLP4 8
INDIRP4
ASGNP4
ADDRLP4 8
ADDRLP4 20
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 0
ADDRLP4 20
INDIRP4
INDIRI1
CVII4 1
ASGNI4
line 1042
;1042:			if (c >= '0' && c <= '9')
ADDRLP4 0
INDIRI4
CNSTI4 48
LTI4 $494
ADDRLP4 0
INDIRI4
CNSTI4 57
GTI4 $494
line 1043
;1043:				val = (val<<4) + c - '0';
ADDRLP4 4
ADDRLP4 4
INDIRI4
CNSTI4 4
LSHI4
ADDRLP4 0
INDIRI4
ADDI4
CNSTI4 48
SUBI4
ASGNI4
ADDRGP4 $495
JUMPV
LABELV $494
line 1044
;1044:			else if (c >= 'a' && c <= 'f')
ADDRLP4 0
INDIRI4
CNSTI4 97
LTI4 $496
ADDRLP4 0
INDIRI4
CNSTI4 102
GTI4 $496
line 1045
;1045:				val = (val<<4) + c - 'a' + 10;
ADDRLP4 4
ADDRLP4 4
INDIRI4
CNSTI4 4
LSHI4
ADDRLP4 0
INDIRI4
ADDI4
CNSTI4 97
SUBI4
CNSTI4 10
ADDI4
ASGNI4
ADDRGP4 $497
JUMPV
LABELV $496
line 1046
;1046:			else if (c >= 'A' && c <= 'F')
ADDRLP4 0
INDIRI4
CNSTI4 65
LTI4 $498
ADDRLP4 0
INDIRI4
CNSTI4 70
GTI4 $498
line 1047
;1047:				val = (val<<4) + c - 'A' + 10;
ADDRLP4 4
ADDRLP4 4
INDIRI4
CNSTI4 4
LSHI4
ADDRLP4 0
INDIRI4
ADDI4
CNSTI4 65
SUBI4
CNSTI4 10
ADDI4
ASGNI4
ADDRGP4 $499
JUMPV
LABELV $498
line 1049
;1048:			else
;1049:				return val*sign;
ADDRLP4 4
INDIRI4
ADDRLP4 12
INDIRI4
MULI4
RETI4
ADDRGP4 $485
JUMPV
LABELV $499
LABELV $497
LABELV $495
line 1050
;1050:		}
LABELV $492
line 1040
ADDRGP4 $491
JUMPV
line 1051
;1051:	}
LABELV $488
line 1056
;1052:	
;1053:    //
;1054:    // check for character
;1055:    //
;1056:	if (str[0] == '\'')
ADDRLP4 8
INDIRP4
INDIRI1
CVII4 1
CNSTI4 39
NEI4 $503
line 1057
;1057:		return sign * str[1];
ADDRLP4 12
INDIRI4
ADDRLP4 8
INDIRP4
CNSTI4 1
ADDP4
INDIRI1
CVII4 1
MULI4
RETI4
ADDRGP4 $485
JUMPV
LABELV $502
line 1062
;1058:	
;1059:    //
;1060:    // assume decimal
;1061:    //
;1062:	while (1) {
line 1063
;1063:		c = *str++;
ADDRLP4 20
ADDRLP4 8
INDIRP4
ASGNP4
ADDRLP4 8
ADDRLP4 20
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 0
ADDRLP4 20
INDIRP4
INDIRI1
CVII4 1
ASGNI4
line 1064
;1064:		if (c <'0' || c > '9')
ADDRLP4 0
INDIRI4
CNSTI4 48
LTI4 $507
ADDRLP4 0
INDIRI4
CNSTI4 57
LEI4 $505
LABELV $507
line 1065
;1065:			return val*sign;
ADDRLP4 4
INDIRI4
ADDRLP4 12
INDIRI4
MULI4
RETI4
ADDRGP4 $485
JUMPV
LABELV $505
line 1066
;1066:		val = val*10 + c - '0';
ADDRLP4 4
ADDRLP4 4
INDIRI4
CNSTI4 10
MULI4
ADDRLP4 0
INDIRI4
ADDI4
CNSTI4 48
SUBI4
ASGNI4
line 1067
;1067:	}
LABELV $503
line 1062
ADDRGP4 $502
JUMPV
line 1069
;1068:	
;1069:	return 0;
CNSTI4 0
RETI4
LABELV $485
endproc N_atoi 36 0
export Com_snprintf
proc Com_snprintf 32016 12
line 1077
;1070:}
;1071:
;1072:#if	defined(_DEBUG) && defined(_WIN32)
;1073:#include <windows.h>
;1074:#endif
;1075:
;1076:int GDR_ATTRIBUTE((format(printf, 3, 4))) GDR_DECL Com_snprintf( char *dest, uint32_t size, const char *fmt, ...)
;1077:{
line 1082
;1078:	int		len;
;1079:	va_list	argptr;
;1080:	char	bigbuffer[32000];	// big, but small enough to fit in PPC stack
;1081:
;1082:	if ( !dest )  {
ADDRFP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $509
line 1083
;1083:		N_Error( ERR_FATAL, "Com_snprintf: NULL dest" );
CNSTI4 0
ARGI4
ADDRGP4 $511
ARGP4
ADDRGP4 N_Error
CALLV
pop
line 1087
;1084:#if	defined(_DEBUG) && defined(_WIN32)
;1085:		DebugBreak();
;1086:#endif
;1087:		return 0;
CNSTI4 0
RETI4
ADDRGP4 $508
JUMPV
LABELV $509
line 1090
;1088:	}
;1089:
;1090:	va_start( argptr, fmt );
ADDRLP4 4
ADDRFP4 8+4
ASGNP4
line 1091
;1091:	len = vsprintf( bigbuffer, fmt, argptr );
ADDRLP4 8
ARGP4
ADDRFP4 8
INDIRP4
ARGP4
ADDRLP4 4
INDIRP4
ARGP4
ADDRLP4 32008
ADDRGP4 vsprintf
CALLI4
ASGNI4
ADDRLP4 0
ADDRLP4 32008
INDIRI4
ASGNI4
line 1092
;1092:	va_end( argptr );
ADDRLP4 4
CNSTP4 0
ASGNP4
line 1094
;1093:
;1094:	if ( len >= sizeof( bigbuffer ) || len < 0 )  {
ADDRLP4 0
INDIRI4
CVIU4 4
CNSTU4 32000
GEU4 $515
ADDRLP4 0
INDIRI4
CNSTI4 0
GEI4 $513
LABELV $515
line 1095
;1095:		N_Error( ERR_FATAL, "Com_smprintf: overflowed bigbuffer" );
CNSTI4 0
ARGI4
ADDRGP4 $516
ARGP4
ADDRGP4 N_Error
CALLV
pop
line 1099
;1096:#if	defined(_DEBUG) && defined(_WIN32)
;1097:		DebugBreak();
;1098:#endif
;1099:		return 0;
CNSTI4 0
RETI4
ADDRGP4 $508
JUMPV
LABELV $513
line 1102
;1100:	}
;1101:
;1102:	if ( len >= size )  {
ADDRLP4 0
INDIRI4
CVIU4 4
ADDRFP4 4
INDIRU4
LTU4 $517
line 1103
;1103:		Con_Printf( COLOR_YELLOW "Com_snprintf: overflow of %i in %u\n", len, size );
ADDRGP4 $519
ARGP4
ADDRLP4 0
INDIRI4
ARGI4
ADDRFP4 4
INDIRU4
ARGU4
ADDRGP4 Con_Printf
CALLV
pop
line 1107
;1104:#if	defined(_DEBUG) && defined(_WIN32)
;1105:		DebugBreak();
;1106:#endif
;1107:		len = size - 1;
ADDRLP4 0
ADDRFP4 4
INDIRU4
CNSTU4 1
SUBU4
CVUI4 4
ASGNI4
line 1108
;1108:	}
LABELV $517
line 1112
;1109:
;1110:	//Q_strncpyz( dest, bigbuffer, size );
;1111:	//strncpy( dest, bigbuffer, len );
;1112:	memcpy( dest, bigbuffer, len );
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 8
ARGP4
ADDRLP4 0
INDIRI4
CVIU4 4
ARGU4
ADDRGP4 memcpy
CALLP4
pop
line 1113
;1113:	dest[ len ] = '\0';
ADDRLP4 0
INDIRI4
ADDRFP4 0
INDIRP4
ADDP4
CNSTI1 0
ASGNI1
line 1115
;1114:
;1115:	return len;
ADDRLP4 0
INDIRI4
RETI4
LABELV $508
endproc Com_snprintf 32016 12
export COM_SkipPath
proc COM_SkipPath 4 0
line 1124
;1116:}
;1117:
;1118:/*
;1119:============
;1120:COM_SkipPath
;1121:============
;1122:*/
;1123:char *COM_SkipPath (char *pathname)
;1124:{
line 1127
;1125:	char	*last;
;1126:	
;1127:	last = pathname;
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
ADDRGP4 $522
JUMPV
LABELV $521
line 1128
;1128:	while (*pathname) {
line 1129
;1129:		if (*pathname=='/')
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 47
NEI4 $524
line 1130
;1130:			last = pathname+1;
ADDRLP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
LABELV $524
line 1131
;1131:		pathname++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1132
;1132:	}
LABELV $522
line 1128
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $521
line 1133
;1133:	return last;
ADDRLP4 0
INDIRP4
RETP4
LABELV $520
endproc COM_SkipPath 4 0
export COM_GetExtension
proc COM_GetExtension 20 8
line 1142
;1134:}
;1135:
;1136:/*
;1137:============
;1138:COM_GetExtension
;1139:============
;1140:*/
;1141:const char *COM_GetExtension( const char *name )
;1142:{
line 1143
;1143:	const char *dot = (const char *)strrchr(name, '.'), *slash;
ADDRFP4 0
INDIRP4
ARGP4
CNSTI4 46
ARGI4
ADDRLP4 8
ADDRGP4 strrchr
CALLI4
ASGNI4
ADDRLP4 0
ADDRLP4 8
INDIRI4
CVIU4 4
CVUP4 4
ASGNP4
line 1144
;1144:	if (dot && ((slash = (const char *)strrchr(name, '/')) == NULL || slash < dot))
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $527
ADDRFP4 0
INDIRP4
ARGP4
CNSTI4 47
ARGI4
ADDRLP4 12
ADDRGP4 strrchr
CALLI4
ASGNI4
ADDRLP4 16
ADDRLP4 12
INDIRI4
CVIU4 4
CVUP4 4
ASGNP4
ADDRLP4 4
ADDRLP4 16
INDIRP4
ASGNP4
ADDRLP4 16
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $529
ADDRLP4 4
INDIRP4
CVPU4 4
ADDRLP4 0
INDIRP4
CVPU4 4
GEU4 $527
LABELV $529
line 1145
;1145:		return dot + 1;
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
RETP4
ADDRGP4 $526
JUMPV
LABELV $527
line 1147
;1146:	else
;1147:		return "";
ADDRGP4 $530
RETP4
LABELV $526
endproc COM_GetExtension 20 8
export COM_BeginParseSession
proc COM_BeginParseSession 0 16
line 1167
;1148:}
;1149:
;1150:/*
;1151:===============================================================
;1152:
;1153:Parsing
;1154:
;1155:===============================================================
;1156:*/
;1157:
;1158:static	char	com_token[MAX_TOKEN_CHARS];
;1159:static	char	com_parsename[MAX_TOKEN_CHARS];
;1160:static	uint64_t com_lines;
;1161:static  uint64_t com_tokenline;
;1162:
;1163:// for complex parser
;1164:tokenType_t		com_tokentype;
;1165:
;1166:void COM_BeginParseSession( const char *name )
;1167:{
line 1168
;1168:	com_lines = 1;
ADDRGP4 com_lines
CNSTU4 1
ASGNU4
line 1169
;1169:	com_tokenline = 0;
ADDRGP4 com_tokenline
CNSTU4 0
ASGNU4
line 1170
;1170:	Com_snprintf(com_parsename, sizeof(com_parsename), "%s", name);
ADDRGP4 com_parsename
ARGP4
CNSTU4 1024
ARGU4
ADDRGP4 $532
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRGP4 Com_snprintf
CALLI4
pop
line 1171
;1171:}
LABELV $531
endproc COM_BeginParseSession 0 16
export COM_GetCurrentParseLine
proc COM_GetCurrentParseLine 0 0
line 1175
;1172:
;1173:
;1174:uint64_t COM_GetCurrentParseLine( void )
;1175:{
line 1176
;1176:	if ( com_tokenline )
ADDRGP4 com_tokenline
INDIRU4
CNSTU4 0
EQU4 $534
line 1177
;1177:	{
line 1178
;1178:		return com_tokenline;
ADDRGP4 com_tokenline
INDIRU4
RETU4
ADDRGP4 $533
JUMPV
LABELV $534
line 1181
;1179:	}
;1180:
;1181:	return com_lines;
ADDRGP4 com_lines
INDIRU4
RETU4
LABELV $533
endproc COM_GetCurrentParseLine 0 0
export COM_Parse
proc COM_Parse 4 8
line 1186
;1182:}
;1183:
;1184:
;1185:const char *COM_Parse( const char **data_p )
;1186:{
line 1187
;1187:	return COM_ParseExt( data_p, qtrue );
ADDRFP4 0
INDIRP4
ARGP4
CNSTI4 1
ARGI4
ADDRLP4 0
ADDRGP4 COM_ParseExt
CALLP4
ASGNP4
ADDRLP4 0
INDIRP4
RETP4
LABELV $536
endproc COM_Parse 4 8
bss
align 1
LABELV $538
skip 4096
export COM_ParseError
code
proc COM_ParseError 8 16
line 1191
;1188:}
;1189:
;1190:void COM_ParseError( const char *format, ... )
;1191:{
line 1195
;1192:	va_list argptr;
;1193:	static char string[4096];
;1194:
;1195:	va_start( argptr, format );
ADDRLP4 0
ADDRFP4 0+4
ASGNP4
line 1196
;1196:	vsprintf (string, format, argptr);
ADDRGP4 $538
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 vsprintf
CALLI4
pop
line 1197
;1197:	va_end( argptr );
ADDRLP4 0
CNSTP4 0
ASGNP4
line 1199
;1198:
;1199:	Con_Printf( COLOR_RED "ERROR: %s, line %lu: %s\n", com_parsename, COM_GetCurrentParseLine(), string );
ADDRLP4 4
ADDRGP4 COM_GetCurrentParseLine
CALLU4
ASGNU4
ADDRGP4 $540
ARGP4
ADDRGP4 com_parsename
ARGP4
ADDRLP4 4
INDIRU4
ARGU4
ADDRGP4 $538
ARGP4
ADDRGP4 Con_Printf
CALLV
pop
line 1200
;1200:}
LABELV $537
endproc COM_ParseError 8 16
bss
align 1
LABELV $542
skip 4096
export COM_ParseWarning
code
proc COM_ParseWarning 8 16
line 1203
;1201:
;1202:void COM_ParseWarning( const char *format, ... )
;1203:{
line 1207
;1204:	va_list argptr;
;1205:	static char string[4096];
;1206:
;1207:	va_start( argptr, format );
ADDRLP4 0
ADDRFP4 0+4
ASGNP4
line 1208
;1208:	vsprintf (string, format, argptr);
ADDRGP4 $542
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 vsprintf
CALLI4
pop
line 1209
;1209:	va_end( argptr );
ADDRLP4 0
CNSTP4 0
ASGNP4
line 1211
;1210:
;1211:	Con_Printf( COLOR_YELLOW "WARNING: %s, line %lu: %s\n", com_parsename, COM_GetCurrentParseLine(), string );
ADDRLP4 4
ADDRGP4 COM_GetCurrentParseLine
CALLU4
ASGNU4
ADDRGP4 $544
ARGP4
ADDRGP4 com_parsename
ARGP4
ADDRLP4 4
INDIRU4
ARGU4
ADDRGP4 $542
ARGP4
ADDRGP4 Con_Printf
CALLV
pop
line 1212
;1212:}
LABELV $541
endproc COM_ParseWarning 8 16
export SkipWhitespace
proc SkipWhitespace 8 0
line 1227
;1213:
;1214:
;1215:/*
;1216:==============
;1217:COM_Parse
;1218:
;1219:Parse a token out of a string
;1220:Will never return NULL, just empty strings
;1221:
;1222:If "allowLineBreaks" is qtrue then an empty
;1223:string will be returned if the next token is
;1224:a newline.
;1225:==============
;1226:*/
;1227:const char *SkipWhitespace( const char *data, qboolean *hasNewLines ) {
ADDRGP4 $547
JUMPV
LABELV $546
line 1230
;1228:	int c;
;1229:
;1230:	while( (c = *data) <= ' ') {
line 1231
;1231:		if( !c ) {
ADDRLP4 0
INDIRI4
CNSTI4 0
NEI4 $549
line 1232
;1232:			return NULL;
CNSTP4 0
RETP4
ADDRGP4 $545
JUMPV
LABELV $549
line 1234
;1233:		}
;1234:		if( c == '\n' ) {
ADDRLP4 0
INDIRI4
CNSTI4 10
NEI4 $551
line 1235
;1235:			com_lines++;
ADDRLP4 4
ADDRGP4 com_lines
ASGNP4
ADDRLP4 4
INDIRP4
ADDRLP4 4
INDIRP4
INDIRU4
CNSTU4 1
ADDU4
ASGNU4
line 1236
;1236:			*hasNewLines = qtrue;
ADDRFP4 4
INDIRP4
CNSTI4 1
ASGNI4
line 1237
;1237:		}
LABELV $551
line 1238
;1238:		data++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1239
;1239:	}
LABELV $547
line 1230
ADDRLP4 4
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 0
ADDRLP4 4
INDIRI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 32
LEI4 $546
line 1241
;1240:
;1241:	return data;
ADDRFP4 0
INDIRP4
RETP4
LABELV $545
endproc SkipWhitespace 8 0
export COM_Compress
proc COM_Compress 44 0
line 1244
;1242:}
;1243:
;1244:uintptr_t COM_Compress( char *data_p ) {
line 1248
;1245:	const char *in;
;1246:	char *out;
;1247:	int c;
;1248:	qboolean newline = qfalse, whitespace = qfalse;
ADDRLP4 12
CNSTI4 0
ASGNI4
ADDRLP4 16
CNSTI4 0
ASGNI4
line 1250
;1249:
;1250:	in = out = data_p;
ADDRLP4 20
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 8
ADDRLP4 20
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 20
INDIRP4
ASGNP4
ADDRGP4 $555
JUMPV
LABELV $554
line 1251
;1251:	while ((c = *in) != '\0') {
line 1253
;1252:		// skip double slash comments
;1253:		if ( c == '/' && in[1] == '/' ) {
ADDRLP4 4
INDIRI4
CNSTI4 47
NEI4 $557
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
INDIRI1
CVII4 1
CNSTI4 47
NEI4 $557
ADDRGP4 $560
JUMPV
LABELV $559
line 1254
;1254:			while (*in && *in != '\n') {
line 1255
;1255:				in++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1256
;1256:			}
LABELV $560
line 1254
ADDRLP4 24
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 24
INDIRI4
CNSTI4 0
EQI4 $562
ADDRLP4 24
INDIRI4
CNSTI4 10
NEI4 $559
LABELV $562
line 1258
;1257:		// skip /* */ comments
;1258:		} else if ( c == '/' && in[1] == '*' ) {
ADDRGP4 $558
JUMPV
LABELV $557
ADDRLP4 4
INDIRI4
CNSTI4 47
NEI4 $563
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
INDIRI1
CVII4 1
CNSTI4 42
NEI4 $563
ADDRGP4 $566
JUMPV
LABELV $565
line 1260
;1259:			while ( *in && ( *in != '*' || in[1] != '/' ) ) 
;1260:				in++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
LABELV $566
line 1259
ADDRLP4 28
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 28
INDIRI4
CNSTI4 0
EQI4 $568
ADDRLP4 28
INDIRI4
CNSTI4 42
NEI4 $565
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
INDIRI1
CVII4 1
CNSTI4 47
NEI4 $565
LABELV $568
line 1261
;1261:			if ( *in ) 
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
EQI4 $564
line 1262
;1262:				in += 2;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 2
ADDP4
ASGNP4
line 1264
;1263:			// record when we hit a newline
;1264:		} else if ( c == '\n' || c == '\r' ) {
ADDRGP4 $564
JUMPV
LABELV $563
ADDRLP4 4
INDIRI4
CNSTI4 10
EQI4 $573
ADDRLP4 4
INDIRI4
CNSTI4 13
NEI4 $571
LABELV $573
line 1265
;1265:			newline = qtrue;
ADDRLP4 12
CNSTI4 1
ASGNI4
line 1266
;1266:			in++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1268
;1267:			// record when we hit whitespace
;1268:		} else if ( c == ' ' || c == '\t') {
ADDRGP4 $572
JUMPV
LABELV $571
ADDRLP4 4
INDIRI4
CNSTI4 32
EQI4 $576
ADDRLP4 4
INDIRI4
CNSTI4 9
NEI4 $574
LABELV $576
line 1269
;1269:			whitespace = qtrue;
ADDRLP4 16
CNSTI4 1
ASGNI4
line 1270
;1270:			in++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1272
;1271:			// an actual token
;1272:		} else {
ADDRGP4 $575
JUMPV
LABELV $574
line 1274
;1273:			// if we have a pending newline, emit it (and it counts as whitespace)
;1274:			if (newline) {
ADDRLP4 12
INDIRI4
CNSTI4 0
EQI4 $577
line 1275
;1275:				*out++ = '\n';
ADDRLP4 32
ADDRLP4 8
INDIRP4
ASGNP4
ADDRLP4 8
ADDRLP4 32
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 32
INDIRP4
CNSTI1 10
ASGNI1
line 1276
;1276:				newline = qfalse;
ADDRLP4 12
CNSTI4 0
ASGNI4
line 1277
;1277:				whitespace = qfalse;
ADDRLP4 16
CNSTI4 0
ASGNI4
line 1278
;1278:			} else if (whitespace) {
ADDRGP4 $578
JUMPV
LABELV $577
ADDRLP4 16
INDIRI4
CNSTI4 0
EQI4 $579
line 1279
;1279:				*out++ = ' ';
ADDRLP4 32
ADDRLP4 8
INDIRP4
ASGNP4
ADDRLP4 8
ADDRLP4 32
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 32
INDIRP4
CNSTI1 32
ASGNI1
line 1280
;1280:				whitespace = qfalse;
ADDRLP4 16
CNSTI4 0
ASGNI4
line 1281
;1281:			}
LABELV $579
LABELV $578
line 1283
;1282:			// copy quoted strings unmolested
;1283:			if (c == '"') {
ADDRLP4 4
INDIRI4
CNSTI4 34
NEI4 $581
line 1284
;1284:				*out++ = c;
ADDRLP4 32
ADDRLP4 8
INDIRP4
ASGNP4
ADDRLP4 8
ADDRLP4 32
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 32
INDIRP4
ADDRLP4 4
INDIRI4
CVII1 4
ASGNI1
line 1285
;1285:				in++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRGP4 $584
JUMPV
LABELV $583
line 1286
;1286:				while (1) {
line 1287
;1287:					c = *in;
ADDRLP4 4
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
line 1288
;1288:					if (c && c != '"') {
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $585
ADDRLP4 4
INDIRI4
CNSTI4 34
EQI4 $585
line 1289
;1289:						*out++ = c;
ADDRLP4 40
ADDRLP4 8
INDIRP4
ASGNP4
ADDRLP4 8
ADDRLP4 40
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 40
INDIRP4
ADDRLP4 4
INDIRI4
CVII1 4
ASGNI1
line 1290
;1290:						in++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1291
;1291:					} else {
line 1292
;1292:						break;
LABELV $587
line 1294
;1293:					}
;1294:				}
LABELV $584
line 1286
ADDRGP4 $583
JUMPV
LABELV $585
line 1295
;1295:				if (c == '"') {
ADDRLP4 4
INDIRI4
CNSTI4 34
NEI4 $582
line 1296
;1296:					*out++ = c;
ADDRLP4 36
ADDRLP4 8
INDIRP4
ASGNP4
ADDRLP4 8
ADDRLP4 36
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 36
INDIRP4
ADDRLP4 4
INDIRI4
CVII1 4
ASGNI1
line 1297
;1297:					in++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1298
;1298:				}
line 1299
;1299:			} else {
ADDRGP4 $582
JUMPV
LABELV $581
line 1300
;1300:				*out++ = c;
ADDRLP4 32
ADDRLP4 8
INDIRP4
ASGNP4
ADDRLP4 8
ADDRLP4 32
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 32
INDIRP4
ADDRLP4 4
INDIRI4
CVII1 4
ASGNI1
line 1301
;1301:				in++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1302
;1302:			}
LABELV $582
line 1303
;1303:		}
LABELV $575
LABELV $572
LABELV $564
LABELV $558
line 1304
;1304:	}
LABELV $555
line 1251
ADDRLP4 24
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 4
ADDRLP4 24
INDIRI4
ASGNI4
ADDRLP4 24
INDIRI4
CNSTI4 0
NEI4 $554
line 1306
;1305:
;1306:	*out = '\0';
ADDRLP4 8
INDIRP4
CNSTI1 0
ASGNI1
line 1308
;1307:
;1308:	return (uintptr_t)(out - data_p);
ADDRLP4 8
INDIRP4
CVPU4 4
ADDRFP4 0
INDIRP4
CVPU4 4
SUBU4
CVUI4 4
CVIU4 4
RETU4
LABELV $553
endproc COM_Compress 44 0
export COM_ParseExt
proc COM_ParseExt 28 8
line 1312
;1309:}
;1310:
;1311:const char *COM_ParseExt( const char **data_p, qboolean allowLineBreaks )
;1312:{
line 1313
;1313:	int c = 0, len;
ADDRLP4 4
CNSTI4 0
ASGNI4
line 1314
;1314:	qboolean hasNewLines = qfalse;
ADDRLP4 12
CNSTI4 0
ASGNI4
line 1317
;1315:	const char *data;
;1316:
;1317:	data = *data_p;
ADDRLP4 0
ADDRFP4 0
INDIRP4
INDIRP4
ASGNP4
line 1318
;1318:	len = 0;
ADDRLP4 8
CNSTI4 0
ASGNI4
line 1319
;1319:	com_token[0] = '\0';
ADDRGP4 com_token
CNSTI1 0
ASGNI1
line 1320
;1320:	com_tokenline = 0;
ADDRGP4 com_tokenline
CNSTU4 0
ASGNU4
line 1323
;1321:
;1322:	// make sure incoming data is valid
;1323:	if ( !data ) {
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $594
line 1324
;1324:		*data_p = NULL;
ADDRFP4 0
INDIRP4
CNSTP4 0
ASGNP4
line 1325
;1325:		return com_token;
ADDRGP4 com_token
RETP4
ADDRGP4 $590
JUMPV
LABELV $593
line 1328
;1326:	}
;1327:
;1328:	while ( 1 ) {
line 1330
;1329:		// skip whitespace
;1330:		data = SkipWhitespace( data, &hasNewLines );
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 12
ARGP4
ADDRLP4 16
ADDRGP4 SkipWhitespace
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 16
INDIRP4
ASGNP4
line 1331
;1331:		if ( !data ) {
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $596
line 1332
;1332:			*data_p = NULL;
ADDRFP4 0
INDIRP4
CNSTP4 0
ASGNP4
line 1333
;1333:			return com_token;
ADDRGP4 com_token
RETP4
ADDRGP4 $590
JUMPV
LABELV $596
line 1335
;1334:		}
;1335:		if ( hasNewLines && !allowLineBreaks ) {
ADDRLP4 12
INDIRI4
CNSTI4 0
EQI4 $598
ADDRFP4 4
INDIRI4
CNSTI4 0
NEI4 $598
line 1336
;1336:			*data_p = data;
ADDRFP4 0
INDIRP4
ADDRLP4 0
INDIRP4
ASGNP4
line 1337
;1337:			return com_token;
ADDRGP4 com_token
RETP4
ADDRGP4 $590
JUMPV
LABELV $598
line 1340
;1338:		}
;1339:
;1340:		c = *data;
ADDRLP4 4
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
line 1343
;1341:
;1342:		// skip double slash comments
;1343:		if ( c == '/' && data[1] == '/' ) {
ADDRLP4 4
INDIRI4
CNSTI4 47
NEI4 $600
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
INDIRI1
CVII4 1
CNSTI4 47
NEI4 $600
line 1344
;1344:			data += 2;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 2
ADDP4
ASGNP4
ADDRGP4 $603
JUMPV
LABELV $602
line 1345
;1345:			while (*data && *data != '\n') {
line 1346
;1346:				data++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1347
;1347:			}
LABELV $603
line 1345
ADDRLP4 20
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 20
INDIRI4
CNSTI4 0
EQI4 $605
ADDRLP4 20
INDIRI4
CNSTI4 10
NEI4 $602
LABELV $605
line 1348
;1348:		}
ADDRGP4 $601
JUMPV
LABELV $600
line 1350
;1349:		// skip /* */ comments
;1350:		else if ( c == '/' && data[1] == '*' ) {
ADDRLP4 4
INDIRI4
CNSTI4 47
NEI4 $595
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
INDIRI1
CVII4 1
CNSTI4 42
NEI4 $595
line 1351
;1351:			data += 2;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 2
ADDP4
ASGNP4
ADDRGP4 $609
JUMPV
LABELV $608
line 1352
;1352:			while ( *data && ( *data != '*' || data[1] != '/' ) ) {
line 1353
;1353:				if ( *data == '\n' ) {
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 10
NEI4 $611
line 1354
;1354:					com_lines++;
ADDRLP4 20
ADDRGP4 com_lines
ASGNP4
ADDRLP4 20
INDIRP4
ADDRLP4 20
INDIRP4
INDIRU4
CNSTU4 1
ADDU4
ASGNU4
line 1355
;1355:				}
LABELV $611
line 1356
;1356:				data++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1357
;1357:			}
LABELV $609
line 1352
ADDRLP4 24
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 24
INDIRI4
CNSTI4 0
EQI4 $613
ADDRLP4 24
INDIRI4
CNSTI4 42
NEI4 $608
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
INDIRI1
CVII4 1
CNSTI4 47
NEI4 $608
LABELV $613
line 1358
;1358:			if ( *data ) {
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
EQI4 $607
line 1359
;1359:				data += 2;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 2
ADDP4
ASGNP4
line 1360
;1360:			}
line 1361
;1361:		}
line 1362
;1362:		else {
line 1363
;1363:			break;
LABELV $607
LABELV $601
line 1365
;1364:		}
;1365:	}
LABELV $594
line 1328
ADDRGP4 $593
JUMPV
LABELV $595
line 1368
;1366:
;1367:	// token starts on this line
;1368:	com_tokenline = com_lines;
ADDRGP4 com_tokenline
ADDRGP4 com_lines
INDIRU4
ASGNU4
line 1371
;1369:
;1370:	// handle quoted strings
;1371:	if ( c == '"' )
ADDRLP4 4
INDIRI4
CNSTI4 34
NEI4 $616
line 1372
;1372:	{
line 1373
;1373:		data++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRGP4 $619
JUMPV
LABELV $618
line 1375
;1374:		while ( 1 )
;1375:		{
line 1376
;1376:			c = *data;
ADDRLP4 4
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
line 1377
;1377:			if ( c == '"' || c == '\0' )
ADDRLP4 4
INDIRI4
CNSTI4 34
EQI4 $623
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $621
LABELV $623
line 1378
;1378:			{
line 1379
;1379:				if ( c == '"' )
ADDRLP4 4
INDIRI4
CNSTI4 34
NEI4 $624
line 1380
;1380:					data++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
LABELV $624
line 1381
;1381:				com_token[ len ] = '\0';
ADDRLP4 8
INDIRI4
ADDRGP4 com_token
ADDP4
CNSTI1 0
ASGNI1
line 1382
;1382:				*data_p = data;
ADDRFP4 0
INDIRP4
ADDRLP4 0
INDIRP4
ASGNP4
line 1383
;1383:				return com_token;
ADDRGP4 com_token
RETP4
ADDRGP4 $590
JUMPV
LABELV $621
line 1385
;1384:			}
;1385:			data++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1386
;1386:			if ( c == '\n' )
ADDRLP4 4
INDIRI4
CNSTI4 10
NEI4 $626
line 1387
;1387:			{
line 1388
;1388:				com_lines++;
ADDRLP4 20
ADDRGP4 com_lines
ASGNP4
ADDRLP4 20
INDIRP4
ADDRLP4 20
INDIRP4
INDIRU4
CNSTU4 1
ADDU4
ASGNU4
line 1389
;1389:			}
LABELV $626
line 1390
;1390:			if ( len < arraylen( com_token )-1 )
ADDRLP4 8
INDIRI4
CVIU4 4
CNSTU4 1023
GEU4 $628
line 1391
;1391:			{
line 1392
;1392:				com_token[ len ] = c;
ADDRLP4 8
INDIRI4
ADDRGP4 com_token
ADDP4
ADDRLP4 4
INDIRI4
CVII1 4
ASGNI1
line 1393
;1393:				len++;
ADDRLP4 8
ADDRLP4 8
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
line 1394
;1394:			}
LABELV $628
line 1395
;1395:		}
LABELV $619
line 1374
ADDRGP4 $618
JUMPV
line 1396
;1396:	}
LABELV $616
LABELV $630
line 1400
;1397:
;1398:	// parse a regular word
;1399:	do
;1400:	{
line 1401
;1401:		if ( len < arraylen( com_token )-1 )
ADDRLP4 8
INDIRI4
CVIU4 4
CNSTU4 1023
GEU4 $633
line 1402
;1402:		{
line 1403
;1403:			com_token[ len ] = c;
ADDRLP4 8
INDIRI4
ADDRGP4 com_token
ADDP4
ADDRLP4 4
INDIRI4
CVII1 4
ASGNI1
line 1404
;1404:			len++;
ADDRLP4 8
ADDRLP4 8
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
line 1405
;1405:		}
LABELV $633
line 1406
;1406:		data++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1407
;1407:		c = *data;
ADDRLP4 4
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
line 1408
;1408:	} while ( c > ' ' );
LABELV $631
ADDRLP4 4
INDIRI4
CNSTI4 32
GTI4 $630
line 1410
;1409:
;1410:	com_token[ len ] = '\0';
ADDRLP4 8
INDIRI4
ADDRGP4 com_token
ADDP4
CNSTI1 0
ASGNI1
line 1412
;1411:
;1412:	*data_p = data;
ADDRFP4 0
INDIRP4
ADDRLP4 0
INDIRP4
ASGNP4
line 1413
;1413:	return com_token;
ADDRGP4 com_token
RETP4
LABELV $590
endproc COM_ParseExt 28 8
lit
align 1
LABELV $636
byte 1 1
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 1
byte 1 1
byte 1 0
byte 1 0
byte 1 1
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 1
byte 1 1
byte 1 1
byte 1 1
byte 1 1
byte 1 1
byte 1 1
byte 1 1
byte 1 1
byte 1 1
byte 1 1
byte 1 1
byte 1 1
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 1
byte 1 1
byte 1 1
byte 1 1
byte 1 1
byte 1 1
byte 1 1
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 1
byte 1 0
byte 1 1
byte 1 1
byte 1 0
byte 1 1
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 1
byte 1 1
byte 1 1
byte 1 1
byte 1 1
skip 128
export COM_ParseComplex
code
proc COM_ParseComplex 156 0
line 1423
;1414:}
;1415:	
;1416:
;1417:/*
;1418:==============
;1419:COM_ParseComplex
;1420:==============
;1421:*/
;1422:char *COM_ParseComplex( const char **data_p, qboolean allowLineBreaks )
;1423:{
line 1447
;1424:	static const byte is_separator[ 256 ] =
;1425:	{
;1426:	// \0 . . . . . . .\b\t\n . .\r . .
;1427:		1,0,0,0,0,0,0,0,0,1,1,0,0,1,0,0,
;1428:	//  . . . . . . . . . . . . . . . .
;1429:		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
;1430:	//    ! " # $ % & ' ( ) * + , - . /
;1431:		1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0, // excl. '-' '.' '/'
;1432:	//  0 1 2 3 4 5 6 7 8 9 : ; < = > ?
;1433:		0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,
;1434:	//  @ A B C D E F G H I J K L M N O
;1435:		1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
;1436:	//  P Q R S T U V W X Y Z [ \ ] ^ _
;1437:		0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0, // excl. '\\' '_'
;1438:	//  ` a b c d e f g h i j k l m n o
;1439:		1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
;1440:	//  p q r s t u v w x y z { | } ~ 
;1441:		0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1
;1442:	};
;1443:
;1444:	int c, len, shift;
;1445:	const byte *str;
;1446:
;1447:	str = (byte*)*data_p;
ADDRLP4 0
ADDRFP4 0
INDIRP4
INDIRP4
ASGNP4
line 1448
;1448:	len = 0; 
ADDRLP4 8
CNSTI4 0
ASGNI4
line 1449
;1449:	shift = 0; // token line shift relative to com_lines
ADDRLP4 12
CNSTI4 0
ASGNI4
line 1450
;1450:	com_tokentype = TK_GENEGIC;
ADDRGP4 com_tokentype
CNSTI4 0
ASGNI4
LABELV $637
line 1453
;1451:	
;1452:__reswitch:
;1453:	switch ( *str )
ADDRLP4 16
ADDRLP4 0
INDIRP4
INDIRU1
CVUI4 1
ASGNI4
ADDRLP4 16
INDIRI4
CNSTI4 32
LTI4 $711
ADDRLP4 16
INDIRI4
CNSTI4 63
GTI4 $712
ADDRLP4 16
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 $713-128
ADDP4
INDIRP4
JUMPV
data
align 4
LABELV $713
address $642
address $688
address $672
address $638
address $638
address $684
address $703
address $638
address $686
address $687
address $685
address $684
address $684
address $638
address $638
address $651
address $638
address $638
address $638
address $638
address $638
address $638
address $638
address $638
address $638
address $638
address $684
address $684
address $697
address $691
address $694
address $684
code
LABELV $711
ADDRLP4 16
INDIRI4
CNSTI4 0
EQI4 $641
ADDRLP4 16
INDIRI4
CNSTI4 0
LTI4 $638
LABELV $715
ADDRLP4 16
INDIRI4
CNSTI4 9
EQI4 $642
ADDRLP4 16
INDIRI4
CNSTI4 10
EQI4 $646
ADDRLP4 16
INDIRI4
CNSTI4 13
EQI4 $646
ADDRGP4 $638
JUMPV
LABELV $712
ADDRLP4 16
INDIRI4
CNSTI4 91
LTI4 $638
ADDRLP4 16
INDIRI4
CNSTI4 96
GTI4 $716
ADDRLP4 16
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 $717-364
ADDP4
INDIRP4
JUMPV
data
align 4
LABELV $717
address $684
address $638
address $684
address $684
address $638
address $684
code
LABELV $716
ADDRLP4 16
INDIRI4
CNSTI4 123
LTI4 $638
ADDRLP4 16
INDIRI4
CNSTI4 126
GTI4 $638
ADDRLP4 16
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 $719-492
ADDP4
INDIRP4
JUMPV
data
align 4
LABELV $719
address $684
address $700
address $684
address $684
code
line 1454
;1454:	{
LABELV $641
line 1456
;1455:	case '\0':
;1456:		com_tokentype = TK_EOF;
ADDRGP4 com_tokentype
CNSTI4 15
ASGNI4
line 1457
;1457:		break;
ADDRGP4 $639
JUMPV
LABELV $642
line 1462
;1458:
;1459:	// whitespace
;1460:	case ' ':
;1461:	case '\t':
;1462:		str++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRGP4 $644
JUMPV
LABELV $643
line 1464
;1463:		while ( (c = *str) == ' ' || c == '\t' )
;1464:			str++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
LABELV $644
line 1463
ADDRLP4 40
ADDRLP4 0
INDIRP4
INDIRU1
CVUI4 1
ASGNI4
ADDRLP4 4
ADDRLP4 40
INDIRI4
ASGNI4
ADDRLP4 40
INDIRI4
CNSTI4 32
EQI4 $643
ADDRLP4 4
INDIRI4
CNSTI4 9
EQI4 $643
line 1465
;1465:		goto __reswitch;
ADDRGP4 $637
JUMPV
LABELV $646
line 1470
;1466:
;1467:	// newlines
;1468:	case '\n':
;1469:	case '\r':
;1470:	com_lines++;
ADDRLP4 44
ADDRGP4 com_lines
ASGNP4
ADDRLP4 44
INDIRP4
ADDRLP4 44
INDIRP4
INDIRU4
CNSTU4 1
ADDU4
ASGNU4
line 1471
;1471:		if ( *str == '\r' && str[1] == '\n' )
ADDRLP4 0
INDIRP4
INDIRU1
CVUI4 1
CNSTI4 13
NEI4 $647
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
INDIRU1
CVUI4 1
CNSTI4 10
NEI4 $647
line 1472
;1472:			str += 2; // CR+LF
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 2
ADDP4
ASGNP4
ADDRGP4 $648
JUMPV
LABELV $647
line 1474
;1473:		else
;1474:			str++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
LABELV $648
line 1475
;1475:		if ( !allowLineBreaks ) {
ADDRFP4 4
INDIRI4
CNSTI4 0
NEI4 $637
line 1476
;1476:			com_tokentype = TK_NEWLINE;
ADDRGP4 com_tokentype
CNSTI4 14
ASGNI4
line 1477
;1477:			break;
ADDRGP4 $639
JUMPV
line 1479
;1478:		}
;1479:		goto __reswitch;
LABELV $651
line 1484
;1480:
;1481:	// comments, single slash
;1482:	case '/':
;1483:		// until end of line
;1484:		if ( str[1] == '/' ) {
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
INDIRU1
CVUI4 1
CNSTI4 47
NEI4 $652
line 1485
;1485:			str += 2;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 2
ADDP4
ASGNP4
ADDRGP4 $655
JUMPV
LABELV $654
line 1487
;1486:			while ( (c = *str) != '\0' && c != '\n' && c != '\r' )
;1487:				str++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
LABELV $655
line 1486
ADDRLP4 52
ADDRLP4 0
INDIRP4
INDIRU1
CVUI4 1
ASGNI4
ADDRLP4 4
ADDRLP4 52
INDIRI4
ASGNI4
ADDRLP4 52
INDIRI4
CNSTI4 0
EQI4 $658
ADDRLP4 4
INDIRI4
CNSTI4 10
EQI4 $658
ADDRLP4 4
INDIRI4
CNSTI4 13
NEI4 $654
LABELV $658
line 1488
;1488:			goto __reswitch;
ADDRGP4 $637
JUMPV
LABELV $652
line 1492
;1489:		}
;1490:
;1491:		// comment
;1492:		if ( str[1] == '*' ) {
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
INDIRU1
CVUI4 1
CNSTI4 42
NEI4 $659
line 1493
;1493:			str += 2;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 2
ADDP4
ASGNP4
ADDRGP4 $662
JUMPV
LABELV $661
line 1494
;1494:			while ( (c = *str) != '\0' && ( c != '*' || str[1] != '/' ) ) {
line 1495
;1495:				if ( c == '\n' || c == '\r' ) {
ADDRLP4 4
INDIRI4
CNSTI4 10
EQI4 $666
ADDRLP4 4
INDIRI4
CNSTI4 13
NEI4 $664
LABELV $666
line 1496
;1496:					com_lines++;
ADDRLP4 56
ADDRGP4 com_lines
ASGNP4
ADDRLP4 56
INDIRP4
ADDRLP4 56
INDIRP4
INDIRU4
CNSTU4 1
ADDU4
ASGNU4
line 1497
;1497:					if ( c == '\r' && str[1] == '\n' ) // CR+LF?
ADDRLP4 4
INDIRI4
CNSTI4 13
NEI4 $667
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
INDIRU1
CVUI4 1
CNSTI4 10
NEI4 $667
line 1498
;1498:						str++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
LABELV $667
line 1499
;1499:				}
LABELV $664
line 1500
;1500:				str++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1501
;1501:			}
LABELV $662
line 1494
ADDRLP4 56
ADDRLP4 0
INDIRP4
INDIRU1
CVUI4 1
ASGNI4
ADDRLP4 4
ADDRLP4 56
INDIRI4
ASGNI4
ADDRLP4 56
INDIRI4
CNSTI4 0
EQI4 $669
ADDRLP4 4
INDIRI4
CNSTI4 42
NEI4 $661
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
INDIRU1
CVUI4 1
CNSTI4 47
NEI4 $661
LABELV $669
line 1502
;1502:			if ( c != '\0' && str[1] != '\0' ) {
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $637
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
INDIRU1
CVUI4 1
CNSTI4 0
EQI4 $637
line 1503
;1503:				str += 2;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 2
ADDP4
ASGNP4
line 1504
;1504:			} else {
line 1506
;1505:				// FIXME: unterminated comment?
;1506:			}
line 1507
;1507:			goto __reswitch;
ADDRGP4 $637
JUMPV
LABELV $659
line 1511
;1508:		}
;1509:
;1510:		// single slash
;1511:		com_token[ len++ ] = *str++;
ADDRLP4 52
ADDRLP4 8
INDIRI4
ASGNI4
ADDRLP4 8
ADDRLP4 52
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 56
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 56
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 52
INDIRI4
ADDRGP4 com_token
ADDP4
ADDRLP4 56
INDIRP4
INDIRU1
CVUI4 1
CVII1 4
ASGNI1
line 1512
;1512:		break;
ADDRGP4 $639
JUMPV
LABELV $672
line 1516
;1513:	
;1514:	// quoted string?
;1515:	case '"':
;1516:		str++; // skip leading '"'
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRGP4 $674
JUMPV
LABELV $673
line 1518
;1517:		//com_tokenline = com_lines;
;1518:		while ( (c = *str) != '\0' && c != '"' ) {
line 1519
;1519:			if ( c == '\n' || c == '\r' ) {
ADDRLP4 4
INDIRI4
CNSTI4 10
EQI4 $678
ADDRLP4 4
INDIRI4
CNSTI4 13
NEI4 $676
LABELV $678
line 1520
;1520:				com_lines++; // FIXME: unterminated quoted string?
ADDRLP4 64
ADDRGP4 com_lines
ASGNP4
ADDRLP4 64
INDIRP4
ADDRLP4 64
INDIRP4
INDIRU4
CNSTU4 1
ADDU4
ASGNU4
line 1521
;1521:				shift++;
ADDRLP4 12
ADDRLP4 12
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
line 1522
;1522:			}
LABELV $676
line 1523
;1523:			if ( len < MAX_TOKEN_CHARS-1 ) // overflow check
ADDRLP4 8
INDIRI4
CNSTI4 1023
GEI4 $679
line 1524
;1524:				com_token[ len++ ] = c;
ADDRLP4 64
ADDRLP4 8
INDIRI4
ASGNI4
ADDRLP4 8
ADDRLP4 64
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 64
INDIRI4
ADDRGP4 com_token
ADDP4
ADDRLP4 4
INDIRI4
CVII1 4
ASGNI1
LABELV $679
line 1525
;1525:			str++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1526
;1526:		}
LABELV $674
line 1518
ADDRLP4 60
ADDRLP4 0
INDIRP4
INDIRU1
CVUI4 1
ASGNI4
ADDRLP4 4
ADDRLP4 60
INDIRI4
ASGNI4
ADDRLP4 60
INDIRI4
CNSTI4 0
EQI4 $681
ADDRLP4 4
INDIRI4
CNSTI4 34
NEI4 $673
LABELV $681
line 1527
;1527:		if ( c != '\0' ) {
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $682
line 1528
;1528:			str++; // skip ending '"'
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1529
;1529:		} else {
LABELV $682
line 1531
;1530:			// FIXME: unterminated quoted string?
;1531:		}
LABELV $683
line 1532
;1532:		com_tokentype = TK_QUOTED;
ADDRGP4 com_tokentype
CNSTI4 2
ASGNI4
line 1533
;1533:		break;
ADDRGP4 $639
JUMPV
LABELV $684
line 1543
;1534:
;1535:	// single tokens:
;1536:	case '+': case '`':
;1537:	/*case '*':*/ case '~':
;1538:	case '{': case '}':
;1539:	case '[': case ']':
;1540:	case '?': case ',':
;1541:	case ':': case ';':
;1542:	case '%': case '^':
;1543:		com_token[ len++ ] = *str++;
ADDRLP4 64
ADDRLP4 8
INDIRI4
ASGNI4
ADDRLP4 8
ADDRLP4 64
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 68
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 68
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 64
INDIRI4
ADDRGP4 com_token
ADDP4
ADDRLP4 68
INDIRP4
INDIRU1
CVUI4 1
CVII1 4
ASGNI1
line 1544
;1544:		break;
ADDRGP4 $639
JUMPV
LABELV $685
line 1547
;1545:
;1546:	case '*':
;1547:		com_token[ len++ ] = *str++;
ADDRLP4 72
ADDRLP4 8
INDIRI4
ASGNI4
ADDRLP4 8
ADDRLP4 72
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 76
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 76
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 72
INDIRI4
ADDRGP4 com_token
ADDP4
ADDRLP4 76
INDIRP4
INDIRU1
CVUI4 1
CVII1 4
ASGNI1
line 1548
;1548:		com_tokentype = TK_MATCH;
ADDRGP4 com_tokentype
CNSTI4 9
ASGNI4
line 1549
;1549:		break;
ADDRGP4 $639
JUMPV
LABELV $686
line 1552
;1550:
;1551:	case '(':
;1552:		com_token[ len++ ] = *str++;
ADDRLP4 80
ADDRLP4 8
INDIRI4
ASGNI4
ADDRLP4 8
ADDRLP4 80
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 84
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 84
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 80
INDIRI4
ADDRGP4 com_token
ADDP4
ADDRLP4 84
INDIRP4
INDIRU1
CVUI4 1
CVII1 4
ASGNI1
line 1553
;1553:		com_tokentype = TK_SCOPE_OPEN;
ADDRGP4 com_tokentype
CNSTI4 12
ASGNI4
line 1554
;1554:		break;
ADDRGP4 $639
JUMPV
LABELV $687
line 1557
;1555:
;1556:	case ')':
;1557:		com_token[ len++ ] = *str++;
ADDRLP4 88
ADDRLP4 8
INDIRI4
ASGNI4
ADDRLP4 8
ADDRLP4 88
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 92
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 92
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 88
INDIRI4
ADDRGP4 com_token
ADDP4
ADDRLP4 92
INDIRP4
INDIRU1
CVUI4 1
CVII1 4
ASGNI1
line 1558
;1558:		com_tokentype = TK_SCOPE_CLOSE;
ADDRGP4 com_tokentype
CNSTI4 13
ASGNI4
line 1559
;1559:		break;
ADDRGP4 $639
JUMPV
LABELV $688
line 1563
;1560:
;1561:	// !, !=
;1562:	case '!':
;1563:		com_token[ len++ ] = *str++;
ADDRLP4 96
ADDRLP4 8
INDIRI4
ASGNI4
ADDRLP4 8
ADDRLP4 96
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 100
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 100
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 96
INDIRI4
ADDRGP4 com_token
ADDP4
ADDRLP4 100
INDIRP4
INDIRU1
CVUI4 1
CVII1 4
ASGNI1
line 1564
;1564:		if ( *str == '=' ) {
ADDRLP4 0
INDIRP4
INDIRU1
CVUI4 1
CNSTI4 61
NEI4 $639
line 1565
;1565:			com_token[ len++ ] = *str++;
ADDRLP4 104
ADDRLP4 8
INDIRI4
ASGNI4
ADDRLP4 8
ADDRLP4 104
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 108
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 108
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 104
INDIRI4
ADDRGP4 com_token
ADDP4
ADDRLP4 108
INDIRP4
INDIRU1
CVUI4 1
CVII1 4
ASGNI1
line 1566
;1566:			com_tokentype = TK_NEQ;
ADDRGP4 com_tokentype
CNSTI4 4
ASGNI4
line 1567
;1567:		}
line 1568
;1568:		break;
ADDRGP4 $639
JUMPV
LABELV $691
line 1572
;1569:
;1570:	// =, ==
;1571:	case '=':
;1572:		com_token[ len++ ] = *str++;
ADDRLP4 104
ADDRLP4 8
INDIRI4
ASGNI4
ADDRLP4 8
ADDRLP4 104
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 108
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 108
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 104
INDIRI4
ADDRGP4 com_token
ADDP4
ADDRLP4 108
INDIRP4
INDIRU1
CVUI4 1
CVII1 4
ASGNI1
line 1573
;1573:		if ( *str == '=' ) {
ADDRLP4 0
INDIRP4
INDIRU1
CVUI4 1
CNSTI4 61
NEI4 $639
line 1574
;1574:			com_token[ len++ ] = *str++;
ADDRLP4 112
ADDRLP4 8
INDIRI4
ASGNI4
ADDRLP4 8
ADDRLP4 112
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 116
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 116
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 112
INDIRI4
ADDRGP4 com_token
ADDP4
ADDRLP4 116
INDIRP4
INDIRU1
CVUI4 1
CVII1 4
ASGNI1
line 1575
;1575:			com_tokentype = TK_EQ;
ADDRGP4 com_tokentype
CNSTI4 3
ASGNI4
line 1576
;1576:		}
line 1577
;1577:		break;
ADDRGP4 $639
JUMPV
LABELV $694
line 1581
;1578:
;1579:	// >, >=
;1580:	case '>':
;1581:		com_token[ len++ ] = *str++;
ADDRLP4 112
ADDRLP4 8
INDIRI4
ASGNI4
ADDRLP4 8
ADDRLP4 112
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 116
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 116
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 112
INDIRI4
ADDRGP4 com_token
ADDP4
ADDRLP4 116
INDIRP4
INDIRU1
CVUI4 1
CVII1 4
ASGNI1
line 1582
;1582:		if ( *str == '=' ) {
ADDRLP4 0
INDIRP4
INDIRU1
CVUI4 1
CNSTI4 61
NEI4 $695
line 1583
;1583:			com_token[ len++ ] = *str++;
ADDRLP4 120
ADDRLP4 8
INDIRI4
ASGNI4
ADDRLP4 8
ADDRLP4 120
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 124
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 124
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 120
INDIRI4
ADDRGP4 com_token
ADDP4
ADDRLP4 124
INDIRP4
INDIRU1
CVUI4 1
CVII1 4
ASGNI1
line 1584
;1584:			com_tokentype = TK_GTE;
ADDRGP4 com_tokentype
CNSTI4 6
ASGNI4
line 1585
;1585:		} else {
ADDRGP4 $639
JUMPV
LABELV $695
line 1586
;1586:			com_tokentype = TK_GT;
ADDRGP4 com_tokentype
CNSTI4 5
ASGNI4
line 1587
;1587:		}
line 1588
;1588:		break;
ADDRGP4 $639
JUMPV
LABELV $697
line 1592
;1589:
;1590:	//  <, <=
;1591:	case '<':
;1592:		com_token[ len++ ] = *str++;
ADDRLP4 120
ADDRLP4 8
INDIRI4
ASGNI4
ADDRLP4 8
ADDRLP4 120
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 124
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 124
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 120
INDIRI4
ADDRGP4 com_token
ADDP4
ADDRLP4 124
INDIRP4
INDIRU1
CVUI4 1
CVII1 4
ASGNI1
line 1593
;1593:		if ( *str == '=' ) {
ADDRLP4 0
INDIRP4
INDIRU1
CVUI4 1
CNSTI4 61
NEI4 $698
line 1594
;1594:			com_token[ len++ ] = *str++;
ADDRLP4 128
ADDRLP4 8
INDIRI4
ASGNI4
ADDRLP4 8
ADDRLP4 128
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 132
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 132
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 128
INDIRI4
ADDRGP4 com_token
ADDP4
ADDRLP4 132
INDIRP4
INDIRU1
CVUI4 1
CVII1 4
ASGNI1
line 1595
;1595:			com_tokentype = TK_LTE;
ADDRGP4 com_tokentype
CNSTI4 8
ASGNI4
line 1596
;1596:		} else {
ADDRGP4 $639
JUMPV
LABELV $698
line 1597
;1597:			com_tokentype = TK_LT;
ADDRGP4 com_tokentype
CNSTI4 7
ASGNI4
line 1598
;1598:		}
line 1599
;1599:		break;
ADDRGP4 $639
JUMPV
LABELV $700
line 1603
;1600:
;1601:	// |, ||
;1602:	case '|':
;1603:		com_token[ len++ ] = *str++;
ADDRLP4 128
ADDRLP4 8
INDIRI4
ASGNI4
ADDRLP4 8
ADDRLP4 128
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 132
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 132
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 128
INDIRI4
ADDRGP4 com_token
ADDP4
ADDRLP4 132
INDIRP4
INDIRU1
CVUI4 1
CVII1 4
ASGNI1
line 1604
;1604:		if ( *str == '|' ) {
ADDRLP4 0
INDIRP4
INDIRU1
CVUI4 1
CNSTI4 124
NEI4 $639
line 1605
;1605:			com_token[ len++ ] = *str++;
ADDRLP4 136
ADDRLP4 8
INDIRI4
ASGNI4
ADDRLP4 8
ADDRLP4 136
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 140
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 140
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 136
INDIRI4
ADDRGP4 com_token
ADDP4
ADDRLP4 140
INDIRP4
INDIRU1
CVUI4 1
CVII1 4
ASGNI1
line 1606
;1606:			com_tokentype = TK_OR;
ADDRGP4 com_tokentype
CNSTI4 10
ASGNI4
line 1607
;1607:		}
line 1608
;1608:		break;
ADDRGP4 $639
JUMPV
LABELV $703
line 1612
;1609:
;1610:	// &, &&
;1611:	case '&':
;1612:		com_token[ len++ ] = *str++;
ADDRLP4 136
ADDRLP4 8
INDIRI4
ASGNI4
ADDRLP4 8
ADDRLP4 136
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 140
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 140
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 136
INDIRI4
ADDRGP4 com_token
ADDP4
ADDRLP4 140
INDIRP4
INDIRU1
CVUI4 1
CVII1 4
ASGNI1
line 1613
;1613:		if ( *str == '&' ) {
ADDRLP4 0
INDIRP4
INDIRU1
CVUI4 1
CNSTI4 38
NEI4 $639
line 1614
;1614:			com_token[ len++ ] = *str++;
ADDRLP4 144
ADDRLP4 8
INDIRI4
ASGNI4
ADDRLP4 8
ADDRLP4 144
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 148
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 148
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 144
INDIRI4
ADDRGP4 com_token
ADDP4
ADDRLP4 148
INDIRP4
INDIRU1
CVUI4 1
CVII1 4
ASGNI1
line 1615
;1615:			com_tokentype = TK_AND;
ADDRGP4 com_tokentype
CNSTI4 11
ASGNI4
line 1616
;1616:		}
line 1617
;1617:		break;
ADDRGP4 $639
JUMPV
LABELV $638
line 1621
;1618:
;1619:	// rest of the charset
;1620:	default:
;1621:		com_token[ len++ ] = *str++;
ADDRLP4 144
ADDRLP4 8
INDIRI4
ASGNI4
ADDRLP4 8
ADDRLP4 144
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 148
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 148
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 144
INDIRI4
ADDRGP4 com_token
ADDP4
ADDRLP4 148
INDIRP4
INDIRU1
CVUI4 1
CVII1 4
ASGNI1
ADDRGP4 $707
JUMPV
LABELV $706
line 1622
;1622:		while ( !is_separator[ (c = *str) ] ) {
line 1623
;1623:			if ( len < MAX_TOKEN_CHARS-1 )
ADDRLP4 8
INDIRI4
CNSTI4 1023
GEI4 $709
line 1624
;1624:				com_token[ len++ ] = c;
ADDRLP4 152
ADDRLP4 8
INDIRI4
ASGNI4
ADDRLP4 8
ADDRLP4 152
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 152
INDIRI4
ADDRGP4 com_token
ADDP4
ADDRLP4 4
INDIRI4
CVII1 4
ASGNI1
LABELV $709
line 1625
;1625:			str++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1626
;1626:		}
LABELV $707
line 1622
ADDRLP4 152
ADDRLP4 0
INDIRP4
INDIRU1
CVUI4 1
ASGNI4
ADDRLP4 4
ADDRLP4 152
INDIRI4
ASGNI4
ADDRLP4 152
INDIRI4
ADDRGP4 $636
ADDP4
INDIRU1
CVUI4 1
CNSTI4 0
EQI4 $706
line 1627
;1627:		com_tokentype = TK_STRING;
ADDRGP4 com_tokentype
CNSTI4 1
ASGNI4
line 1628
;1628:		break;
LABELV $639
line 1632
;1629:
;1630:	} // switch ( *str )
;1631:
;1632:	com_tokenline = com_lines - shift;
ADDRGP4 com_tokenline
ADDRGP4 com_lines
INDIRU4
ADDRLP4 12
INDIRI4
CVIU4 4
SUBU4
ASGNU4
line 1633
;1633:	com_token[ len ] = '\0';
ADDRLP4 8
INDIRI4
ADDRGP4 com_token
ADDP4
CNSTI1 0
ASGNI1
line 1634
;1634:	*data_p = ( char * )str;
ADDRFP4 0
INDIRP4
ADDRLP4 0
INDIRP4
ASGNP4
line 1635
;1635:	return com_token;
ADDRGP4 com_token
RETP4
LABELV $635
endproc COM_ParseComplex 156 0
export COM_MatchToken
proc COM_MatchToken 12 16
line 1644
;1636:}
;1637:
;1638:
;1639:/*
;1640:==================
;1641:COM_MatchToken
;1642:==================
;1643:*/
;1644:void COM_MatchToken( const char **buf_p, const char *match ) {
line 1647
;1645:	const char *token;
;1646:
;1647:	token = COM_Parse( buf_p );
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 4
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 4
INDIRP4
ASGNP4
line 1648
;1648:	if ( strcmp( token, match ) ) {
ADDRLP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 8
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 0
EQI4 $722
line 1649
;1649:		N_Error( ERR_DROP, "MatchToken: %s != %s", token, match );
CNSTI4 1
ARGI4
ADDRGP4 $724
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRGP4 N_Error
CALLV
pop
line 1650
;1650:	}
LABELV $722
line 1651
;1651:}
LABELV $721
endproc COM_MatchToken 12 16
export SkipBracedSection
proc SkipBracedSection 8 8
line 1663
;1652:
;1653:
;1654:/*
;1655:=================
;1656:SkipBracedSection
;1657:
;1658:The next token should be an open brace or set depth to 1 if already parsed it.
;1659:Skips until a matching close brace is found.
;1660:Internal brace depths are properly skipped.
;1661:=================
;1662:*/
;1663:qboolean SkipBracedSection( const char **program, int depth ) {
LABELV $726
line 1666
;1664:	const char			*token;
;1665:
;1666:	do {
line 1667
;1667:		token = COM_ParseExt( program, qtrue );
ADDRFP4 0
INDIRP4
ARGP4
CNSTI4 1
ARGI4
ADDRLP4 4
ADDRGP4 COM_ParseExt
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 4
INDIRP4
ASGNP4
line 1668
;1668:		if( token[1] == 0 ) {
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $729
line 1669
;1669:			if( token[0] == '{' ) {
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 123
NEI4 $731
line 1670
;1670:				depth++;
ADDRFP4 4
ADDRFP4 4
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
line 1671
;1671:			}
ADDRGP4 $732
JUMPV
LABELV $731
line 1672
;1672:			else if( token[0] == '}' ) {
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 125
NEI4 $733
line 1673
;1673:				depth--;
ADDRFP4 4
ADDRFP4 4
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
line 1674
;1674:			}
LABELV $733
LABELV $732
line 1675
;1675:		}
LABELV $729
line 1676
;1676:	} while( depth && *program );
LABELV $727
ADDRFP4 4
INDIRI4
CNSTI4 0
EQI4 $735
ADDRFP4 0
INDIRP4
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $726
LABELV $735
line 1678
;1677:
;1678:	return (qboolean)( depth == 0 );
ADDRFP4 4
INDIRI4
CNSTI4 0
NEI4 $737
ADDRLP4 4
CNSTI4 1
ASGNI4
ADDRGP4 $738
JUMPV
LABELV $737
ADDRLP4 4
CNSTI4 0
ASGNI4
LABELV $738
ADDRLP4 4
INDIRI4
RETI4
LABELV $725
endproc SkipBracedSection 8 8
export SkipRestOfLine
proc SkipRestOfLine 12 0
line 1687
;1679:}
;1680:
;1681:
;1682:/*
;1683:=================
;1684:SkipRestOfLine
;1685:=================
;1686:*/
;1687:void SkipRestOfLine( const char **data ) {
line 1691
;1688:	const char *p;
;1689:	int		c;
;1690:
;1691:	p = *data;
ADDRLP4 0
ADDRFP4 0
INDIRP4
INDIRP4
ASGNP4
line 1693
;1692:
;1693:	if ( !*p )
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $743
line 1694
;1694:		return;
ADDRGP4 $739
JUMPV
LABELV $742
line 1696
;1695:
;1696:	while ( (c = *p) != '\0' ) {
line 1697
;1697:		p++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1698
;1698:		if ( c == '\n' ) {
ADDRLP4 4
INDIRI4
CNSTI4 10
NEI4 $745
line 1699
;1699:			com_lines++;
ADDRLP4 8
ADDRGP4 com_lines
ASGNP4
ADDRLP4 8
INDIRP4
ADDRLP4 8
INDIRP4
INDIRU4
CNSTU4 1
ADDU4
ASGNU4
line 1700
;1700:			break;
ADDRGP4 $744
JUMPV
LABELV $745
line 1702
;1701:		}
;1702:	}
LABELV $743
line 1696
ADDRLP4 8
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 4
ADDRLP4 8
INDIRI4
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 0
NEI4 $742
LABELV $744
line 1704
;1703:
;1704:	*data = p;
ADDRFP4 0
INDIRP4
ADDRLP4 0
INDIRP4
ASGNP4
line 1705
;1705:}
LABELV $739
endproc SkipRestOfLine 12 0
export ParseHex
proc ParseHex 20 0
line 1708
;1706:
;1707:int ParseHex(const char *text)
;1708:{
line 1712
;1709:    int value;
;1710:    int c;
;1711:
;1712:    value = 0;
ADDRLP4 4
CNSTI4 0
ASGNI4
ADDRGP4 $749
JUMPV
LABELV $748
line 1713
;1713:    while ((c = *text++) != 0) {
line 1714
;1714:        if (c >= '0' && c <= '9') {
ADDRLP4 0
INDIRI4
CNSTI4 48
LTI4 $751
ADDRLP4 0
INDIRI4
CNSTI4 57
GTI4 $751
line 1715
;1715:            value = value * 16 + c - '0';
ADDRLP4 4
ADDRLP4 4
INDIRI4
CNSTI4 4
LSHI4
ADDRLP4 0
INDIRI4
ADDI4
CNSTI4 48
SUBI4
ASGNI4
line 1716
;1716:            continue;
ADDRGP4 $749
JUMPV
LABELV $751
line 1718
;1717:        }
;1718:        if (c >= 'a' && c <= 'f') {
ADDRLP4 0
INDIRI4
CNSTI4 97
LTI4 $753
ADDRLP4 0
INDIRI4
CNSTI4 102
GTI4 $753
line 1719
;1719:            value = value * 16 + 10 + c - 'a';
ADDRLP4 4
ADDRLP4 4
INDIRI4
CNSTI4 4
LSHI4
CNSTI4 10
ADDI4
ADDRLP4 0
INDIRI4
ADDI4
CNSTI4 97
SUBI4
ASGNI4
line 1720
;1720:            continue;
ADDRGP4 $749
JUMPV
LABELV $753
line 1722
;1721:        }
;1722:        if (c >= 'A' && c <= 'F') {
ADDRLP4 0
INDIRI4
CNSTI4 65
LTI4 $755
ADDRLP4 0
INDIRI4
CNSTI4 70
GTI4 $755
line 1723
;1723:            value = value * 16 + 10 + c - 'A';
ADDRLP4 4
ADDRLP4 4
INDIRI4
CNSTI4 4
LSHI4
CNSTI4 10
ADDI4
ADDRLP4 0
INDIRI4
ADDI4
CNSTI4 65
SUBI4
ASGNI4
line 1724
;1724:            continue;
LABELV $755
line 1726
;1725:        }
;1726:    }
LABELV $749
line 1713
ADDRLP4 8
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 8
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 12
ADDRLP4 8
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 0
ADDRLP4 12
INDIRI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 0
NEI4 $748
line 1728
;1727:
;1728:    return value;
ADDRLP4 4
INDIRI4
RETI4
LABELV $747
endproc ParseHex 20 0
export Parse1DMatrix
proc Parse1DMatrix 16 8
line 1731
;1729:}
;1730:
;1731:void Parse1DMatrix( const char **buf_p, int x, float *m ) {
line 1735
;1732:	const char	*token;
;1733:	int		i;
;1734:
;1735:	COM_MatchToken( buf_p, "(" );
ADDRFP4 0
INDIRP4
ARGP4
ADDRGP4 $758
ARGP4
ADDRGP4 COM_MatchToken
CALLV
pop
line 1737
;1736:
;1737:	for (i = 0 ; i < x; i++) {
ADDRLP4 0
CNSTI4 0
ASGNI4
ADDRGP4 $762
JUMPV
LABELV $759
line 1738
;1738:		token = COM_Parse( buf_p );
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 8
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 4
ADDRLP4 8
INDIRP4
ASGNP4
line 1739
;1739:		m[i] = N_atof( token );
ADDRLP4 4
INDIRP4
ARGP4
ADDRLP4 12
ADDRGP4 N_atof
CALLF4
ASGNF4
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 8
INDIRP4
ADDP4
ADDRLP4 12
INDIRF4
ASGNF4
line 1740
;1740:	}
LABELV $760
line 1737
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $762
ADDRLP4 0
INDIRI4
ADDRFP4 4
INDIRI4
LTI4 $759
line 1742
;1741:
;1742:	COM_MatchToken( buf_p, ")" );
ADDRFP4 0
INDIRP4
ARGP4
ADDRGP4 $763
ARGP4
ADDRGP4 COM_MatchToken
CALLV
pop
line 1743
;1743:}
LABELV $757
endproc Parse1DMatrix 16 8
export Parse2DMatrix
proc Parse2DMatrix 8 12
line 1745
;1744:
;1745:void Parse2DMatrix( const char **buf_p, int y, int x, float *m ) {
line 1748
;1746:	int		i;
;1747:
;1748:	COM_MatchToken( buf_p, "(" );
ADDRFP4 0
INDIRP4
ARGP4
ADDRGP4 $758
ARGP4
ADDRGP4 COM_MatchToken
CALLV
pop
line 1750
;1749:
;1750:	for (i = 0 ; i < y ; i++) {
ADDRLP4 0
CNSTI4 0
ASGNI4
ADDRGP4 $768
JUMPV
LABELV $765
line 1751
;1751:		Parse1DMatrix (buf_p, x, m + i * x);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 4
ADDRFP4 8
INDIRI4
ASGNI4
ADDRLP4 4
INDIRI4
ARGI4
ADDRLP4 0
INDIRI4
ADDRLP4 4
INDIRI4
MULI4
CNSTI4 2
LSHI4
ADDRFP4 12
INDIRP4
ADDP4
ARGP4
ADDRGP4 Parse1DMatrix
CALLV
pop
line 1752
;1752:	}
LABELV $766
line 1750
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $768
ADDRLP4 0
INDIRI4
ADDRFP4 4
INDIRI4
LTI4 $765
line 1754
;1753:
;1754:	COM_MatchToken( buf_p, ")" );
ADDRFP4 0
INDIRP4
ARGP4
ADDRGP4 $763
ARGP4
ADDRGP4 COM_MatchToken
CALLV
pop
line 1755
;1755:}
LABELV $764
endproc Parse2DMatrix 8 12
export Parse3DMatrix
proc Parse3DMatrix 12 16
line 1757
;1756:
;1757:void Parse3DMatrix( const char **buf_p, int z, int y, int x, float *m ) {
line 1760
;1758:	int		i;
;1759:
;1760:	COM_MatchToken( buf_p, "(" );
ADDRFP4 0
INDIRP4
ARGP4
ADDRGP4 $758
ARGP4
ADDRGP4 COM_MatchToken
CALLV
pop
line 1762
;1761:
;1762:	for (i = 0 ; i < z ; i++) {
ADDRLP4 0
CNSTI4 0
ASGNI4
ADDRGP4 $773
JUMPV
LABELV $770
line 1763
;1763:		Parse2DMatrix (buf_p, y, x, m + i * x*y);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 4
ADDRFP4 8
INDIRI4
ASGNI4
ADDRLP4 4
INDIRI4
ARGI4
ADDRLP4 8
ADDRFP4 12
INDIRI4
ASGNI4
ADDRLP4 8
INDIRI4
ARGI4
ADDRLP4 0
INDIRI4
ADDRLP4 8
INDIRI4
MULI4
ADDRLP4 4
INDIRI4
MULI4
CNSTI4 2
LSHI4
ADDRFP4 16
INDIRP4
ADDP4
ARGP4
ADDRGP4 Parse2DMatrix
CALLV
pop
line 1764
;1764:	}
LABELV $771
line 1762
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $773
ADDRLP4 0
INDIRI4
ADDRFP4 4
INDIRI4
LTI4 $770
line 1766
;1765:
;1766:	COM_MatchToken( buf_p, ")" );
ADDRFP4 0
INDIRP4
ARGP4
ADDRGP4 $763
ARGP4
ADDRGP4 COM_MatchToken
CALLV
pop
line 1767
;1767:}
LABELV $769
endproc Parse3DMatrix 12 16
export Hex
proc Hex 12 0
ADDRFP4 0
ADDRFP4 0
INDIRI4
CVII1 4
ASGNI1
line 1770
;1768:
;1769:int Hex( char c )
;1770:{
line 1771
;1771:	if ( c >= '0' && c <= '9' ) {
ADDRLP4 0
ADDRFP4 0
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 48
LTI4 $775
ADDRLP4 0
INDIRI4
CNSTI4 57
GTI4 $775
line 1772
;1772:		return c - '0';
ADDRFP4 0
INDIRI1
CVII4 1
CNSTI4 48
SUBI4
RETI4
ADDRGP4 $774
JUMPV
LABELV $775
line 1775
;1773:	}
;1774:	else
;1775:	if ( c >= 'A' && c <= 'F' ) {
ADDRLP4 4
ADDRFP4 0
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 65
LTI4 $777
ADDRLP4 4
INDIRI4
CNSTI4 70
GTI4 $777
line 1776
;1776:		return 10 + c - 'A';
ADDRFP4 0
INDIRI1
CVII4 1
CNSTI4 10
ADDI4
CNSTI4 65
SUBI4
RETI4
ADDRGP4 $774
JUMPV
LABELV $777
line 1779
;1777:	}
;1778:	else
;1779:	if ( c >= 'a' && c <= 'f' ) {
ADDRLP4 8
ADDRFP4 0
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 97
LTI4 $779
ADDRLP4 8
INDIRI4
CNSTI4 102
GTI4 $779
line 1780
;1780:		return 10 + c - 'a';
ADDRFP4 0
INDIRI1
CVII4 1
CNSTI4 10
ADDI4
CNSTI4 97
SUBI4
RETI4
ADDRGP4 $774
JUMPV
LABELV $779
line 1783
;1781:	}
;1782:
;1783:	return -1;
CNSTI4 -1
RETI4
LABELV $774
endproc Hex 12 0
export Com_HexStrToInt
proc Com_HexStrToInt 28 4
line 1793
;1784:}
;1785:
;1786:
;1787:/*
;1788:===================
;1789:Com_HexStrToInt
;1790:===================
;1791:*/
;1792:int32_t Com_HexStrToInt(const char *str)
;1793:{
line 1794
;1794:	if (!str)
ADDRFP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $782
line 1795
;1795:		return -1;
CNSTI4 -1
RETI4
ADDRGP4 $781
JUMPV
LABELV $782
line 1798
;1796:
;1797:	// check for hex code
;1798:	if (str[ 0 ] == '0' && str[ 1 ] == 'x' && str[ 2 ] != '\0') {
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 48
NEI4 $784
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
INDIRI1
CVII4 1
CNSTI4 120
NEI4 $784
ADDRLP4 0
INDIRP4
CNSTI4 2
ADDP4
INDIRI1
CVII4 1
CNSTI4 0
EQI4 $784
line 1799
;1799:	    int32_t i, digit, n = 0, len = strlen( str );
ADDRLP4 12
CNSTI4 0
ASGNI4
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 20
ADDRGP4 strlen
CALLU4
ASGNU4
ADDRLP4 16
ADDRLP4 20
INDIRU4
CVUI4 4
ASGNI4
line 1801
;1800:
;1801:		for (i = 2; i < len; i++) {
ADDRLP4 4
CNSTI4 2
ASGNI4
ADDRGP4 $789
JUMPV
LABELV $786
line 1802
;1802:			n *= 16;
ADDRLP4 12
ADDRLP4 12
INDIRI4
CNSTI4 4
LSHI4
ASGNI4
line 1804
;1803:
;1804:			digit = Hex( str[ i ] );
ADDRLP4 4
INDIRI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRI1
CVII4 1
ARGI4
ADDRLP4 24
ADDRGP4 Hex
CALLI4
ASGNI4
ADDRLP4 8
ADDRLP4 24
INDIRI4
ASGNI4
line 1806
;1805:
;1806:			if ( digit < 0 )
ADDRLP4 8
INDIRI4
CNSTI4 0
GEI4 $790
line 1807
;1807:				return -1;
CNSTI4 -1
RETI4
ADDRGP4 $781
JUMPV
LABELV $790
line 1809
;1808:
;1809:			n += digit;
ADDRLP4 12
ADDRLP4 12
INDIRI4
ADDRLP4 8
INDIRI4
ADDI4
ASGNI4
line 1810
;1810:		}
LABELV $787
line 1801
ADDRLP4 4
ADDRLP4 4
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $789
ADDRLP4 4
INDIRI4
ADDRLP4 16
INDIRI4
LTI4 $786
line 1812
;1811:
;1812:		return n;
ADDRLP4 12
INDIRI4
RETI4
ADDRGP4 $781
JUMPV
LABELV $784
line 1815
;1813:	}
;1814:
;1815:	return -1;
CNSTI4 -1
RETI4
LABELV $781
endproc Com_HexStrToInt 28 4
export Com_GetHashColor
proc Com_GetHashColor 60 4
line 1819
;1816:}
;1817:
;1818:qboolean Com_GetHashColor(const char *str, byte *color)
;1819:{
line 1822
;1820:	int32_t i, len, hex[6];
;1821:
;1822:	color[0] = color[1] = color[2] = 0;
ADDRLP4 32
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 36
CNSTU1 0
ASGNU1
ADDRLP4 32
INDIRP4
CNSTI4 2
ADDP4
ADDRLP4 36
INDIRU1
ASGNU1
ADDRLP4 32
INDIRP4
CNSTI4 1
ADDP4
ADDRLP4 36
INDIRU1
ASGNU1
ADDRLP4 32
INDIRP4
ADDRLP4 36
INDIRU1
ASGNU1
line 1824
;1823:
;1824:	if ( *str++ != '#' ) {
ADDRLP4 40
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 40
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 40
INDIRP4
INDIRI1
CVII4 1
CNSTI4 35
EQI4 $793
line 1825
;1825:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $792
JUMPV
LABELV $793
line 1828
;1826:	}
;1827:
;1828:	len = (int)strlen( str );
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 44
ADDRGP4 strlen
CALLU4
ASGNU4
ADDRLP4 28
ADDRLP4 44
INDIRU4
CVUI4 4
ASGNI4
line 1829
;1829:	if ( len <= 0 || len > 6 ) {
ADDRLP4 28
INDIRI4
CNSTI4 0
LEI4 $797
ADDRLP4 28
INDIRI4
CNSTI4 6
LEI4 $795
LABELV $797
line 1830
;1830:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $792
JUMPV
LABELV $795
line 1833
;1831:	}
;1832:
;1833:	for ( i = 0; i < len; i++ ) {
ADDRLP4 0
CNSTI4 0
ASGNI4
ADDRGP4 $801
JUMPV
LABELV $798
line 1834
;1834:		hex[i] = Hex( str[i] );
ADDRLP4 0
INDIRI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRI1
CVII4 1
ARGI4
ADDRLP4 56
ADDRGP4 Hex
CALLI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRLP4 4
ADDP4
ADDRLP4 56
INDIRI4
ASGNI4
line 1835
;1835:		if ( hex[i] < 0 ) {
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRLP4 4
ADDP4
INDIRI4
CNSTI4 0
GEI4 $802
line 1836
;1836:			return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $792
JUMPV
LABELV $802
line 1838
;1837:		}
;1838:	}
LABELV $799
line 1833
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $801
ADDRLP4 0
INDIRI4
ADDRLP4 28
INDIRI4
LTI4 $798
line 1840
;1839:
;1840:	switch ( len ) {
ADDRLP4 28
INDIRI4
CNSTI4 3
EQI4 $806
ADDRLP4 28
INDIRI4
CNSTI4 6
EQI4 $811
ADDRGP4 $804
JUMPV
LABELV $806
line 1842
;1841:		case 3: // #rgb
;1842:			color[0] = hex[0] << 4 | hex[0];
ADDRLP4 56
ADDRLP4 4
INDIRI4
ASGNI4
ADDRFP4 4
INDIRP4
ADDRLP4 56
INDIRI4
CNSTI4 4
LSHI4
ADDRLP4 56
INDIRI4
BORI4
CVIU4 4
CVUU1 4
ASGNU1
line 1843
;1843:			color[1] = hex[1] << 4 | hex[1];
ADDRFP4 4
INDIRP4
CNSTI4 1
ADDP4
ADDRLP4 4+4
INDIRI4
CNSTI4 4
LSHI4
ADDRLP4 4+4
INDIRI4
BORI4
CVIU4 4
CVUU1 4
ASGNU1
line 1844
;1844:			color[2] = hex[2] << 4 | hex[2];
ADDRFP4 4
INDIRP4
CNSTI4 2
ADDP4
ADDRLP4 4+8
INDIRI4
CNSTI4 4
LSHI4
ADDRLP4 4+8
INDIRI4
BORI4
CVIU4 4
CVUU1 4
ASGNU1
line 1845
;1845:			break;
ADDRGP4 $805
JUMPV
LABELV $811
line 1847
;1846:		case 6: // #rrggbb
;1847:			color[0] = hex[0] << 4 | hex[1];
ADDRFP4 4
INDIRP4
ADDRLP4 4
INDIRI4
CNSTI4 4
LSHI4
ADDRLP4 4+4
INDIRI4
BORI4
CVIU4 4
CVUU1 4
ASGNU1
line 1848
;1848:			color[1] = hex[2] << 4 | hex[3];
ADDRFP4 4
INDIRP4
CNSTI4 1
ADDP4
ADDRLP4 4+8
INDIRI4
CNSTI4 4
LSHI4
ADDRLP4 4+12
INDIRI4
BORI4
CVIU4 4
CVUU1 4
ASGNU1
line 1849
;1849:			color[2] = hex[4] << 4 | hex[5];
ADDRFP4 4
INDIRP4
CNSTI4 2
ADDP4
ADDRLP4 4+16
INDIRI4
CNSTI4 4
LSHI4
ADDRLP4 4+20
INDIRI4
BORI4
CVIU4 4
CVUU1 4
ASGNU1
line 1850
;1850:			break;
ADDRGP4 $805
JUMPV
LABELV $804
line 1852
;1851:		default: // unsupported format
;1852:			return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $792
JUMPV
LABELV $805
line 1855
;1853:	}
;1854:
;1855:	return qtrue;
CNSTI4 1
RETI4
LABELV $792
endproc Com_GetHashColor 60 4
export Com_PrintStartupBegin
proc Com_PrintStartupBegin 0 24
line 1858
;1856:}
;1857:
;1858:void Com_PrintStartupBegin( const char *func ) {
line 1859
;1859:	Con_Printf( "%*c %s %*c", 10, '-', func, 10, '-' );
ADDRGP4 $818
ARGP4
CNSTI4 10
ARGI4
CNSTI4 45
ARGI4
ADDRFP4 0
INDIRP4
ARGP4
CNSTI4 10
ARGI4
CNSTI4 45
ARGI4
ADDRGP4 Con_Printf
CALLV
pop
line 1860
;1860:}
LABELV $817
endproc Com_PrintStartupBegin 0 24
export Com_PrintStartupEnd
proc Com_PrintStartupEnd 0 12
line 1862
;1861:
;1862:void Com_PrintStartupEnd( void ) {
line 1863
;1863:	Con_Printf( "%*c", 20, '-' );
ADDRGP4 $820
ARGP4
CNSTI4 20
ARGI4
CNSTI4 45
ARGI4
ADDRGP4 Con_Printf
CALLV
pop
line 1864
;1864:}
LABELV $819
endproc Com_PrintStartupEnd 0 12
proc Q_strkey 12 0
line 1875
;1865:
;1866:/*
;1867:=====================================================================
;1868:
;1869:  INFO STRINGS
;1870:
;1871:=====================================================================
;1872:*/
;1873:
;1874:static qboolean Q_strkey( const char *str, const char *key, uint32_t key_len )
;1875:{
line 1878
;1876:	uint32_t i;
;1877:
;1878:	for ( i = 0; i < key_len; i++ )
ADDRLP4 0
CNSTU4 0
ASGNU4
ADDRGP4 $825
JUMPV
LABELV $822
line 1879
;1879:	{
line 1880
;1880:		if ( locase[ (byte)str[i] ] != locase[ (byte)key[i] ] )
ADDRLP4 8
ADDRGP4 locase
ASGNP4
ADDRLP4 0
INDIRU4
ADDRFP4 0
INDIRP4
ADDP4
INDIRI1
CVII4 1
CVIU4 4
CVUU1 4
CVUI4 1
ADDRLP4 8
INDIRP4
ADDP4
INDIRU1
CVUI4 1
ADDRLP4 0
INDIRU4
ADDRFP4 4
INDIRP4
ADDP4
INDIRI1
CVII4 1
CVIU4 4
CVUU1 4
CVUI4 1
ADDRLP4 8
INDIRP4
ADDP4
INDIRU1
CVUI4 1
EQI4 $826
line 1881
;1881:		{
line 1882
;1882:			return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $821
JUMPV
LABELV $826
line 1884
;1883:		}
;1884:	}
LABELV $823
line 1878
ADDRLP4 0
ADDRLP4 0
INDIRU4
CNSTU4 1
ADDU4
ASGNU4
LABELV $825
ADDRLP4 0
INDIRU4
ADDRFP4 8
INDIRU4
LTU4 $822
line 1886
;1885:
;1886:	return qtrue;
CNSTI4 1
RETI4
LABELV $821
endproc Q_strkey 12 0
bss
align 1
LABELV $829
skip 16384
data
align 4
LABELV $830
byte 4 0
export Info_ValueForKey
code
proc Info_ValueForKey 64 12
line 1899
;1887:}
;1888:
;1889:
;1890:/*
;1891:===============
;1892:Info_ValueForKey
;1893:
;1894:Searches the string for the given
;1895:key and returns the associated value, or an empty string.
;1896:===============
;1897:*/
;1898:const char *Info_ValueForKey( const char *s, const char *key )
;1899:{
line 1907
;1900:	static	char value[2][BIG_INFO_VALUE];	// use two buffers so compares
;1901:											// work without stomping on each other
;1902:	static uint32_t valueindex = 0;
;1903:	const char *v, *pkey;
;1904:	char	*o, *o2;
;1905:	uint32_t klen, len;
;1906:	
;1907:	if ( !s || !key || !*key )
ADDRFP4 0
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $834
ADDRLP4 24
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 24
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $834
ADDRLP4 24
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $831
LABELV $834
line 1908
;1908:		return "";
ADDRGP4 $530
RETP4
ADDRGP4 $828
JUMPV
LABELV $831
line 1910
;1909:
;1910:	klen = strlen( key );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 28
ADDRGP4 strlen
CALLU4
ASGNU4
ADDRLP4 12
ADDRLP4 28
INDIRU4
ASGNU4
line 1912
;1911:
;1912:	if ( *s == '\\' )
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 92
NEI4 $838
line 1913
;1913:		s++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRGP4 $838
JUMPV
LABELV $837
line 1916
;1914:
;1915:	while (1)
;1916:	{
line 1917
;1917:		pkey = s;
ADDRLP4 8
ADDRFP4 0
INDIRP4
ASGNP4
ADDRGP4 $841
JUMPV
LABELV $840
line 1919
;1918:		while ( *s != '\\' )
;1919:		{
line 1920
;1920:			if ( *s == '\0' )
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $843
line 1921
;1921:				return "";
ADDRGP4 $530
RETP4
ADDRGP4 $828
JUMPV
LABELV $843
line 1922
;1922:			++s;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1923
;1923:		}
LABELV $841
line 1918
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 92
NEI4 $840
line 1924
;1924:		len = (s - pkey);
ADDRLP4 16
ADDRFP4 0
INDIRP4
CVPU4 4
ADDRLP4 8
INDIRP4
CVPU4 4
SUBU4
CVUI4 4
CVIU4 4
ASGNU4
line 1925
;1925:		s++; // skip '\\'
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1927
;1926:
;1927:		v = s;
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
ADDRGP4 $846
JUMPV
LABELV $845
line 1929
;1928:		while ( *s != '\\' && *s !='\0' )
;1929:			s++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
LABELV $846
line 1928
ADDRLP4 32
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 32
INDIRI4
CNSTI4 92
EQI4 $848
ADDRLP4 32
INDIRI4
CNSTI4 0
NEI4 $845
LABELV $848
line 1931
;1930:
;1931:		if ( len == klen && Q_strkey( pkey, key, klen ) )
ADDRLP4 16
INDIRU4
ADDRLP4 12
INDIRU4
NEU4 $849
ADDRLP4 8
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 12
INDIRU4
ARGU4
ADDRLP4 40
ADDRGP4 Q_strkey
CALLI4
ASGNI4
ADDRLP4 40
INDIRI4
CNSTI4 0
EQI4 $849
line 1932
;1932:		{
line 1933
;1933:			o = o2 = value[ valueindex ^= 1 ];
ADDRLP4 44
ADDRGP4 $830
ASGNP4
ADDRLP4 48
ADDRLP4 44
INDIRP4
INDIRU4
CNSTU4 1
BXORU4
ASGNU4
ADDRLP4 44
INDIRP4
ADDRLP4 48
INDIRU4
ASGNU4
ADDRLP4 52
ADDRLP4 48
INDIRU4
CNSTI4 13
LSHU4
ADDRGP4 $829
ADDP4
ASGNP4
ADDRLP4 20
ADDRLP4 52
INDIRP4
ASGNP4
ADDRLP4 4
ADDRLP4 52
INDIRP4
ASGNP4
line 1934
;1934:			if ( (s - v) >= BIG_INFO_VALUE )
ADDRFP4 0
INDIRP4
CVPU4 4
ADDRLP4 0
INDIRP4
CVPU4 4
SUBU4
CVUI4 4
CNSTI4 8192
LTI4 $855
line 1935
;1935:			{
line 1936
;1936:				N_Error( ERR_DROP, "Info_ValueForKey: oversize infostring" );
CNSTI4 1
ARGI4
ADDRGP4 $853
ARGP4
ADDRGP4 N_Error
CALLV
pop
line 1937
;1937:			}
ADDRGP4 $852
JUMPV
line 1939
;1938:			else 
;1939:			{
LABELV $854
line 1941
;1940:				while ( v < s )
;1941:					*o++ = *v++;
ADDRLP4 56
ADDRLP4 4
INDIRP4
ASGNP4
ADDRLP4 4
ADDRLP4 56
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 60
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 60
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 56
INDIRP4
ADDRLP4 60
INDIRP4
INDIRI1
ASGNI1
LABELV $855
line 1940
ADDRLP4 0
INDIRP4
CVPU4 4
ADDRFP4 0
INDIRP4
CVPU4 4
LTU4 $854
line 1942
;1942:			}
LABELV $852
line 1943
;1943:			*o = '\0';
ADDRLP4 4
INDIRP4
CNSTI1 0
ASGNI1
line 1944
;1944:			return o2;
ADDRLP4 20
INDIRP4
RETP4
ADDRGP4 $828
JUMPV
LABELV $849
line 1947
;1945:		}
;1946:
;1947:		if ( *s == '\0' )
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $857
line 1948
;1948:			break;
ADDRGP4 $839
JUMPV
LABELV $857
line 1950
;1949:
;1950:		s++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1951
;1951:	}
LABELV $838
line 1915
ADDRGP4 $837
JUMPV
LABELV $839
line 1953
;1952:
;1953:	return "";
ADDRGP4 $530
RETP4
LABELV $828
endproc Info_ValueForKey 64 12
bss
align 1
LABELV $860
skip 1024
export Info_Tokenize
code
proc Info_Tokenize 24 0
line 1972
;1954:}
;1955:
;1956:
;1957:#define MAX_INFO_TOKENS ((MAX_INFO_STRING/3)+2)
;1958:
;1959:static const char *info_keys[ MAX_INFO_TOKENS ];
;1960:static const char *info_values[ MAX_INFO_TOKENS ];
;1961:static uint32_t info_tokens;
;1962:
;1963:/*
;1964:===================
;1965:Info_Tokenize
;1966:
;1967:Tokenizes all key/value pairs from specified infostring
;1968:NOT suitable for big infostrings
;1969:===================
;1970:*/
;1971:void Info_Tokenize( const char *s )
;1972:{
line 1974
;1973:	static char tokenBuffer[ MAX_INFO_STRING ];
;1974:	char *o = tokenBuffer;
ADDRLP4 0
ADDRGP4 $860
ASGNP4
line 1976
;1975:
;1976:	info_tokens = 0;
ADDRGP4 info_tokens
CNSTU4 0
ASGNU4
line 1977
;1977:	*o = '\0';
ADDRLP4 0
INDIRP4
CNSTI1 0
ASGNI1
line 1979
;1978:
;1979:	for ( ;; )
line 1980
;1980:	{
ADDRGP4 $866
JUMPV
LABELV $865
line 1982
;1981:		while ( *s == '\\' ) // skip leading/trailing separators
;1982:			s++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
LABELV $866
line 1981
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 92
EQI4 $865
line 1984
;1983:
;1984:		if ( *s == '\0' )
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $868
line 1985
;1985:			break;
ADDRGP4 $863
JUMPV
LABELV $868
line 1987
;1986:
;1987:		info_keys[ info_tokens ] = o;
ADDRGP4 info_tokens
INDIRU4
CNSTI4 2
LSHU4
ADDRGP4 info_keys
ADDP4
ADDRLP4 0
INDIRP4
ASGNP4
ADDRGP4 $871
JUMPV
LABELV $870
line 1989
;1988:		while ( *s != '\\' )
;1989:		{
line 1990
;1990:			if ( *s == '\0' )
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $873
line 1991
;1991:			{
line 1992
;1992:				*o = '\0'; // terminate key
ADDRLP4 0
INDIRP4
CNSTI1 0
ASGNI1
line 1993
;1993:				info_values[ info_tokens++ ] = o;
ADDRLP4 8
ADDRGP4 info_tokens
ASGNP4
ADDRLP4 4
ADDRLP4 8
INDIRP4
INDIRU4
ASGNU4
ADDRLP4 8
INDIRP4
ADDRLP4 4
INDIRU4
CNSTU4 1
ADDU4
ASGNU4
ADDRLP4 4
INDIRU4
CNSTI4 2
LSHU4
ADDRGP4 info_values
ADDP4
ADDRLP4 0
INDIRP4
ASGNP4
line 1994
;1994:				return;
ADDRGP4 $859
JUMPV
LABELV $873
line 1996
;1995:			}
;1996:			*o++ = *s++;
ADDRLP4 4
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 4
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 8
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 8
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
INDIRP4
ADDRLP4 8
INDIRP4
INDIRI1
ASGNI1
line 1997
;1997:		}
LABELV $871
line 1988
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 92
NEI4 $870
line 1998
;1998:		*o++ = '\0'; // terminate key
ADDRLP4 4
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 4
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
INDIRP4
CNSTI1 0
ASGNI1
line 1999
;1999:		s++; // skip '\\'
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 2001
;2000:
;2001:		info_values[ info_tokens++ ] = o;
ADDRLP4 12
ADDRGP4 info_tokens
ASGNP4
ADDRLP4 8
ADDRLP4 12
INDIRP4
INDIRU4
ASGNU4
ADDRLP4 12
INDIRP4
ADDRLP4 8
INDIRU4
CNSTU4 1
ADDU4
ASGNU4
ADDRLP4 8
INDIRU4
CNSTI4 2
LSHU4
ADDRGP4 info_values
ADDP4
ADDRLP4 0
INDIRP4
ASGNP4
ADDRGP4 $876
JUMPV
LABELV $875
line 2003
;2002:		while ( *s != '\\' && *s != '\0' )
;2003:		{
line 2004
;2004:			*o++ = *s++;
ADDRLP4 16
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 16
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 20
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 20
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 16
INDIRP4
ADDRLP4 20
INDIRP4
INDIRI1
ASGNI1
line 2005
;2005:		}
LABELV $876
line 2002
ADDRLP4 16
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 16
INDIRI4
CNSTI4 92
EQI4 $878
ADDRLP4 16
INDIRI4
CNSTI4 0
NEI4 $875
LABELV $878
line 2006
;2006:		*o++ = '\0';
ADDRLP4 20
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 20
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 20
INDIRP4
CNSTI1 0
ASGNI1
line 2007
;2007:	}
line 1979
ADDRGP4 $866
JUMPV
LABELV $863
line 2008
;2008:}
LABELV $859
endproc Info_Tokenize 24 0
export Info_ValueForKeyToken
proc Info_ValueForKeyToken 8 8
line 2019
;2009:
;2010:
;2011:/*
;2012:===================
;2013:Info_ValueForKeyToken
;2014:
;2015:Fast lookup from tokenized infostring
;2016:===================
;2017:*/
;2018:const char *Info_ValueForKeyToken( const char *key )
;2019:{
line 2022
;2020:	uint32_t i;
;2021:
;2022:	for ( i = 0; i < info_tokens; i++ )  {
ADDRLP4 0
CNSTU4 0
ASGNU4
ADDRGP4 $883
JUMPV
LABELV $880
line 2023
;2023:		if ( N_stricmp( info_keys[ i ], key ) == 0 )
ADDRLP4 0
INDIRU4
CNSTI4 2
LSHU4
ADDRGP4 info_keys
ADDP4
INDIRP4
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 4
ADDRGP4 N_stricmp
CALLI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $884
line 2024
;2024:		{
line 2025
;2025:			return info_values[ i ];
ADDRLP4 0
INDIRU4
CNSTI4 2
LSHU4
ADDRGP4 info_values
ADDP4
INDIRP4
RETP4
ADDRGP4 $879
JUMPV
LABELV $884
line 2027
;2026:		}
;2027:	}
LABELV $881
line 2022
ADDRLP4 0
ADDRLP4 0
INDIRU4
CNSTU4 1
ADDU4
ASGNU4
LABELV $883
ADDRLP4 0
INDIRU4
ADDRGP4 info_tokens
INDIRU4
LTU4 $880
line 2029
;2028:
;2029:	return "";
ADDRGP4 $530
RETP4
LABELV $879
endproc Info_ValueForKeyToken 8 8
export Info_NextPair
proc Info_NextPair 12 0
line 2041
;2030:}
;2031:
;2032:
;2033:/*
;2034:===================
;2035:Info_NextPair
;2036:
;2037:Used to iterate through all the key/value pairs in an info string
;2038:===================
;2039:*/
;2040:const char *Info_NextPair( const char *s, char *key, char *value )
;2041:{
line 2044
;2042:	char	*o;
;2043:
;2044:	if ( *s == '\\' ) {
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 92
NEI4 $887
line 2045
;2045:		s++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 2046
;2046:	}
LABELV $887
line 2048
;2047:
;2048:	key[0] = '\0';
ADDRFP4 4
INDIRP4
CNSTI1 0
ASGNI1
line 2049
;2049:	value[0] = '\0';
ADDRFP4 8
INDIRP4
CNSTI1 0
ASGNI1
line 2051
;2050:
;2051:	o = key;
ADDRLP4 0
ADDRFP4 4
INDIRP4
ASGNP4
ADDRGP4 $890
JUMPV
LABELV $889
line 2052
;2052:	while ( *s != '\\' ) {
line 2053
;2053:		if ( !*s ) {
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $892
line 2054
;2054:			*o = '\0';
ADDRLP4 0
INDIRP4
CNSTI1 0
ASGNI1
line 2055
;2055:			return s;
ADDRFP4 0
INDIRP4
RETP4
ADDRGP4 $886
JUMPV
LABELV $892
line 2057
;2056:		}
;2057:		*o++ = *s++;
ADDRLP4 4
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 4
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 8
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 8
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
INDIRP4
ADDRLP4 8
INDIRP4
INDIRI1
ASGNI1
line 2058
;2058:	}
LABELV $890
line 2052
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 92
NEI4 $889
line 2059
;2059:	*o = '\0';
ADDRLP4 0
INDIRP4
CNSTI1 0
ASGNI1
line 2060
;2060:	s++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 2062
;2061:
;2062:	o = value;
ADDRLP4 0
ADDRFP4 8
INDIRP4
ASGNP4
ADDRGP4 $895
JUMPV
LABELV $894
line 2063
;2063:	while ( *s != '\\' && *s ) {
line 2064
;2064:		*o++ = *s++;
ADDRLP4 4
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 4
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 8
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 8
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
INDIRP4
ADDRLP4 8
INDIRP4
INDIRI1
ASGNI1
line 2065
;2065:	}
LABELV $895
line 2063
ADDRLP4 4
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 92
EQI4 $897
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $894
LABELV $897
line 2066
;2066:	*o = '\0';
ADDRLP4 0
INDIRP4
CNSTI1 0
ASGNI1
line 2068
;2067:
;2068:	return s;
ADDRFP4 0
INDIRP4
RETP4
LABELV $886
endproc Info_NextPair 12 0
export Info_RemoveKey
proc Info_RemoveKey 40 12
line 2080
;2069:}
;2070:
;2071:
;2072:/*
;2073:===================
;2074:Info_RemoveKey
;2075:
;2076:return removed character count
;2077:===================
;2078:*/
;2079:size_t Info_RemoveKey( char *s, const char *key )
;2080:{
line 2085
;2081:	char *start;
;2082:	const char *pkey;
;2083:	size_t key_len, len, ret;
;2084:
;2085:	key_len = strlen( key );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 20
ADDRGP4 strlen
CALLU4
ASGNU4
ADDRLP4 12
ADDRLP4 20
INDIRU4
ASGNU4
line 2086
;2086:	ret = 0;
ADDRLP4 4
CNSTU4 0
ASGNU4
ADDRGP4 $900
JUMPV
LABELV $899
line 2088
;2087:
;2088:	while ( 1 ) {
line 2089
;2089:		start = s;
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
line 2090
;2090:		if ( *s == '\\' ) {
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 92
NEI4 $902
line 2091
;2091:			++s;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 2092
;2092:		}
LABELV $902
line 2093
;2093:		pkey = s;
ADDRLP4 8
ADDRFP4 0
INDIRP4
ASGNP4
ADDRGP4 $905
JUMPV
LABELV $904
line 2094
;2094:		while ( *s != '\\' ) {
line 2095
;2095:			if ( *s == '\0' ) {
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $907
line 2096
;2096:				if ( s != start ) {
ADDRFP4 0
INDIRP4
CVPU4 4
ADDRLP4 0
INDIRP4
CVPU4 4
EQU4 $909
line 2098
;2097:					// remove any trailing empty keys
;2098:					*start = '\0';
ADDRLP4 0
INDIRP4
CNSTI1 0
ASGNI1
line 2099
;2099:					ret += (int)(s - start);
ADDRLP4 4
ADDRLP4 4
INDIRU4
ADDRFP4 0
INDIRP4
CVPU4 4
ADDRLP4 0
INDIRP4
CVPU4 4
SUBU4
CVUI4 4
CVIU4 4
ADDU4
ASGNU4
line 2100
;2100:				}
LABELV $909
line 2101
;2101:				return ret;
ADDRLP4 4
INDIRU4
RETU4
ADDRGP4 $898
JUMPV
LABELV $907
line 2103
;2102:			}
;2103:			++s;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 2104
;2104:		}
LABELV $905
line 2094
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 92
NEI4 $904
line 2105
;2105:		len = (s - pkey);
ADDRLP4 16
ADDRFP4 0
INDIRP4
CVPU4 4
ADDRLP4 8
INDIRP4
CVPU4 4
SUBU4
CVUI4 4
CVIU4 4
ASGNU4
line 2106
;2106:		++s; // skip '\\'
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRGP4 $912
JUMPV
LABELV $911
line 2108
;2107:
;2108:		while ( *s != '\\' && *s != '\0' ) {
line 2109
;2109:			++s;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 2110
;2110:		}
LABELV $912
line 2108
ADDRLP4 24
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 24
INDIRI4
CNSTI4 92
EQI4 $914
ADDRLP4 24
INDIRI4
CNSTI4 0
NEI4 $911
LABELV $914
line 2112
;2111:
;2112:		if ( len == key_len && Q_strkey( pkey, key, key_len ) ) {
ADDRLP4 16
INDIRU4
ADDRLP4 12
INDIRU4
NEU4 $915
ADDRLP4 8
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 12
INDIRU4
ARGU4
ADDRLP4 32
ADDRGP4 Q_strkey
CALLI4
ASGNI4
ADDRLP4 32
INDIRI4
CNSTI4 0
EQI4 $915
line 2113
;2113:			memmove( start, s, strlen( s ) + 1 ); // remove this part
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 36
ADDRGP4 strlen
CALLU4
ASGNU4
ADDRLP4 0
INDIRP4
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 36
INDIRU4
CNSTU4 1
ADDU4
ARGU4
ADDRGP4 memmove
CALLP4
pop
line 2114
;2114:			ret += (int)(s - start);
ADDRLP4 4
ADDRLP4 4
INDIRU4
ADDRFP4 0
INDIRP4
CVPU4 4
ADDRLP4 0
INDIRP4
CVPU4 4
SUBU4
CVUI4 4
CVIU4 4
ADDU4
ASGNU4
line 2115
;2115:			s = start;
ADDRFP4 0
ADDRLP4 0
INDIRP4
ASGNP4
line 2116
;2116:		}
LABELV $915
line 2118
;2117:
;2118:		if ( *s == '\0' ) {
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $917
line 2119
;2119:			break;
ADDRGP4 $901
JUMPV
LABELV $917
line 2121
;2120:		}
;2121:	}
LABELV $900
line 2088
ADDRGP4 $899
JUMPV
LABELV $901
line 2123
;2122:
;2123:	return ret;
ADDRLP4 4
INDIRU4
RETU4
LABELV $898
endproc Info_RemoveKey 40 12
export Info_Validate
proc Info_Validate 12 0
line 2136
;2124:}
;2125:
;2126:
;2127:/*
;2128:==================
;2129:Info_Validate
;2130:
;2131:Some characters are illegal in info strings because they
;2132:can mess up the server's parsing
;2133:==================
;2134:*/
;2135:qboolean Info_Validate( const char *s )
;2136:{
line 2137
;2137:	for ( ;; ) {
LABELV $920
line 2138
;2138:		switch ( *s++ ) {
ADDRLP4 4
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 4
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 0
ADDRLP4 4
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 34
EQI4 $928
ADDRLP4 0
INDIRI4
CNSTI4 34
GTI4 $930
LABELV $929
ADDRLP4 0
INDIRI4
CNSTI4 0
EQI4 $927
ADDRGP4 $920
JUMPV
LABELV $930
ADDRLP4 0
INDIRI4
CNSTI4 59
EQI4 $928
ADDRGP4 $920
JUMPV
LABELV $927
line 2140
;2139:		case '\0':
;2140:			return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $919
JUMPV
LABELV $928
line 2143
;2141:		case '\"':
;2142:		case ';':
;2143:			return qfalse;
CNSTI4 0
RETI4
line 2145
;2144:		default:
;2145:			break;
line 2146
;2146:		};
line 2147
;2147:	}
line 2137
LABELV $919
endproc Info_Validate 12 0
export Info_ValidateKeyValue
proc Info_ValidateKeyValue 16 0
line 2160
;2148:}
;2149:
;2150:
;2151:/*
;2152:==================
;2153:Info_ValidateKeyValue
;2154:
;2155:Some characters are illegal in key values because they
;2156:can mess up the server's parsing
;2157:==================
;2158:*/
;2159:qboolean Info_ValidateKeyValue( const char *s )
;2160:{
line 2161
;2161:	for ( ;; ) {
LABELV $932
line 2162
;2162:		switch ( *s++ ) {
ADDRLP4 4
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 4
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 0
ADDRLP4 4
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 34
EQI4 $940
ADDRLP4 0
INDIRI4
CNSTI4 34
GTI4 $942
LABELV $941
ADDRLP4 0
INDIRI4
CNSTI4 0
EQI4 $939
ADDRGP4 $932
JUMPV
LABELV $942
ADDRLP4 0
INDIRI4
CNSTI4 59
EQI4 $940
ADDRLP4 0
INDIRI4
CNSTI4 59
LTI4 $932
LABELV $943
ADDRLP4 0
INDIRI4
CNSTI4 92
EQI4 $940
ADDRGP4 $932
JUMPV
LABELV $939
line 2164
;2163:		case '\0':
;2164:			return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $931
JUMPV
LABELV $940
line 2168
;2165:		case '\\':
;2166:		case '\"':
;2167:		case ';':
;2168:			return qfalse;
CNSTI4 0
RETI4
line 2170
;2169:		default:
;2170:			break;
line 2171
;2171:		};
line 2172
;2172:	}
line 2161
LABELV $931
endproc Info_ValidateKeyValue 16 0
export Info_SetValueForKey_s
proc Info_SetValueForKey_s 8236 20
line 2184
;2173:}
;2174:
;2175:
;2176:/*
;2177:==================
;2178:Info_SetValueForKey_s
;2179:
;2180:Changes or adds a key/value pair
;2181:==================
;2182:*/
;2183:qboolean Info_SetValueForKey_s( char *s, uint32_t slen, const char *key, const char *value )
;2184:{
line 2188
;2185:	char		newi[BIG_INFO_STRING+2];
;2186:	uint32_t	len1, len2;
;2187:
;2188:	len1 = strlen( s );
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 8204
ADDRGP4 strlen
CALLU4
ASGNU4
ADDRLP4 0
ADDRLP4 8204
INDIRU4
ASGNU4
line 2190
;2189:
;2190:	if ( len1 >= slen ) {
ADDRLP4 0
INDIRU4
ADDRFP4 4
INDIRU4
LTU4 $945
line 2191
;2191:		Con_Printf( COLOR_YELLOW "Info_SetValueForKey(%s): oversize infostring\n", key );
ADDRGP4 $947
ARGP4
ADDRFP4 8
INDIRP4
ARGP4
ADDRGP4 Con_Printf
CALLV
pop
line 2192
;2192:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $944
JUMPV
LABELV $945
line 2195
;2193:	}
;2194:
;2195:	if ( !key || !Info_ValidateKeyValue( key ) || *key == '\0' ) {
ADDRLP4 8208
ADDRFP4 8
INDIRP4
ASGNP4
ADDRLP4 8208
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $951
ADDRLP4 8208
INDIRP4
ARGP4
ADDRLP4 8212
ADDRGP4 Info_ValidateKeyValue
CALLI4
ASGNI4
ADDRLP4 8212
INDIRI4
CNSTI4 0
EQI4 $951
ADDRFP4 8
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $948
LABELV $951
line 2196
;2196:		Con_Printf( COLOR_YELLOW "Invalid key name: '%s'\n", key );
ADDRGP4 $952
ARGP4
ADDRFP4 8
INDIRP4
ARGP4
ADDRGP4 Con_Printf
CALLV
pop
line 2197
;2197:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $944
JUMPV
LABELV $948
line 2200
;2198:	}
;2199:
;2200:	if ( value && !Info_ValidateKeyValue( value ) ) {
ADDRLP4 8216
ADDRFP4 12
INDIRP4
ASGNP4
ADDRLP4 8216
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $953
ADDRLP4 8216
INDIRP4
ARGP4
ADDRLP4 8220
ADDRGP4 Info_ValidateKeyValue
CALLI4
ASGNI4
ADDRLP4 8220
INDIRI4
CNSTI4 0
NEI4 $953
line 2201
;2201:		Con_Printf( COLOR_YELLOW "Invalid value name: '%s'\n", value );
ADDRGP4 $955
ARGP4
ADDRFP4 12
INDIRP4
ARGP4
ADDRGP4 Con_Printf
CALLV
pop
line 2202
;2202:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $944
JUMPV
LABELV $953
line 2205
;2203:	}
;2204:
;2205:	len1 -= Info_RemoveKey( s, key );
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 8
INDIRP4
ARGP4
ADDRLP4 8224
ADDRGP4 Info_RemoveKey
CALLU4
ASGNU4
ADDRLP4 0
ADDRLP4 0
INDIRU4
ADDRLP4 8224
INDIRU4
SUBU4
ASGNU4
line 2206
;2206:	if ( value == NULL || *value == '\0' ) {
ADDRLP4 8228
ADDRFP4 12
INDIRP4
ASGNP4
ADDRLP4 8228
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $958
ADDRLP4 8228
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $956
LABELV $958
line 2207
;2207:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $944
JUMPV
LABELV $956
line 2210
;2208:	}
;2209:
;2210:	len2 = Com_snprintf( newi, sizeof( newi ), "\\%s\\%s", key, value );
ADDRLP4 4
ARGP4
CNSTU4 8194
ARGU4
ADDRGP4 $959
ARGP4
ADDRFP4 8
INDIRP4
ARGP4
ADDRFP4 12
INDIRP4
ARGP4
ADDRLP4 8232
ADDRGP4 Com_snprintf
CALLI4
ASGNI4
ADDRLP4 8200
ADDRLP4 8232
INDIRI4
CVIU4 4
ASGNU4
line 2212
;2211:
;2212:	if ( len1 + len2 >= slen ) {
ADDRLP4 0
INDIRU4
ADDRLP4 8200
INDIRU4
ADDU4
ADDRFP4 4
INDIRU4
LTU4 $960
line 2213
;2213:		Con_Printf( COLOR_YELLOW "Info string length exceeded for key '%s'\n", key );
ADDRGP4 $962
ARGP4
ADDRFP4 8
INDIRP4
ARGP4
ADDRGP4 Con_Printf
CALLV
pop
line 2214
;2214:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $944
JUMPV
LABELV $960
line 2217
;2215:	}
;2216:
;2217:	strcpy( s + len1, newi );
ADDRLP4 0
INDIRU4
ADDRFP4 0
INDIRP4
ADDP4
ARGP4
ADDRLP4 4
ARGP4
ADDRGP4 strcpy
CALLP4
pop
line 2218
;2218:	return qtrue;
CNSTI4 1
RETI4
LABELV $944
endproc Info_SetValueForKey_s 8236 20
import strncpy
import strrchr
bss
align 4
LABELV info_tokens
skip 4
align 4
LABELV info_values
skip 1372
align 4
LABELV info_keys
skip 1372
align 4
LABELV com_tokenline
skip 4
align 4
LABELV com_lines
skip 4
align 1
LABELV com_parsename
skip 1024
align 1
LABELV com_token
skip 1024
import I_GetParm
import Com_TouchMemory
import Hunk_TempIsClear
import Hunk_Check
import Hunk_Print
import Hunk_SetMark
import Hunk_ClearToMark
import Hunk_CheckMark
import Hunk_SmallLog
import Hunk_Log
import Hunk_MemoryRemaining
import Hunk_ClearTempMemory
import Hunk_FreeTempMemory
import Hunk_AllocateTempMemory
import Hunk_Clear
import Hunk_Alloc
import Hunk_InitMemory
import Z_InitMemory
import Z_InitSmallZoneMemory
import CopyString
import Z_AvailableMemory
import Z_FreeTags
import Z_Free
import S_Malloc
import Z_Malloc
import Z_Realloc
import CPU_flags
import FS_ReadLine
import FS_ListFiles
import FS_FreeFileList
import FS_FreeFile
import FS_SetBFFIndex
import FS_GetCurrentChunkList
import FS_Initialized
import FS_FileIsInBFF
import FS_StripExt
import FS_AllowedExtension
import FS_GetFileList
import FS_LoadLibrary
import FS_CopyString
import FS_BuildOSPath
import FS_FilenameCompare
import FS_FileTell
import FS_FileLength
import FS_FileSeek
import FS_FileExists
import FS_LastBFFIndex
import FS_LoadStack
import FS_Rename
import FS_FOpenFileRead
import FS_FOpenAppend
import FS_FOpenRW
import FS_FOpenWrite
import FS_FOpenRead
import FS_FOpenFileWithMode
import FS_FOpenWithMode
import FS_FileToFileno
import FS_Printf
import FS_GetGamePath
import FS_GetHomePath
import FS_GetBasePath
import FS_GetBaseGameDir
import FS_GetCurrentGameDir
import FS_Flush
import FS_ForceFlush
import FS_FClose
import FS_LoadFile
import FS_WriteFile
import FS_Write
import FS_Read
import FS_Remove
import FS_Restart
import FS_Shutdown
import FS_InitFilesystem
import FS_Startup
import FS_VM_CloseFiles
import FS_VM_FileLength
import FS_VM_Read
import FS_VM_Write
import FS_VM_WriteFile
import FS_VM_FClose
import FS_VM_FOpenFileRead
import FS_VM_FOpenFileWrite
import FS_VM_FOpenFile
import FS_VM_FileTell
import FS_VM_FileSeek
import FS_VM_FOpenRW
import FS_VM_FOpenAppend
import FS_VM_FOpenWrite
import FS_VM_FOpenRead
import com_errorMessage
import com_fullyInitialized
import com_errorEntered
import com_cacheLine
import com_frameTime
import com_fps
import com_frameNumber
import com_maxfps
import sys_cpuString
import com_devmode
import com_version
import com_logfile
import com_journal
import com_demo
import Con_HistoryGetNext
import Con_HistoryGetPrev
import Con_SaveField
import Con_ResetHistory
import Field_CompleteCommand
import Field_CompleteFilename
import Field_CompleteKeyBind
import Field_CompleteKeyname
import Field_AutoComplete
import Field_Clear
import Cbuf_Init
import Cbuf_Clear
import Cbuf_AddText
import Cbuf_Execute
import Cbuf_InsertText
import Cbuf_ExecuteText
import Cmd_CompleteArgument
import Cmd_CommandCompletion
import Cmd_Clear
import Cmd_Argv
import Cmd_ArgsFrom
import Cmd_SetCommandCompletionFunc
import Cmd_TokenizeStringIgnoreQuotes
import Cmd_TokenizeString
import Cmd_ArgvBuffer
import Cmd_Argc
import Cmd_ExecuteString
import Cmd_ExecuteText
import Cmd_ArgsBuffer
import Cmd_ExecuteCommand
import Cmd_RemoveCommand
import Cmd_AddCommand
import Cmd_Init
import keys
import Key_WriteBindings
import Key_SetOverstrikeMode
import Key_GetOverstrikeMode
import Key_GetKey
import Key_GetCatcher
import Key_SetCatcher
import Key_ClearStates
import Key_GetBinding
import Key_IsDown
import Key_KeynumToString
import Key_StringToKeynum
import Key_KeynameCompletion
import Com_EventLoop
import Com_KeyEvent
import Com_SendKeyEvents
import Com_QueueEvent
import Com_InitKeyCommands
export com_tokentype
align 4
LABELV com_tokentype
skip 4
import Com_BlockChecksum
import Com_SortFileList
import Com_Base64Decode
import Com_WriteConfig
import Con_RenderConsole
import Com_Shutdown
import Com_Init
import Com_StartupVariable
import Com_EarlyParseCmdLine
import Com_Milliseconds
import Com_Frame
import Sys_SnapVector
import Con_DPrintf
import Con_Printf
import Con_Shutdown
import Con_Init
import Con_DrawConsole
import Con_AddText
import ColorIndexFromChar
import g_color_table
import bytedirs
import N_isnan
import N_crandom
import N_random
import N_rand
import N_fabs
import N_acos
import N_log2
import ColorBytes4
import ColorBytes3
import AddPointToBounds
import ClearBounds
import RadiusFromBounds
import NormalizeColor
import _VectorMA
import _VectorScale
import _VectorCopy
import _VectorAdd
import _VectorSubtract
import _DotProduct
import ByteToDir
import DirToByte
import CrossProduct
import VectorInverse
import VectorNormalizeFast
import DistanceSquared
import Distance
import VectorLengthSquared
import VectorLength
import VectorCompare
import BoundsIntersectPoint
import BoundsIntersectSphere
import BoundsIntersect
import disBetweenOBJ
import vec3_set
import vec3_get
import ClampShort
import ClampCharMove
import ClampChar
import N_exp2f
import N_log2f
import Q_rsqrt
import N_Error
import colorDkGrey
import colorMdGrey
import colorLtGrey
import colorWhite
import colorCyan
import colorMagenta
import colorYellow
import colorBlue
import colorGreen
import colorRed
import colorBlack
import vec2_origin
import vec3_origin
import N_atof
import N_fmaxf
import acos
import fabs
import abs
import tan
import atan2
import cos
import sin
import sqrt
import floor
import ceil
import sscanf
import vsprintf
import rand
import srand
import qsort
import toupper
import tolower
import strncmp
import strcmp
import strstr
import strchr
import strlen
import strcat
import strcpy
import memmove
import memset
import memchr
import memcpy
lit
align 1
LABELV $962
byte 1 94
byte 1 51
byte 1 73
byte 1 110
byte 1 102
byte 1 111
byte 1 32
byte 1 115
byte 1 116
byte 1 114
byte 1 105
byte 1 110
byte 1 103
byte 1 32
byte 1 108
byte 1 101
byte 1 110
byte 1 103
byte 1 116
byte 1 104
byte 1 32
byte 1 101
byte 1 120
byte 1 99
byte 1 101
byte 1 101
byte 1 100
byte 1 101
byte 1 100
byte 1 32
byte 1 102
byte 1 111
byte 1 114
byte 1 32
byte 1 107
byte 1 101
byte 1 121
byte 1 32
byte 1 39
byte 1 37
byte 1 115
byte 1 39
byte 1 10
byte 1 0
align 1
LABELV $959
byte 1 92
byte 1 37
byte 1 115
byte 1 92
byte 1 37
byte 1 115
byte 1 0
align 1
LABELV $955
byte 1 94
byte 1 51
byte 1 73
byte 1 110
byte 1 118
byte 1 97
byte 1 108
byte 1 105
byte 1 100
byte 1 32
byte 1 118
byte 1 97
byte 1 108
byte 1 117
byte 1 101
byte 1 32
byte 1 110
byte 1 97
byte 1 109
byte 1 101
byte 1 58
byte 1 32
byte 1 39
byte 1 37
byte 1 115
byte 1 39
byte 1 10
byte 1 0
align 1
LABELV $952
byte 1 94
byte 1 51
byte 1 73
byte 1 110
byte 1 118
byte 1 97
byte 1 108
byte 1 105
byte 1 100
byte 1 32
byte 1 107
byte 1 101
byte 1 121
byte 1 32
byte 1 110
byte 1 97
byte 1 109
byte 1 101
byte 1 58
byte 1 32
byte 1 39
byte 1 37
byte 1 115
byte 1 39
byte 1 10
byte 1 0
align 1
LABELV $947
byte 1 94
byte 1 51
byte 1 73
byte 1 110
byte 1 102
byte 1 111
byte 1 95
byte 1 83
byte 1 101
byte 1 116
byte 1 86
byte 1 97
byte 1 108
byte 1 117
byte 1 101
byte 1 70
byte 1 111
byte 1 114
byte 1 75
byte 1 101
byte 1 121
byte 1 40
byte 1 37
byte 1 115
byte 1 41
byte 1 58
byte 1 32
byte 1 111
byte 1 118
byte 1 101
byte 1 114
byte 1 115
byte 1 105
byte 1 122
byte 1 101
byte 1 32
byte 1 105
byte 1 110
byte 1 102
byte 1 111
byte 1 115
byte 1 116
byte 1 114
byte 1 105
byte 1 110
byte 1 103
byte 1 10
byte 1 0
align 1
LABELV $853
byte 1 73
byte 1 110
byte 1 102
byte 1 111
byte 1 95
byte 1 86
byte 1 97
byte 1 108
byte 1 117
byte 1 101
byte 1 70
byte 1 111
byte 1 114
byte 1 75
byte 1 101
byte 1 121
byte 1 58
byte 1 32
byte 1 111
byte 1 118
byte 1 101
byte 1 114
byte 1 115
byte 1 105
byte 1 122
byte 1 101
byte 1 32
byte 1 105
byte 1 110
byte 1 102
byte 1 111
byte 1 115
byte 1 116
byte 1 114
byte 1 105
byte 1 110
byte 1 103
byte 1 0
align 1
LABELV $820
byte 1 37
byte 1 42
byte 1 99
byte 1 0
align 1
LABELV $818
byte 1 37
byte 1 42
byte 1 99
byte 1 32
byte 1 37
byte 1 115
byte 1 32
byte 1 37
byte 1 42
byte 1 99
byte 1 0
align 1
LABELV $763
byte 1 41
byte 1 0
align 1
LABELV $758
byte 1 40
byte 1 0
align 1
LABELV $724
byte 1 77
byte 1 97
byte 1 116
byte 1 99
byte 1 104
byte 1 84
byte 1 111
byte 1 107
byte 1 101
byte 1 110
byte 1 58
byte 1 32
byte 1 37
byte 1 115
byte 1 32
byte 1 33
byte 1 61
byte 1 32
byte 1 37
byte 1 115
byte 1 0
align 1
LABELV $544
byte 1 94
byte 1 51
byte 1 87
byte 1 65
byte 1 82
byte 1 78
byte 1 73
byte 1 78
byte 1 71
byte 1 58
byte 1 32
byte 1 37
byte 1 115
byte 1 44
byte 1 32
byte 1 108
byte 1 105
byte 1 110
byte 1 101
byte 1 32
byte 1 37
byte 1 108
byte 1 117
byte 1 58
byte 1 32
byte 1 37
byte 1 115
byte 1 10
byte 1 0
align 1
LABELV $540
byte 1 94
byte 1 49
byte 1 69
byte 1 82
byte 1 82
byte 1 79
byte 1 82
byte 1 58
byte 1 32
byte 1 37
byte 1 115
byte 1 44
byte 1 32
byte 1 108
byte 1 105
byte 1 110
byte 1 101
byte 1 32
byte 1 37
byte 1 108
byte 1 117
byte 1 58
byte 1 32
byte 1 37
byte 1 115
byte 1 10
byte 1 0
align 1
LABELV $532
byte 1 37
byte 1 115
byte 1 0
align 1
LABELV $530
byte 1 0
align 1
LABELV $519
byte 1 94
byte 1 51
byte 1 67
byte 1 111
byte 1 109
byte 1 95
byte 1 115
byte 1 110
byte 1 112
byte 1 114
byte 1 105
byte 1 110
byte 1 116
byte 1 102
byte 1 58
byte 1 32
byte 1 111
byte 1 118
byte 1 101
byte 1 114
byte 1 102
byte 1 108
byte 1 111
byte 1 119
byte 1 32
byte 1 111
byte 1 102
byte 1 32
byte 1 37
byte 1 105
byte 1 32
byte 1 105
byte 1 110
byte 1 32
byte 1 37
byte 1 117
byte 1 10
byte 1 0
align 1
LABELV $516
byte 1 67
byte 1 111
byte 1 109
byte 1 95
byte 1 115
byte 1 109
byte 1 112
byte 1 114
byte 1 105
byte 1 110
byte 1 116
byte 1 102
byte 1 58
byte 1 32
byte 1 111
byte 1 118
byte 1 101
byte 1 114
byte 1 102
byte 1 108
byte 1 111
byte 1 119
byte 1 101
byte 1 100
byte 1 32
byte 1 98
byte 1 105
byte 1 103
byte 1 98
byte 1 117
byte 1 102
byte 1 102
byte 1 101
byte 1 114
byte 1 0
align 1
LABELV $511
byte 1 67
byte 1 111
byte 1 109
byte 1 95
byte 1 115
byte 1 110
byte 1 112
byte 1 114
byte 1 105
byte 1 110
byte 1 116
byte 1 102
byte 1 58
byte 1 32
byte 1 78
byte 1 85
byte 1 76
byte 1 76
byte 1 32
byte 1 100
byte 1 101
byte 1 115
byte 1 116
byte 1 0
align 1
LABELV $345
byte 1 78
byte 1 95
byte 1 115
byte 1 116
byte 1 114
byte 1 99
byte 1 97
byte 1 116
byte 1 58
byte 1 32
byte 1 97
byte 1 108
byte 1 114
byte 1 101
byte 1 97
byte 1 100
byte 1 121
byte 1 32
byte 1 111
byte 1 118
byte 1 101
byte 1 114
byte 1 102
byte 1 108
byte 1 111
byte 1 119
byte 1 101
byte 1 100
byte 1 0
align 1
LABELV $294
byte 1 78
byte 1 95
byte 1 115
byte 1 116
byte 1 114
byte 1 110
byte 1 99
byte 1 112
byte 1 121
byte 1 122
byte 1 58
byte 1 32
byte 1 98
byte 1 97
byte 1 100
byte 1 32
byte 1 99
byte 1 111
byte 1 117
byte 1 110
byte 1 116
byte 1 0
align 1
LABELV $291
byte 1 78
byte 1 95
byte 1 115
byte 1 116
byte 1 114
byte 1 110
byte 1 99
byte 1 112
byte 1 121
byte 1 122
byte 1 58
byte 1 32
byte 1 78
byte 1 85
byte 1 76
byte 1 76
byte 1 32
byte 1 115
byte 1 114
byte 1 99
byte 1 0
align 1
LABELV $288
byte 1 78
byte 1 95
byte 1 115
byte 1 116
byte 1 114
byte 1 110
byte 1 99
byte 1 112
byte 1 121
byte 1 122
byte 1 58
byte 1 32
byte 1 78
byte 1 85
byte 1 76
byte 1 76
byte 1 32
byte 1 100
byte 1 101
byte 1 115
byte 1 116
byte 1 0
align 1
LABELV $284
byte 1 32
byte 1 46
byte 1 46
byte 1 46
byte 1 32
byte 1 0
