export Com_Clamp
code
proc Com_Clamp 0 0
file "../../engine/n_shared.c"
line 12
;1:#ifdef Q3_VM
;2:#include "../engine/n_shared.h"
;3:#else
;4:#include "code/engine/n_shared.h"
;5:#endif
;6:
;7:// undefined symbol: CPU_flags when compiling dlls
;8:#if defined(GDR_DLLCOMPILE) || defined(UI_HARD_LINKED) || defined(SGAME_HARD_LINKED)
;9:int CPU_flags;
;10:#endif
;11:
;12:float Com_Clamp( float min, float max, float value ) {
line 13
;13:	if ( value < min ) {
ADDRFP4 8
INDIRF4
ADDRFP4 0
INDIRF4
GEF4 $25
line 14
;14:		return min;
ADDRFP4 0
INDIRF4
RETF4
ADDRGP4 $24
JUMPV
LABELV $25
line 16
;15:	}
;16:	if ( value > max ) {
ADDRFP4 8
INDIRF4
ADDRFP4 4
INDIRF4
LEF4 $27
line 17
;17:		return max;
ADDRFP4 4
INDIRF4
RETF4
ADDRGP4 $24
JUMPV
LABELV $27
line 19
;18:	}
;19:	return value;
ADDRFP4 8
INDIRF4
RETF4
LABELV $24
endproc Com_Clamp 0 0
data
export locase
align 1
LABELV locase
byte 1 0
byte 1 1
byte 1 2
byte 1 3
byte 1 4
byte 1 5
byte 1 6
byte 1 7
byte 1 8
byte 1 9
byte 1 10
byte 1 11
byte 1 12
byte 1 13
byte 1 14
byte 1 15
byte 1 16
byte 1 17
byte 1 18
byte 1 19
byte 1 20
byte 1 21
byte 1 22
byte 1 23
byte 1 24
byte 1 25
byte 1 26
byte 1 27
byte 1 28
byte 1 29
byte 1 30
byte 1 31
byte 1 32
byte 1 33
byte 1 34
byte 1 35
byte 1 36
byte 1 37
byte 1 38
byte 1 39
byte 1 40
byte 1 41
byte 1 42
byte 1 43
byte 1 44
byte 1 45
byte 1 46
byte 1 47
byte 1 48
byte 1 49
byte 1 50
byte 1 51
byte 1 52
byte 1 53
byte 1 54
byte 1 55
byte 1 56
byte 1 57
byte 1 58
byte 1 59
byte 1 60
byte 1 61
byte 1 62
byte 1 63
byte 1 64
byte 1 97
byte 1 98
byte 1 99
byte 1 100
byte 1 101
byte 1 102
byte 1 103
byte 1 104
byte 1 105
byte 1 106
byte 1 107
byte 1 108
byte 1 109
byte 1 110
byte 1 111
byte 1 112
byte 1 113
byte 1 114
byte 1 115
byte 1 116
byte 1 117
byte 1 118
byte 1 119
byte 1 120
byte 1 121
byte 1 122
byte 1 91
byte 1 92
byte 1 93
byte 1 94
byte 1 95
byte 1 96
byte 1 97
byte 1 98
byte 1 99
byte 1 100
byte 1 101
byte 1 102
byte 1 103
byte 1 104
byte 1 105
byte 1 106
byte 1 107
byte 1 108
byte 1 109
byte 1 110
byte 1 111
byte 1 112
byte 1 113
byte 1 114
byte 1 115
byte 1 116
byte 1 117
byte 1 118
byte 1 119
byte 1 120
byte 1 121
byte 1 122
byte 1 123
byte 1 124
byte 1 125
byte 1 126
byte 1 127
byte 1 128
byte 1 129
byte 1 130
byte 1 131
byte 1 132
byte 1 133
byte 1 134
byte 1 135
byte 1 136
byte 1 137
byte 1 138
byte 1 139
byte 1 140
byte 1 141
byte 1 142
byte 1 143
byte 1 144
byte 1 145
byte 1 146
byte 1 147
byte 1 148
byte 1 149
byte 1 150
byte 1 151
byte 1 152
byte 1 153
byte 1 154
byte 1 155
byte 1 156
byte 1 157
byte 1 158
byte 1 159
byte 1 160
byte 1 161
byte 1 162
byte 1 163
byte 1 164
byte 1 165
byte 1 166
byte 1 167
byte 1 168
byte 1 169
byte 1 170
byte 1 171
byte 1 172
byte 1 173
byte 1 174
byte 1 175
byte 1 176
byte 1 177
byte 1 178
byte 1 179
byte 1 180
byte 1 181
byte 1 182
byte 1 183
byte 1 184
byte 1 185
byte 1 186
byte 1 187
byte 1 188
byte 1 189
byte 1 190
byte 1 191
byte 1 192
byte 1 193
byte 1 194
byte 1 195
byte 1 196
byte 1 197
byte 1 198
byte 1 199
byte 1 200
byte 1 201
byte 1 202
byte 1 203
byte 1 204
byte 1 205
byte 1 206
byte 1 207
byte 1 208
byte 1 209
byte 1 210
byte 1 211
byte 1 212
byte 1 213
byte 1 214
byte 1 215
byte 1 216
byte 1 217
byte 1 218
byte 1 219
byte 1 220
byte 1 221
byte 1 222
byte 1 223
byte 1 224
byte 1 225
byte 1 226
byte 1 227
byte 1 228
byte 1 229
byte 1 230
byte 1 231
byte 1 232
byte 1 233
byte 1 234
byte 1 235
byte 1 236
byte 1 237
byte 1 238
byte 1 239
byte 1 240
byte 1 241
byte 1 242
byte 1 243
byte 1 244
byte 1 245
byte 1 246
byte 1 247
byte 1 248
byte 1 249
byte 1 250
byte 1 251
byte 1 252
byte 1 253
byte 1 254
byte 1 255
bss
align 4
LABELV $30
skip 1024
data
align 4
LABELV $31
byte 4 0
export crc32_buffer
code
proc crc32_buffer 20 0
line 58
;20:}
;21:
;22:const byte locase[ 256 ] = {
;23:	0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
;24:	0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
;25:	0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,
;26:	0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
;27:	0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,
;28:	0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
;29:	0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,
;30:	0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
;31:	0x40,0x61,0x62,0x63,0x64,0x65,0x66,0x67,
;32:	0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,
;33:	0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,
;34:	0x78,0x79,0x7a,0x5b,0x5c,0x5d,0x5e,0x5f,
;35:	0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,
;36:	0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,
;37:	0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,
;38:	0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x7e,0x7f,
;39:	0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,
;40:	0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,
;41:	0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,
;42:	0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,
;43:	0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,
;44:	0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,
;45:	0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,
;46:	0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,
;47:	0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,
;48:	0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,
;49:	0xd0,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,
;50:	0xd8,0xd9,0xda,0xdb,0xdc,0xdd,0xde,0xdf,
;51:	0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,
;52:	0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,
;53:	0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,
;54:	0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff
;55:};
;56:
;57:uint32_t crc32_buffer(const byte *buf, uint32_t len)
;58:{
line 62
;59:	static uint32_t crc32_table[256];
;60:	static qboolean crc32_inited = qfalse;
;61:
;62:	uint32_t crc = UINT_MAX;
ADDRLP4 0
CNSTU4 4294967295
ASGNU4
line 64
;63:
;64:	if (!crc32_inited) {
ADDRGP4 $31
INDIRI4
CNSTI4 0
NEI4 $46
line 68
;65:		uint32_t c;
;66:		int i, j;
;67:
;68:		for (i = 0; i < 256; i++) {
ADDRLP4 12
CNSTI4 0
ASGNI4
LABELV $34
line 69
;69:			c = i;
ADDRLP4 4
ADDRLP4 12
INDIRI4
CVIU4 4
ASGNU4
line 70
;70:			for (j = 0; j < 8; j++)
ADDRLP4 8
CNSTI4 0
ASGNI4
LABELV $38
line 71
;71:				c = (c & 1) ? (c >> 1) ^ 0xEDB88320UL : c >> 1;
ADDRLP4 4
INDIRU4
CNSTU4 1
BANDU4
CNSTU4 0
EQU4 $43
ADDRLP4 16
ADDRLP4 4
INDIRU4
CNSTI4 1
RSHU4
CNSTU4 3988292384
BXORU4
ASGNU4
ADDRGP4 $44
JUMPV
LABELV $43
ADDRLP4 16
ADDRLP4 4
INDIRU4
CNSTI4 1
RSHU4
ASGNU4
LABELV $44
ADDRLP4 4
ADDRLP4 16
INDIRU4
ASGNU4
LABELV $39
line 70
ADDRLP4 8
ADDRLP4 8
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 8
LTI4 $38
line 73
;72:			
;73:			crc32_table[i] = c;
ADDRLP4 12
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 $30
ADDP4
ADDRLP4 4
INDIRU4
ASGNU4
line 74
;74:		}
LABELV $35
line 68
ADDRLP4 12
ADDRLP4 12
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 256
LTI4 $34
line 75
;75:		crc32_inited = qtrue;
ADDRGP4 $31
CNSTI4 1
ASGNI4
line 76
;76:	}
ADDRGP4 $46
JUMPV
LABELV $45
line 79
;77:
;78:	while (len--)
;79:		crc = crc32_table[(crc ^ *buf++) & 0xFF] ^ (crc >> 8);
ADDRLP4 4
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 4
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 0
ADDRLP4 0
INDIRU4
ADDRLP4 4
INDIRP4
INDIRU1
CVUI4 1
CVIU4 4
BXORU4
CNSTU4 255
BANDU4
CNSTI4 2
LSHU4
ADDRGP4 $30
ADDP4
INDIRU4
ADDRLP4 0
INDIRU4
CNSTI4 8
RSHU4
BXORU4
ASGNU4
LABELV $46
line 78
ADDRLP4 12
ADDRFP4 4
INDIRU4
ASGNU4
ADDRFP4 4
ADDRLP4 12
INDIRU4
CNSTU4 1
SUBU4
ASGNU4
ADDRLP4 12
INDIRU4
CNSTU4 0
NEU4 $45
line 81
;80:
;81:	return crc ^ UINT_MAX;
ADDRLP4 0
INDIRU4
CNSTU4 4294967295
BXORU4
RETU4
LABELV $29
endproc crc32_buffer 20 0
lit
align 1
LABELV hash_locase
byte 1 0
byte 1 1
byte 1 2
byte 1 3
byte 1 4
byte 1 5
byte 1 6
byte 1 7
byte 1 8
byte 1 9
byte 1 10
byte 1 11
byte 1 12
byte 1 13
byte 1 14
byte 1 15
byte 1 16
byte 1 17
byte 1 18
byte 1 19
byte 1 20
byte 1 21
byte 1 22
byte 1 23
byte 1 24
byte 1 25
byte 1 26
byte 1 27
byte 1 28
byte 1 29
byte 1 30
byte 1 31
byte 1 32
byte 1 33
byte 1 34
byte 1 35
byte 1 36
byte 1 37
byte 1 38
byte 1 39
byte 1 40
byte 1 41
byte 1 42
byte 1 43
byte 1 44
byte 1 45
byte 1 0
byte 1 47
byte 1 48
byte 1 49
byte 1 50
byte 1 51
byte 1 52
byte 1 53
byte 1 54
byte 1 55
byte 1 56
byte 1 57
byte 1 58
byte 1 59
byte 1 60
byte 1 61
byte 1 62
byte 1 63
byte 1 64
byte 1 97
byte 1 98
byte 1 99
byte 1 100
byte 1 101
byte 1 102
byte 1 103
byte 1 104
byte 1 105
byte 1 106
byte 1 107
byte 1 108
byte 1 109
byte 1 110
byte 1 111
byte 1 112
byte 1 113
byte 1 114
byte 1 115
byte 1 116
byte 1 117
byte 1 118
byte 1 119
byte 1 120
byte 1 121
byte 1 122
byte 1 91
byte 1 47
byte 1 93
byte 1 94
byte 1 95
byte 1 96
byte 1 97
byte 1 98
byte 1 99
byte 1 100
byte 1 101
byte 1 102
byte 1 103
byte 1 104
byte 1 105
byte 1 106
byte 1 107
byte 1 108
byte 1 109
byte 1 110
byte 1 111
byte 1 112
byte 1 113
byte 1 114
byte 1 115
byte 1 116
byte 1 117
byte 1 118
byte 1 119
byte 1 120
byte 1 121
byte 1 122
byte 1 123
byte 1 124
byte 1 125
byte 1 126
byte 1 127
byte 1 128
byte 1 129
byte 1 130
byte 1 131
byte 1 132
byte 1 133
byte 1 134
byte 1 135
byte 1 136
byte 1 137
byte 1 138
byte 1 139
byte 1 140
byte 1 141
byte 1 142
byte 1 143
byte 1 144
byte 1 145
byte 1 146
byte 1 147
byte 1 148
byte 1 149
byte 1 150
byte 1 151
byte 1 152
byte 1 153
byte 1 154
byte 1 155
byte 1 156
byte 1 157
byte 1 158
byte 1 159
byte 1 160
byte 1 161
byte 1 162
byte 1 163
byte 1 164
byte 1 165
byte 1 166
byte 1 167
byte 1 168
byte 1 169
byte 1 170
byte 1 171
byte 1 172
byte 1 173
byte 1 174
byte 1 175
byte 1 176
byte 1 177
byte 1 178
byte 1 179
byte 1 180
byte 1 181
byte 1 182
byte 1 183
byte 1 184
byte 1 185
byte 1 186
byte 1 187
byte 1 188
byte 1 189
byte 1 190
byte 1 191
byte 1 192
byte 1 193
byte 1 194
byte 1 195
byte 1 196
byte 1 197
byte 1 198
byte 1 199
byte 1 200
byte 1 201
byte 1 202
byte 1 203
byte 1 204
byte 1 205
byte 1 206
byte 1 207
byte 1 208
byte 1 209
byte 1 210
byte 1 211
byte 1 212
byte 1 213
byte 1 214
byte 1 215
byte 1 216
byte 1 217
byte 1 218
byte 1 219
byte 1 220
byte 1 221
byte 1 222
byte 1 223
byte 1 224
byte 1 225
byte 1 226
byte 1 227
byte 1 228
byte 1 229
byte 1 230
byte 1 231
byte 1 232
byte 1 233
byte 1 234
byte 1 235
byte 1 236
byte 1 237
byte 1 238
byte 1 239
byte 1 240
byte 1 241
byte 1 242
byte 1 243
byte 1 244
byte 1 245
byte 1 246
byte 1 247
byte 1 248
byte 1 249
byte 1 250
byte 1 251
byte 1 252
byte 1 253
byte 1 254
byte 1 255
export Com_GenerateHashValue
code
proc Com_GenerateHashValue 24 0
ADDRFP4 4
ADDRFP4 4
INDIRU4
ASGNU4
line 126
;82:}
;83:
;84:
;85:/*
;86:Com_GenerateHashValue: used in renderer and filesystem
;87:*/
;88:// ASCII lowcase conversion table with '\\' turned to '/' and '.' to '\0'
;89:static const byte hash_locase[ 256 ] =
;90:{
;91:	0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
;92:	0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
;93:	0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,
;94:	0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
;95:	0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,
;96:	0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x00,0x2f,
;97:	0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,
;98:	0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
;99:	0x40,0x61,0x62,0x63,0x64,0x65,0x66,0x67,
;100:	0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,
;101:	0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,
;102:	0x78,0x79,0x7a,0x5b,0x2f,0x5d,0x5e,0x5f,
;103:	0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,
;104:	0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,
;105:	0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,
;106:	0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x7e,0x7f,
;107:	0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,
;108:	0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,
;109:	0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,
;110:	0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,
;111:	0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,
;112:	0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,
;113:	0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,
;114:	0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,
;115:	0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,
;116:	0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,
;117:	0xd0,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,
;118:	0xd8,0xd9,0xda,0xdb,0xdc,0xdd,0xde,0xdf,
;119:	0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,
;120:	0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,
;121:	0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,
;122:	0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff
;123:};
;124:
;125:uint64_t Com_GenerateHashValue( const char *fname, const uint64_t size )
;126:{
line 131
;127:	const byte *s;
;128:	uint64_t hash;
;129:	int c;
;130:
;131:	s = (byte *)fname;
ADDRLP4 8
ADDRFP4 0
INDIRP4
ASGNP4
line 132
;132:	hash = 0;
ADDRLP4 0
CNSTU4 0
ASGNU4
ADDRGP4 $50
JUMPV
LABELV $49
line 134
;133:	
;134:	while ( (c = hash_locase[(byte)*s++]) != '\0' ) {
line 135
;135:		hash = hash * 101 + c;
ADDRLP4 0
CNSTU4 101
ADDRLP4 0
INDIRU4
MULU4
ADDRLP4 4
INDIRI4
CVIU4 4
ADDU4
ASGNU4
line 136
;136:	}
LABELV $50
line 134
ADDRLP4 12
ADDRLP4 8
INDIRP4
ASGNP4
ADDRLP4 8
ADDRLP4 12
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 16
ADDRLP4 12
INDIRP4
INDIRU1
CVUI4 1
ADDRGP4 hash_locase
ADDP4
INDIRU1
CVUI4 1
ASGNI4
ADDRLP4 4
ADDRLP4 16
INDIRI4
ASGNI4
ADDRLP4 16
INDIRI4
CNSTI4 0
NEI4 $49
line 138
;137:	
;138:	hash = (hash ^ (hash >> 10) ^ (hash >> 20));
ADDRLP4 0
ADDRLP4 0
INDIRU4
ADDRLP4 0
INDIRU4
CNSTI4 10
RSHU4
BXORU4
ADDRLP4 0
INDIRU4
CNSTI4 20
RSHU4
BXORU4
ASGNU4
line 139
;139:	hash &= (size-1);
ADDRLP4 0
ADDRLP4 0
INDIRU4
ADDRFP4 4
INDIRU4
CNSTU4 1
SUBU4
BANDU4
ASGNU4
line 141
;140:
;141:	return hash;
ADDRLP4 0
INDIRU4
RETU4
LABELV $48
endproc Com_GenerateHashValue 24 0
export Com_StringContains
proc Com_StringContains 24 4
line 145
;142:}
;143:
;144:const char *Com_StringContains( const char *str1, const char *str2, uint64_t len2 )
;145:{
line 148
;146:	int64_t len, i, j;
;147:
;148:	len = strlen(str1) - len2;
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 12
ADDRGP4 strlen
CALLU4
ASGNU4
ADDRLP4 8
ADDRLP4 12
INDIRU4
ADDRFP4 8
INDIRU4
SUBU4
CVUI4 4
ASGNI4
line 149
;149:	for (i = 0; i <= len; i++, str1++) {
ADDRLP4 4
CNSTI4 0
ASGNI4
ADDRGP4 $56
JUMPV
LABELV $53
line 150
;150:		for (j = 0; str2[j]; j++) {
ADDRLP4 0
CNSTI4 0
ASGNI4
ADDRGP4 $60
JUMPV
LABELV $57
line 151
;151:			if (locase[(byte)str1[j]] != locase[(byte)str2[j]]) {
ADDRLP4 20
ADDRGP4 locase
ASGNP4
ADDRLP4 0
INDIRI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRI1
CVII4 1
CVIU4 4
CVUU1 4
CVUI4 1
ADDRLP4 20
INDIRP4
ADDP4
INDIRU1
CVUI4 1
ADDRLP4 0
INDIRI4
ADDRFP4 4
INDIRP4
ADDP4
INDIRI1
CVII4 1
CVIU4 4
CVUU1 4
CVUI4 1
ADDRLP4 20
INDIRP4
ADDP4
INDIRU1
CVUI4 1
EQI4 $61
line 152
;152:				break;
ADDRGP4 $59
JUMPV
LABELV $61
line 154
;153:			}
;154:		}
LABELV $58
line 150
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $60
ADDRLP4 0
INDIRI4
ADDRFP4 4
INDIRP4
ADDP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $57
LABELV $59
line 155
;155:		if (!str2[j]) {
ADDRLP4 0
INDIRI4
ADDRFP4 4
INDIRP4
ADDP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $63
line 156
;156:			return str1;
ADDRFP4 0
INDIRP4
RETP4
ADDRGP4 $52
JUMPV
LABELV $63
line 158
;157:		}
;158:	}
LABELV $54
line 149
ADDRLP4 4
ADDRLP4 4
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
LABELV $56
ADDRLP4 4
INDIRI4
ADDRLP4 8
INDIRI4
LEI4 $53
line 159
;159:	return NULL;
CNSTP4 0
RETP4
LABELV $52
endproc Com_StringContains 24 4
export Com_FilterExt
proc Com_FilterExt 1040 12
line 163
;160:}
;161:
;162:qboolean Com_FilterExt( const char *filter, const char *name )
;163:{
ADDRGP4 $67
JUMPV
LABELV $66
line 168
;164:	char buf[ MAX_TOKEN_CHARS ];
;165:	const char *ptr;
;166:	uint32_t i;
;167:
;168:	while ( *filter ) {
line 169
;169:		if ( *filter == '*' ) {
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 42
NEI4 $69
line 170
;170:			filter++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 171
;171:			for ( i = 0; *filter != '\0' && i < sizeof(buf)-1; i++ ) {
ADDRLP4 0
CNSTU4 0
ASGNU4
ADDRGP4 $74
JUMPV
LABELV $71
line 172
;172:				if ( *filter == '*' || *filter == '?' )
ADDRLP4 1032
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 1032
INDIRI4
CNSTI4 42
EQI4 $77
ADDRLP4 1032
INDIRI4
CNSTI4 63
NEI4 $75
LABELV $77
line 173
;173:					break;
ADDRGP4 $73
JUMPV
LABELV $75
line 174
;174:				buf[i] = *filter++;
ADDRLP4 1036
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 1036
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 0
INDIRU4
ADDRLP4 4
ADDP4
ADDRLP4 1036
INDIRP4
INDIRI1
ASGNI1
line 175
;175:			}
LABELV $72
line 171
ADDRLP4 0
ADDRLP4 0
INDIRU4
CNSTU4 1
ADDU4
ASGNU4
LABELV $74
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
EQI4 $78
ADDRLP4 0
INDIRU4
CNSTU4 1023
LTU4 $71
LABELV $78
LABELV $73
line 176
;176:			buf[ i ] = '\0';
ADDRLP4 0
INDIRU4
ADDRLP4 4
ADDP4
CNSTI1 0
ASGNI1
line 177
;177:			if ( i ) {
ADDRLP4 0
INDIRU4
CNSTU4 0
EQU4 $79
line 178
;178:				ptr = Com_StringContains( name, buf, i );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 4
ARGP4
ADDRLP4 0
INDIRU4
ARGU4
ADDRLP4 1032
ADDRGP4 Com_StringContains
CALLP4
ASGNP4
ADDRLP4 1028
ADDRLP4 1032
INDIRP4
ASGNP4
line 179
;179:				if ( !ptr )
ADDRLP4 1028
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $81
line 180
;180:					return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $65
JUMPV
LABELV $81
line 181
;181:				name = ptr + i;
ADDRFP4 4
ADDRLP4 0
INDIRU4
ADDRLP4 1028
INDIRP4
ADDP4
ASGNP4
line 182
;182:			} else if ( *filter == '\0' ) {
ADDRGP4 $70
JUMPV
LABELV $79
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $70
line 183
;183:				return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $65
JUMPV
line 185
;184:			}
;185:		}
LABELV $69
line 186
;186:		else if ( *filter == '?' ) {
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 63
NEI4 $85
line 187
;187:			if ( *name == '\0' )
ADDRFP4 4
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $87
line 188
;188:				return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $65
JUMPV
LABELV $87
line 189
;189:			filter++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 190
;190:			name++;
ADDRFP4 4
ADDRFP4 4
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 191
;191:		}
ADDRGP4 $86
JUMPV
LABELV $85
line 192
;192:		else {
line 193
;193:			if ( locase[(byte)*filter] != locase[(byte)*name] )
ADDRLP4 1032
ADDRGP4 locase
ASGNP4
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CVIU4 4
CVUU1 4
CVUI4 1
ADDRLP4 1032
INDIRP4
ADDP4
INDIRU1
CVUI4 1
ADDRFP4 4
INDIRP4
INDIRI1
CVII4 1
CVIU4 4
CVUU1 4
CVUI4 1
ADDRLP4 1032
INDIRP4
ADDP4
INDIRU1
CVUI4 1
EQI4 $89
line 194
;194:				return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $65
JUMPV
LABELV $89
line 195
;195:			filter++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 196
;196:			name++;
ADDRFP4 4
ADDRFP4 4
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 197
;197:		}
LABELV $86
LABELV $70
line 198
;198:	}
LABELV $67
line 168
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $66
line 199
;199:	if ( *name ) {
ADDRFP4 4
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
EQI4 $91
line 200
;200:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $65
JUMPV
LABELV $91
line 202
;201:	}
;202:	return qtrue;
CNSTI4 1
RETI4
LABELV $65
endproc Com_FilterExt 1040 12
export Com_Filter
proc Com_Filter 1076 12
line 207
;203:}
;204:
;205:
;206:int Com_Filter( const char *filter, const char *name )
;207:{
ADDRGP4 $95
JUMPV
LABELV $94
line 212
;208:	char buf[ MAX_TOKEN_CHARS ];
;209:	const char *ptr;
;210:	int i, found;
;211:
;212:	while (*filter) {
line 213
;213:		if (*filter == '*') {
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 42
NEI4 $97
line 214
;214:			filter++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 215
;215:			for (i = 0; *filter; i++) {
ADDRLP4 0
CNSTI4 0
ASGNI4
ADDRGP4 $102
JUMPV
LABELV $99
line 216
;216:				if (*filter == '*' || *filter == '?')
ADDRLP4 1036
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 1036
INDIRI4
CNSTI4 42
EQI4 $105
ADDRLP4 1036
INDIRI4
CNSTI4 63
NEI4 $103
LABELV $105
line 217
;217:					break;
ADDRGP4 $101
JUMPV
LABELV $103
line 218
;218:				buf[i] = *filter;
ADDRLP4 0
INDIRI4
ADDRLP4 4
ADDP4
ADDRFP4 0
INDIRP4
INDIRI1
ASGNI1
line 219
;219:				filter++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 220
;220:			}
LABELV $100
line 215
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $102
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $99
LABELV $101
line 221
;221:			buf[i] = '\0';
ADDRLP4 0
INDIRI4
ADDRLP4 4
ADDP4
CNSTI1 0
ASGNI1
line 222
;222:			if ( i ) {
ADDRLP4 0
INDIRI4
CNSTI4 0
EQI4 $98
line 223
;223:				ptr = Com_StringContains( name, buf, i );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 4
ARGP4
ADDRLP4 0
INDIRI4
CVIU4 4
ARGU4
ADDRLP4 1036
ADDRGP4 Com_StringContains
CALLP4
ASGNP4
ADDRLP4 1032
ADDRLP4 1036
INDIRP4
ASGNP4
line 224
;224:				if ( !ptr )
ADDRLP4 1032
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $108
line 225
;225:					return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $93
JUMPV
LABELV $108
line 226
;226:				name = ptr + i;
ADDRFP4 4
ADDRLP4 0
INDIRI4
ADDRLP4 1032
INDIRP4
ADDP4
ASGNP4
line 227
;227:			}
line 228
;228:		}
ADDRGP4 $98
JUMPV
LABELV $97
line 229
;229:		else if (*filter == '?') {
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 63
NEI4 $110
line 230
;230:			filter++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 231
;231:			name++;
ADDRFP4 4
ADDRFP4 4
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 232
;232:		}
ADDRGP4 $111
JUMPV
LABELV $110
line 233
;233:		else if (*filter == '[' && *(filter+1) == '[') {
ADDRLP4 1036
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 1040
CNSTI4 91
ASGNI4
ADDRLP4 1036
INDIRP4
INDIRI1
CVII4 1
ADDRLP4 1040
INDIRI4
NEI4 $112
ADDRLP4 1036
INDIRP4
CNSTI4 1
ADDP4
INDIRI1
CVII4 1
ADDRLP4 1040
INDIRI4
NEI4 $112
line 234
;234:			filter++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 235
;235:		}
ADDRGP4 $113
JUMPV
LABELV $112
line 236
;236:		else if (*filter == '[') {
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 91
NEI4 $114
line 237
;237:			filter++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 238
;238:			found = qfalse;
ADDRLP4 1028
CNSTI4 0
ASGNI4
ADDRGP4 $117
JUMPV
LABELV $116
line 239
;239:			while(*filter && !found) {
line 240
;240:				if (*filter == ']' && *(filter+1) != ']') break;
ADDRLP4 1044
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 1048
CNSTI4 93
ASGNI4
ADDRLP4 1044
INDIRP4
INDIRI1
CVII4 1
ADDRLP4 1048
INDIRI4
NEI4 $119
ADDRLP4 1044
INDIRP4
CNSTI4 1
ADDP4
INDIRI1
CVII4 1
ADDRLP4 1048
INDIRI4
EQI4 $119
ADDRGP4 $118
JUMPV
LABELV $119
line 241
;241:				if (*(filter+1) == '-' && *(filter+2) && (*(filter+2) != ']' || *(filter+3) == ']')) {
ADDRLP4 1052
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 1052
INDIRP4
CNSTI4 1
ADDP4
INDIRI1
CVII4 1
CNSTI4 45
NEI4 $121
ADDRLP4 1056
ADDRLP4 1052
INDIRP4
CNSTI4 2
ADDP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 1056
INDIRI4
CNSTI4 0
EQI4 $121
ADDRLP4 1060
CNSTI4 93
ASGNI4
ADDRLP4 1056
INDIRI4
ADDRLP4 1060
INDIRI4
NEI4 $123
ADDRLP4 1052
INDIRP4
CNSTI4 3
ADDP4
INDIRI1
CVII4 1
ADDRLP4 1060
INDIRI4
NEI4 $121
LABELV $123
line 242
;242:					if (locase[(byte)*name] >= locase[(byte)*filter] &&
ADDRLP4 1064
ADDRGP4 locase
ASGNP4
ADDRLP4 1068
ADDRFP4 4
INDIRP4
INDIRI1
CVII4 1
CVIU4 4
CVUU1 4
CVUI4 1
ADDRLP4 1064
INDIRP4
ADDP4
INDIRU1
CVUI4 1
ASGNI4
ADDRLP4 1072
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 1068
INDIRI4
ADDRLP4 1072
INDIRP4
INDIRI1
CVII4 1
CVIU4 4
CVUU1 4
CVUI4 1
ADDRLP4 1064
INDIRP4
ADDP4
INDIRU1
CVUI4 1
LTI4 $124
ADDRLP4 1068
INDIRI4
ADDRLP4 1072
INDIRP4
CNSTI4 2
ADDP4
INDIRI1
CVII4 1
CVIU4 4
CVUU1 4
CVUI4 1
ADDRLP4 1064
INDIRP4
ADDP4
INDIRU1
CVUI4 1
GTI4 $124
line 244
;243:						locase[(byte)*name] <= locase[(byte)*(filter+2)])
;244:							found = qtrue;
ADDRLP4 1028
CNSTI4 1
ASGNI4
LABELV $124
line 245
;245:					filter += 3;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 3
ADDP4
ASGNP4
line 246
;246:				}
ADDRGP4 $122
JUMPV
LABELV $121
line 247
;247:				else {
line 248
;248:					if (locase[(byte)*filter] == locase[(byte)*name])
ADDRLP4 1064
ADDRGP4 locase
ASGNP4
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CVIU4 4
CVUU1 4
CVUI4 1
ADDRLP4 1064
INDIRP4
ADDP4
INDIRU1
CVUI4 1
ADDRFP4 4
INDIRP4
INDIRI1
CVII4 1
CVIU4 4
CVUU1 4
CVUI4 1
ADDRLP4 1064
INDIRP4
ADDP4
INDIRU1
CVUI4 1
NEI4 $126
line 249
;249:						found = qtrue;
ADDRLP4 1028
CNSTI4 1
ASGNI4
LABELV $126
line 250
;250:					filter++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 251
;251:				}
LABELV $122
line 252
;252:			}
LABELV $117
line 239
ADDRLP4 1044
CNSTI4 0
ASGNI4
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ADDRLP4 1044
INDIRI4
EQI4 $128
ADDRLP4 1028
INDIRI4
ADDRLP4 1044
INDIRI4
EQI4 $116
LABELV $128
LABELV $118
line 253
;253:			if (!found) return qfalse;
ADDRLP4 1028
INDIRI4
CNSTI4 0
NEI4 $132
CNSTI4 0
RETI4
ADDRGP4 $93
JUMPV
LABELV $131
line 254
;254:			while (*filter) {
line 255
;255:				if (*filter == ']' && *(filter+1) != ']') break;
ADDRLP4 1048
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 1052
CNSTI4 93
ASGNI4
ADDRLP4 1048
INDIRP4
INDIRI1
CVII4 1
ADDRLP4 1052
INDIRI4
NEI4 $134
ADDRLP4 1048
INDIRP4
CNSTI4 1
ADDP4
INDIRI1
CVII4 1
ADDRLP4 1052
INDIRI4
EQI4 $134
ADDRGP4 $133
JUMPV
LABELV $134
line 256
;256:				filter++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 257
;257:			}
LABELV $132
line 254
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $131
LABELV $133
line 258
;258:			filter++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 259
;259:			name++;
ADDRFP4 4
ADDRFP4 4
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 260
;260:		}
ADDRGP4 $115
JUMPV
LABELV $114
line 261
;261:		else {
line 262
;262:			if (locase[(byte)*filter] != locase[(byte)*name])
ADDRLP4 1044
ADDRGP4 locase
ASGNP4
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CVIU4 4
CVUU1 4
CVUI4 1
ADDRLP4 1044
INDIRP4
ADDP4
INDIRU1
CVUI4 1
ADDRFP4 4
INDIRP4
INDIRI1
CVII4 1
CVIU4 4
CVUU1 4
CVUI4 1
ADDRLP4 1044
INDIRP4
ADDP4
INDIRU1
CVUI4 1
EQI4 $136
line 263
;263:				return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $93
JUMPV
LABELV $136
line 264
;264:			filter++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 265
;265:			name++;
ADDRFP4 4
ADDRFP4 4
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 266
;266:		}
LABELV $115
LABELV $113
LABELV $111
LABELV $98
line 267
;267:	}
LABELV $95
line 212
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $94
line 268
;268:	return qtrue;
CNSTI4 1
RETI4
LABELV $93
endproc Com_Filter 1076 12
export Com_FilterPath
proc Com_FilterPath 144 8
line 272
;269:}
;270:
;271:int Com_FilterPath( const char *filter, const char *name )
;272:{
line 277
;273:	int i;
;274:	char new_filter[MAX_GDR_PATH];
;275:	char new_name[MAX_GDR_PATH];
;276:
;277:	for (i = 0; i < MAX_GDR_PATH-1 && filter[i]; i++) {
ADDRLP4 0
CNSTI4 0
ASGNI4
ADDRGP4 $142
JUMPV
LABELV $139
line 278
;278:		if ( filter[i] == '\\' || filter[i] == ':' ) {
ADDRLP4 132
ADDRLP4 0
INDIRI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 132
INDIRI4
CNSTI4 92
EQI4 $145
ADDRLP4 132
INDIRI4
CNSTI4 58
NEI4 $143
LABELV $145
line 279
;279:			new_filter[i] = '/';
ADDRLP4 0
INDIRI4
ADDRLP4 4
ADDP4
CNSTI1 47
ASGNI1
line 280
;280:		}
ADDRGP4 $144
JUMPV
LABELV $143
line 281
;281:		else {
line 282
;282:			new_filter[i] = filter[i];
ADDRLP4 0
INDIRI4
ADDRLP4 4
ADDP4
ADDRLP4 0
INDIRI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRI1
ASGNI1
line 283
;283:		}
LABELV $144
line 284
;284:	}
LABELV $140
line 277
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $142
ADDRLP4 0
INDIRI4
CNSTI4 63
GEI4 $146
ADDRLP4 0
INDIRI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $139
LABELV $146
line 285
;285:	new_filter[i] = '\0';
ADDRLP4 0
INDIRI4
ADDRLP4 4
ADDP4
CNSTI1 0
ASGNI1
line 286
;286:	for (i = 0; i < MAX_GDR_PATH-1 && name[i]; i++) {
ADDRLP4 0
CNSTI4 0
ASGNI4
ADDRGP4 $150
JUMPV
LABELV $147
line 287
;287:		if ( name[i] == '\\' || name[i] == ':' ) {
ADDRLP4 136
ADDRLP4 0
INDIRI4
ADDRFP4 4
INDIRP4
ADDP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 136
INDIRI4
CNSTI4 92
EQI4 $153
ADDRLP4 136
INDIRI4
CNSTI4 58
NEI4 $151
LABELV $153
line 288
;288:			new_name[i] = '/';
ADDRLP4 0
INDIRI4
ADDRLP4 68
ADDP4
CNSTI1 47
ASGNI1
line 289
;289:		}
ADDRGP4 $152
JUMPV
LABELV $151
line 290
;290:		else {
line 291
;291:			new_name[i] = name[i];
ADDRLP4 0
INDIRI4
ADDRLP4 68
ADDP4
ADDRLP4 0
INDIRI4
ADDRFP4 4
INDIRP4
ADDP4
INDIRI1
ASGNI1
line 292
;292:		}
LABELV $152
line 293
;293:	}
LABELV $148
line 286
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $150
ADDRLP4 0
INDIRI4
CNSTI4 63
GEI4 $154
ADDRLP4 0
INDIRI4
ADDRFP4 4
INDIRP4
ADDP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $147
LABELV $154
line 294
;294:	new_name[i] = '\0';
ADDRLP4 0
INDIRI4
ADDRLP4 68
ADDP4
CNSTI1 0
ASGNI1
line 295
;295:	return Com_Filter( new_filter, new_name );
ADDRLP4 4
ARGP4
ADDRLP4 68
ARGP4
ADDRLP4 140
ADDRGP4 Com_Filter
CALLI4
ASGNI4
ADDRLP4 140
INDIRI4
RETI4
LABELV $138
endproc Com_FilterPath 144 8
export Com_HasPatterns
proc Com_HasPatterns 12 0
line 299
;296:}
;297:
;298:qboolean Com_HasPatterns( const char *str )
;299:{
ADDRGP4 $157
JUMPV
LABELV $156
line 302
;300:	int c;
;301:
;302:	while ( (c = *str++) != '\0' ) {
line 303
;303:		if ( c == '*' || c == '?' ) {
ADDRLP4 0
INDIRI4
CNSTI4 42
EQI4 $161
ADDRLP4 0
INDIRI4
CNSTI4 63
NEI4 $159
LABELV $161
line 304
;304:			return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $155
JUMPV
LABELV $159
line 306
;305:		}
;306:	}
LABELV $157
line 302
ADDRLP4 4
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 4
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 8
ADDRLP4 4
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 0
ADDRLP4 8
INDIRI4
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 0
NEI4 $156
line 308
;307:
;308:	return qfalse;
CNSTI4 0
RETI4
LABELV $155
endproc Com_HasPatterns 12 0
export COM_DefaultExtension
proc COM_DefaultExtension 20 12
line 320
;309:}
;310:
;311:/*
;312:==================
;313:COM_DefaultExtension
;314:
;315:if path doesn't have an extension, then append
;316: the specified one (which should include the .)
;317:==================
;318:*/
;319:void COM_DefaultExtension( char *path, uint64_t maxSize, const char *extension )
;320:{
line 321
;321:	const char *dot = (const char *)strrchr(path, '.'), *slash;
ADDRFP4 0
INDIRP4
ARGP4
CNSTI4 46
ARGI4
ADDRLP4 8
ADDRGP4 strrchr
CALLI4
ASGNI4
ADDRLP4 0
ADDRLP4 8
INDIRI4
CVIU4 4
CVUP4 4
ASGNP4
line 322
;322:	if (dot && ((slash = (const char *)strrchr(path, '/')) == NULL || slash < dot))
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $163
ADDRFP4 0
INDIRP4
ARGP4
CNSTI4 47
ARGI4
ADDRLP4 12
ADDRGP4 strrchr
CALLI4
ASGNI4
ADDRLP4 16
ADDRLP4 12
INDIRI4
CVIU4 4
CVUP4 4
ASGNP4
ADDRLP4 4
ADDRLP4 16
INDIRP4
ASGNP4
ADDRLP4 16
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $165
ADDRLP4 4
INDIRP4
CVPU4 4
ADDRLP4 0
INDIRP4
CVPU4 4
GEU4 $163
LABELV $165
line 323
;323:		return;
ADDRGP4 $162
JUMPV
LABELV $163
line 325
;324:	else
;325:		N_strcat(path, maxSize, extension);
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRU4
ARGU4
ADDRFP4 8
INDIRP4
ARGP4
ADDRGP4 N_strcat
CALLV
pop
line 326
;326:}
LABELV $162
endproc COM_DefaultExtension 20 12
export COM_StripExtension
proc COM_StripExtension 24 12
line 330
;327:
;328:
;329:void COM_StripExtension(const char *in, char *out, uint64_t destsize)
;330:{
line 331
;331:	const char *dot = (char *)strrchr(in, '.'), *slash;
ADDRFP4 0
INDIRP4
ARGP4
CNSTI4 46
ARGI4
ADDRLP4 8
ADDRGP4 strrchr
CALLI4
ASGNI4
ADDRLP4 0
ADDRLP4 8
INDIRI4
CVIU4 4
CVUP4 4
ASGNP4
line 333
;332:
;333:	if (dot && ((slash = (char *)strrchr(in, '/')) == NULL || slash < dot))
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $167
ADDRFP4 0
INDIRP4
ARGP4
CNSTI4 47
ARGI4
ADDRLP4 12
ADDRGP4 strrchr
CALLI4
ASGNI4
ADDRLP4 16
ADDRLP4 12
INDIRI4
CVIU4 4
CVUP4 4
ASGNP4
ADDRLP4 4
ADDRLP4 16
INDIRP4
ASGNP4
ADDRLP4 16
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $169
ADDRLP4 4
INDIRP4
CVPU4 4
ADDRLP4 0
INDIRP4
CVPU4 4
GEU4 $167
LABELV $169
line 334
;334:		destsize = (destsize < dot-in+1 ? destsize : dot-in+1);
ADDRFP4 8
INDIRU4
ADDRLP4 0
INDIRP4
CVPU4 4
ADDRFP4 0
INDIRP4
CVPU4 4
SUBU4
CVUI4 4
CNSTI4 1
ADDI4
CVIU4 4
GEU4 $171
ADDRLP4 20
ADDRFP4 8
INDIRU4
ASGNU4
ADDRGP4 $172
JUMPV
LABELV $171
ADDRLP4 20
ADDRLP4 0
INDIRP4
CVPU4 4
ADDRFP4 0
INDIRP4
CVPU4 4
SUBU4
CVUI4 4
CNSTI4 1
ADDI4
CVIU4 4
ASGNU4
LABELV $172
ADDRFP4 8
ADDRLP4 20
INDIRU4
ASGNU4
LABELV $167
line 336
;335:
;336:	if ( in == out && destsize > 1 )
ADDRFP4 0
INDIRP4
CVPU4 4
ADDRFP4 4
INDIRP4
CVPU4 4
NEU4 $173
ADDRFP4 8
INDIRU4
CNSTU4 1
LEU4 $173
line 337
;337:		out[destsize-1] = '\0';
ADDRFP4 8
INDIRU4
CNSTU4 1
SUBU4
ADDRFP4 4
INDIRP4
ADDP4
CNSTI1 0
ASGNI1
ADDRGP4 $174
JUMPV
LABELV $173
line 339
;338:	else
;339:		N_strncpy(out, in, destsize);
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 8
INDIRU4
ARGU4
ADDRGP4 N_strncpy
CALLV
pop
LABELV $174
line 340
;340:}
LABELV $166
endproc COM_StripExtension 24 12
export Com_Split
proc Com_Split 20 0
line 348
;341:
;342:/*
;343:============
;344:Com_Split
;345:============
;346:*/
;347:int Com_Split( char *in, char **out, uint64_t outsz, int delim )
;348:{
line 350
;349:	int c;
;350:	char **o = out, **end = out + outsz;
ADDRLP4 8
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 4
ADDRFP4 8
INDIRU4
CNSTI4 2
LSHU4
ADDRFP4 4
INDIRP4
ADDP4
ASGNP4
line 352
;351:	// skip leading spaces
;352:	if ( delim >= ' ' ) {
ADDRFP4 12
INDIRI4
CNSTI4 32
LTI4 $176
ADDRGP4 $179
JUMPV
LABELV $178
line 354
;353:		while( (c = *in) != '\0' && c <= ' ' )
;354:			in++; 
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
LABELV $179
line 353
ADDRLP4 12
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 0
ADDRLP4 12
INDIRI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 0
EQI4 $181
ADDRLP4 0
INDIRI4
CNSTI4 32
LEI4 $178
LABELV $181
line 355
;355:	}
LABELV $176
line 356
;356:	*out = in; out++;
ADDRFP4 4
INDIRP4
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 4
ADDRFP4 4
INDIRP4
CNSTI4 4
ADDP4
ASGNP4
ADDRGP4 $183
JUMPV
line 357
;357:	while( out < end ) {
LABELV $185
line 359
;358:		while( (c = *in) != '\0' && c != delim )
;359:			in++; 
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
LABELV $186
line 358
ADDRLP4 12
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 0
ADDRLP4 12
INDIRI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 0
EQI4 $188
ADDRLP4 0
INDIRI4
ADDRFP4 12
INDIRI4
NEI4 $185
LABELV $188
line 360
;360:		*in = '\0';
ADDRFP4 0
INDIRP4
CNSTI1 0
ASGNI1
line 361
;361:		if ( !c ) {
ADDRLP4 0
INDIRI4
CNSTI4 0
NEI4 $189
line 363
;362:			// don't count last null value
;363:			if ( out[-1][0] == '\0' )
ADDRFP4 4
INDIRP4
CNSTI4 -4
ADDP4
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $200
line 364
;364:				out--;
ADDRFP4 4
ADDRFP4 4
INDIRP4
CNSTI4 -4
ADDP4
ASGNP4
line 365
;365:			break;
ADDRGP4 $200
JUMPV
LABELV $189
line 367
;366:		}
;367:		in++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 369
;368:		// skip leading spaces
;369:		if ( delim >= ' ' ) {
ADDRFP4 12
INDIRI4
CNSTI4 32
LTI4 $193
ADDRGP4 $196
JUMPV
LABELV $195
line 371
;370:			while( (c = *in) != '\0' && c <= ' ' )
;371:				in++; 
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
LABELV $196
line 370
ADDRLP4 16
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 0
ADDRLP4 16
INDIRI4
ASGNI4
ADDRLP4 16
INDIRI4
CNSTI4 0
EQI4 $198
ADDRLP4 0
INDIRI4
CNSTI4 32
LEI4 $195
LABELV $198
line 372
;372:		}
LABELV $193
line 373
;373:		*out = in; out++;
ADDRFP4 4
INDIRP4
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 4
ADDRFP4 4
INDIRP4
CNSTI4 4
ADDP4
ASGNP4
line 374
;374:	}
LABELV $183
line 357
ADDRFP4 4
INDIRP4
CVPU4 4
ADDRLP4 4
INDIRP4
CVPU4 4
LTU4 $186
ADDRGP4 $200
JUMPV
LABELV $199
line 377
;375:	// sanitize last value
;376:	while( (c = *in) != '\0' && c != delim )
;377:		in++; 
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
LABELV $200
line 376
ADDRLP4 12
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 0
ADDRLP4 12
INDIRI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 0
EQI4 $202
ADDRLP4 0
INDIRI4
ADDRFP4 12
INDIRI4
NEI4 $199
LABELV $202
line 378
;378:	*in = '\0';
ADDRFP4 0
INDIRP4
CNSTI1 0
ASGNI1
line 379
;379:	c = out - o;
ADDRLP4 0
ADDRFP4 4
INDIRP4
CVPU4 4
ADDRLP4 8
INDIRP4
CVPU4 4
SUBU4
CVUI4 4
CNSTI4 4
DIVI4
ASGNI4
ADDRGP4 $204
JUMPV
LABELV $203
line 381
;380:	// set remaining out pointers
;381:	while( out < end ) {
line 382
;382:		*out = in; out++;
ADDRFP4 4
INDIRP4
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 4
ADDRFP4 4
INDIRP4
CNSTI4 4
ADDP4
ASGNP4
line 383
;383:	}
LABELV $204
line 381
ADDRFP4 4
INDIRP4
CVPU4 4
ADDRLP4 4
INDIRP4
CVPU4 4
LTU4 $203
line 384
;384:	return c;
ADDRLP4 0
INDIRI4
RETI4
LABELV $175
endproc Com_Split 20 0
export CopyShortSwap
proc CopyShortSwap 8 0
line 389
;385:}
;386:
;387:
;388:void CopyShortSwap(void *dest, void *src)
;389:{
line 390
;390:	byte *to = (byte *)dest, *from = (byte *)src;
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 4
ADDRFP4 4
INDIRP4
ASGNP4
line 392
;391:
;392:	to[0] = from[1];
ADDRLP4 0
INDIRP4
ADDRLP4 4
INDIRP4
CNSTI4 1
ADDP4
INDIRU1
ASGNU1
line 393
;393:	to[1] = from[0];
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ADDRLP4 4
INDIRP4
INDIRU1
ASGNU1
line 394
;394:}
LABELV $206
endproc CopyShortSwap 8 0
export CopyIntSwap
proc CopyIntSwap 8 0
line 397
;395:
;396:void CopyIntSwap(void *dest, void *src)
;397:{
line 398
;398:	byte *to = (byte *)dest, *from = (byte *)src;
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 4
ADDRFP4 4
INDIRP4
ASGNP4
line 400
;399:
;400:	to[0] = from[3];
ADDRLP4 0
INDIRP4
ADDRLP4 4
INDIRP4
CNSTI4 3
ADDP4
INDIRU1
ASGNU1
line 401
;401:	to[1] = from[2];
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ADDRLP4 4
INDIRP4
CNSTI4 2
ADDP4
INDIRU1
ASGNU1
line 402
;402:	to[2] = from[1];
ADDRLP4 0
INDIRP4
CNSTI4 2
ADDP4
ADDRLP4 4
INDIRP4
CNSTI4 1
ADDP4
INDIRU1
ASGNU1
line 403
;403:	to[3] = from[0];
ADDRLP4 0
INDIRP4
CNSTI4 3
ADDP4
ADDRLP4 4
INDIRP4
INDIRU1
ASGNU1
line 404
;404:}
LABELV $207
endproc CopyIntSwap 8 0
export CopyLongSwap
proc CopyLongSwap 8 0
line 407
;405:
;406:void CopyLongSwap(void *dest, void *src)
;407:{
line 408
;408:	byte *to = (byte *)dest, *from = (byte *)src;
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 4
ADDRFP4 4
INDIRP4
ASGNP4
line 410
;409:
;410:	to[0] = from[7];
ADDRLP4 0
INDIRP4
ADDRLP4 4
INDIRP4
CNSTI4 7
ADDP4
INDIRU1
ASGNU1
line 411
;411:	to[1] = from[6];
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ADDRLP4 4
INDIRP4
CNSTI4 6
ADDP4
INDIRU1
ASGNU1
line 412
;412:	to[2] = from[5];
ADDRLP4 0
INDIRP4
CNSTI4 2
ADDP4
ADDRLP4 4
INDIRP4
CNSTI4 5
ADDP4
INDIRU1
ASGNU1
line 413
;413:	to[3] = from[4];
ADDRLP4 0
INDIRP4
CNSTI4 3
ADDP4
ADDRLP4 4
INDIRP4
CNSTI4 4
ADDP4
INDIRU1
ASGNU1
line 414
;414:	to[4] = from[3];
ADDRLP4 0
INDIRP4
CNSTI4 4
ADDP4
ADDRLP4 4
INDIRP4
CNSTI4 3
ADDP4
INDIRU1
ASGNU1
line 415
;415:	to[5] = from[2];
ADDRLP4 0
INDIRP4
CNSTI4 5
ADDP4
ADDRLP4 4
INDIRP4
CNSTI4 2
ADDP4
INDIRU1
ASGNU1
line 416
;416:	to[6] = from[1];
ADDRLP4 0
INDIRP4
CNSTI4 6
ADDP4
ADDRLP4 4
INDIRP4
CNSTI4 1
ADDP4
INDIRU1
ASGNU1
line 417
;417:	to[7] = from[0];
ADDRLP4 0
INDIRP4
CNSTI4 7
ADDP4
ADDRLP4 4
INDIRP4
INDIRU1
ASGNU1
line 418
;418:}
LABELV $208
endproc CopyLongSwap 8 0
export N_memset
proc N_memset 8 0
line 429
;419:
;420:/*
;421:=====================================================================
;422:
;423:Library Replacement Functions
;424:
;425:=====================================================================
;426:*/
;427:
;428:void* N_memset (void *dest, int fill, size_t count)
;429:{
line 432
;430:	size_t i;
;431:	
;432:	if ( (((uintptr_t)dest | count) & 3) == 0) {
ADDRFP4 0
INDIRP4
CVPU4 4
ADDRFP4 8
INDIRU4
BORU4
CNSTU4 3
BANDU4
CNSTU4 0
NEU4 $210
line 433
;433:		count >>= 2;
ADDRFP4 8
ADDRFP4 8
INDIRU4
CNSTI4 2
RSHU4
ASGNU4
line 434
;434:		fill = fill | (fill<<8) | (fill<<16) | (fill<<24);
ADDRLP4 4
ADDRFP4 4
INDIRI4
ASGNI4
ADDRFP4 4
ADDRLP4 4
INDIRI4
ADDRLP4 4
INDIRI4
CNSTI4 8
LSHI4
BORI4
ADDRLP4 4
INDIRI4
CNSTI4 16
LSHI4
BORI4
ADDRLP4 4
INDIRI4
CNSTI4 24
LSHI4
BORI4
ASGNI4
line 435
;435:		for (i = 0; i < count; i++)
ADDRLP4 0
CNSTU4 0
ASGNU4
ADDRGP4 $215
JUMPV
LABELV $212
line 436
;436:			((int *)dest)[i] = fill;
ADDRLP4 0
INDIRU4
CNSTI4 2
LSHU4
ADDRFP4 0
INDIRP4
ADDP4
ADDRFP4 4
INDIRI4
ASGNI4
LABELV $213
line 435
ADDRLP4 0
ADDRLP4 0
INDIRU4
CNSTU4 1
ADDU4
ASGNU4
LABELV $215
ADDRLP4 0
INDIRU4
ADDRFP4 8
INDIRU4
LTU4 $212
line 437
;437:	}
ADDRGP4 $211
JUMPV
LABELV $210
line 439
;438:	else
;439:		for (i = 0; i < count; i++)
ADDRLP4 0
CNSTU4 0
ASGNU4
ADDRGP4 $219
JUMPV
LABELV $216
line 440
;440:			((char *)dest)[i] = fill;
ADDRLP4 0
INDIRU4
ADDRFP4 0
INDIRP4
ADDP4
ADDRFP4 4
INDIRI4
CVII1 4
ASGNI1
LABELV $217
line 439
ADDRLP4 0
ADDRLP4 0
INDIRU4
CNSTU4 1
ADDU4
ASGNU4
LABELV $219
ADDRLP4 0
INDIRU4
ADDRFP4 8
INDIRU4
LTU4 $216
LABELV $211
line 442
;441:    
;442:    return dest;
ADDRFP4 0
INDIRP4
RETP4
LABELV $209
endproc N_memset 8 0
export N_memchr
proc N_memchr 4 0
line 446
;443:}
;444:
;445:void* N_memchr (void *ptr, int c, size_t count)
;446:{
ADDRGP4 $222
JUMPV
LABELV $221
line 447
;447:	while (--count) {
line 448
;448:		if (((char *)ptr)[count] == c)
ADDRFP4 8
INDIRU4
ADDRFP4 0
INDIRP4
ADDP4
INDIRI1
CVII4 1
ADDRFP4 4
INDIRI4
NEI4 $224
line 449
;449:			return (void *)&((char *)ptr)[count];
ADDRFP4 8
INDIRU4
ADDRFP4 0
INDIRP4
ADDP4
RETP4
ADDRGP4 $220
JUMPV
LABELV $224
line 450
;450:	}
LABELV $222
line 447
ADDRLP4 0
ADDRFP4 8
INDIRU4
CNSTU4 1
SUBU4
ASGNU4
ADDRFP4 8
ADDRLP4 0
INDIRU4
ASGNU4
ADDRLP4 0
INDIRU4
CNSTU4 0
NEU4 $221
line 451
;451:	return NULL;
CNSTP4 0
RETP4
LABELV $220
endproc N_memchr 4 0
export N_memcpy
proc N_memcpy 8 0
line 455
;452:}
;453:
;454:void N_memcpy (void *dest, const void *src, size_t count)
;455:{
line 457
;456:	size_t i;
;457:	if (( ( (uintptr_t)dest | (uintptr_t)src | count) & 7) == 0) {
ADDRFP4 0
INDIRP4
CVPU4 4
ADDRFP4 4
INDIRP4
CVPU4 4
BORU4
ADDRFP4 8
INDIRU4
BORU4
CNSTU4 7
BANDU4
CNSTU4 0
NEU4 $227
ADDRGP4 $230
JUMPV
LABELV $229
line 458
;458:		while (count >= 4) {
line 459
;459:			((intptr_t *)dest)[count] = ((intptr_t *)src)[count];
ADDRLP4 4
ADDRFP4 8
INDIRU4
CNSTI4 2
LSHU4
ASGNU4
ADDRLP4 4
INDIRU4
ADDRFP4 0
INDIRP4
ADDP4
ADDRLP4 4
INDIRU4
ADDRFP4 4
INDIRP4
ADDP4
INDIRI4
ASGNI4
line 460
;460:			count -= 4;
ADDRFP4 8
ADDRFP4 8
INDIRU4
CNSTU4 4
SUBU4
ASGNU4
line 461
;461:		}
LABELV $230
line 458
ADDRFP4 8
INDIRU4
CNSTU4 4
GEU4 $229
line 462
;462:	}
ADDRGP4 $228
JUMPV
LABELV $227
line 463
;463:	else if (( ( (uintptr_t)dest | (uintptr_t)src | count) & 3) == 0 ) {
ADDRFP4 0
INDIRP4
CVPU4 4
ADDRFP4 4
INDIRP4
CVPU4 4
BORU4
ADDRFP4 8
INDIRU4
BORU4
CNSTU4 3
BANDU4
CNSTU4 0
NEU4 $232
line 464
;464:		count>>=2;
ADDRFP4 8
ADDRFP4 8
INDIRU4
CNSTI4 2
RSHU4
ASGNU4
line 465
;465:		for (i = 0; i < count; i++)
ADDRLP4 0
CNSTU4 0
ASGNU4
ADDRGP4 $237
JUMPV
LABELV $234
line 466
;466:			((int *)dest)[i] = ((int *)src)[i];
ADDRLP4 4
ADDRLP4 0
INDIRU4
CNSTI4 2
LSHU4
ASGNU4
ADDRLP4 4
INDIRU4
ADDRFP4 0
INDIRP4
ADDP4
ADDRLP4 4
INDIRU4
ADDRFP4 4
INDIRP4
ADDP4
INDIRI4
ASGNI4
LABELV $235
line 465
ADDRLP4 0
ADDRLP4 0
INDIRU4
CNSTU4 1
ADDU4
ASGNU4
LABELV $237
ADDRLP4 0
INDIRU4
ADDRFP4 8
INDIRU4
LTU4 $234
line 467
;467:	}
ADDRGP4 $233
JUMPV
LABELV $232
line 469
;468:	else
;469:		for (i = 0; i < count; i++)
ADDRLP4 0
CNSTU4 0
ASGNU4
ADDRGP4 $241
JUMPV
LABELV $238
line 470
;470:			((char *)dest)[i] = ((char *)src)[i];
ADDRLP4 0
INDIRU4
ADDRFP4 0
INDIRP4
ADDP4
ADDRLP4 0
INDIRU4
ADDRFP4 4
INDIRP4
ADDP4
INDIRI1
ASGNI1
LABELV $239
line 469
ADDRLP4 0
ADDRLP4 0
INDIRU4
CNSTU4 1
ADDU4
ASGNU4
LABELV $241
ADDRLP4 0
INDIRU4
ADDRFP4 8
INDIRU4
LTU4 $238
LABELV $233
LABELV $228
line 471
;471:}
LABELV $226
endproc N_memcpy 8 0
export N_memcmp
proc N_memcmp 4 0
line 474
;472:
;473:int N_memcmp (const void *ptr1, const void *ptr2, size_t count)
;474:{
ADDRGP4 $244
JUMPV
LABELV $243
line 475
;475:	while (count--) {
line 476
;476:		if (((char *)ptr1)[count] != ((char *)ptr2)[count])
ADDRLP4 0
ADDRFP4 8
INDIRU4
ASGNU4
ADDRLP4 0
INDIRU4
ADDRFP4 0
INDIRP4
ADDP4
INDIRI1
CVII4 1
ADDRLP4 0
INDIRU4
ADDRFP4 4
INDIRP4
ADDP4
INDIRI1
CVII4 1
EQI4 $246
line 477
;477:			return -1;
CNSTI4 -1
RETI4
ADDRGP4 $242
JUMPV
LABELV $246
line 478
;478:	}
LABELV $244
line 475
ADDRLP4 0
ADDRFP4 8
INDIRU4
ASGNU4
ADDRFP4 8
ADDRLP4 0
INDIRU4
CNSTU4 1
SUBU4
ASGNU4
ADDRLP4 0
INDIRU4
CNSTU4 0
NEU4 $243
line 479
;479:	return 1;
CNSTI4 1
RETI4
LABELV $242
endproc N_memcmp 4 0
export N_isprint
proc N_isprint 4 0
line 515
;480:}
;481:
;482:
;483:#ifdef _WIN32
;484:/*
;485:=============
;486:N_vsnprintf
;487: 
;488:Special wrapper function for Microsoft's broken _vsnprintf() function. mingw-w64
;489:however, uses Microsoft's broken _vsnprintf() function.
;490:=============
;491:*/
;492:int N_vsnprintf( char *str, size_t size, const char *format, va_list ap )
;493:{
;494:	int retval;
;495:	
;496:	retval = _vsnprintf( str, size, format, ap );
;497:
;498:	if ( retval < 0 || (size_t)retval == size ) {
;499:		// Microsoft doesn't adhere to the C99 standard of vsnprintf,
;500:		// which states that the return value must be the number of
;501:		// bytes written if the output string had sufficient length.
;502:		//
;503:		// Obviously we cannot determine that value from Microsoft's
;504:		// implementation, so we have no choice but to return size.
;505:		
;506:		str[size - 1] = '\0';
;507:		return size;
;508:	}
;509:	
;510:	return retval;
;511:}
;512:#endif
;513:
;514:int N_isprint( int c )
;515:{
line 516
;516:	if ( c >= 0x20 && c <= 0x7E )
ADDRLP4 0
ADDRFP4 0
INDIRI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 32
LTI4 $249
ADDRLP4 0
INDIRI4
CNSTI4 126
GTI4 $249
line 517
;517:		return ( 1 );
CNSTI4 1
RETI4
ADDRGP4 $248
JUMPV
LABELV $249
line 518
;518:	return ( 0 );
CNSTI4 0
RETI4
LABELV $248
endproc N_isprint 4 0
export N_islower
proc N_islower 4 0
line 523
;519:}
;520:
;521:
;522:int N_islower( int c )
;523:{
line 524
;524:	if (c >= 'a' && c <= 'z')
ADDRLP4 0
ADDRFP4 0
INDIRI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 97
LTI4 $252
ADDRLP4 0
INDIRI4
CNSTI4 122
GTI4 $252
line 525
;525:		return ( 1 );
CNSTI4 1
RETI4
ADDRGP4 $251
JUMPV
LABELV $252
line 526
;526:	return ( 0 );
CNSTI4 0
RETI4
LABELV $251
endproc N_islower 4 0
export N_isupper
proc N_isupper 4 0
line 531
;527:}
;528:
;529:
;530:int N_isupper( int c )
;531:{
line 532
;532:	if (c >= 'A' && c <= 'Z')
ADDRLP4 0
ADDRFP4 0
INDIRI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 65
LTI4 $255
ADDRLP4 0
INDIRI4
CNSTI4 90
GTI4 $255
line 533
;533:		return ( 1 );
CNSTI4 1
RETI4
ADDRGP4 $254
JUMPV
LABELV $255
line 534
;534:	return ( 0 );
CNSTI4 0
RETI4
LABELV $254
endproc N_isupper 4 0
export N_isalpha
proc N_isalpha 8 0
line 539
;535:}
;536:
;537:
;538:int N_isalpha( int c )
;539:{
line 540
;540:	if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'))
ADDRLP4 0
ADDRFP4 0
INDIRI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 97
LTI4 $261
ADDRLP4 0
INDIRI4
CNSTI4 122
LEI4 $260
LABELV $261
ADDRLP4 4
ADDRFP4 0
INDIRI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 65
LTI4 $258
ADDRLP4 4
INDIRI4
CNSTI4 90
GTI4 $258
LABELV $260
line 541
;541:		return ( 1 );
CNSTI4 1
RETI4
ADDRGP4 $257
JUMPV
LABELV $258
line 542
;542:	return ( 0 );
CNSTI4 0
RETI4
LABELV $257
endproc N_isalpha 8 0
export N_isintegral
proc N_isintegral 8 0
line 546
;543:}
;544:
;545:qboolean N_isintegral(float f)
;546:{
line 547
;547:	return (qboolean)((int)f == f);
ADDRLP4 4
ADDRFP4 0
INDIRF4
ASGNF4
ADDRLP4 4
INDIRF4
CVFI4 4
CVIF4 4
ADDRLP4 4
INDIRF4
NEF4 $264
ADDRLP4 0
CNSTI4 1
ASGNI4
ADDRGP4 $265
JUMPV
LABELV $264
ADDRLP4 0
CNSTI4 0
ASGNI4
LABELV $265
ADDRLP4 0
INDIRI4
RETI4
LABELV $262
endproc N_isintegral 8 0
export N_isanumber
proc N_isanumber 0 0
line 552
;548:}
;549:
;550:
;551:qboolean N_isanumber( const char *s )
;552:{
line 555
;553:#ifdef Q3_VM
;554:    //FIXME: implement
;555:    return qfalse;
CNSTI4 0
RETI4
LABELV $266
endproc N_isanumber 0 0
export N_strcpy
proc N_strcpy 24 0
line 570
;556:#else
;557:    char *p;
;558:
;559:	if( *s == '\0' )
;560:        return qfalse;
;561:
;562:	strtod( s, &p );
;563:
;564:    return (qboolean)(*p == '\0');
;565:#endif
;566:}
;567:
;568:
;569:void N_strcpy (char *dest, const char *src)
;570:{
line 571
;571:	char *d = dest;
ADDRLP4 4
ADDRFP4 0
INDIRP4
ASGNP4
line 572
;572:	const char *s = src;
ADDRLP4 0
ADDRFP4 4
INDIRP4
ASGNP4
ADDRGP4 $269
JUMPV
LABELV $268
line 574
;573:	while (*s)
;574:		*d++ = *s++;
ADDRLP4 8
ADDRLP4 4
INDIRP4
ASGNP4
ADDRLP4 16
CNSTI4 1
ASGNI4
ADDRLP4 4
ADDRLP4 8
INDIRP4
ADDRLP4 16
INDIRI4
ADDP4
ASGNP4
ADDRLP4 12
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 12
INDIRP4
ADDRLP4 16
INDIRI4
ADDP4
ASGNP4
ADDRLP4 8
INDIRP4
ADDRLP4 12
INDIRP4
INDIRI1
ASGNI1
LABELV $269
line 573
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $268
line 576
;575:	
;576:	*d++ = 0;
ADDRLP4 20
ADDRLP4 4
INDIRP4
ASGNP4
ADDRLP4 4
ADDRLP4 20
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 20
INDIRP4
CNSTI1 0
ASGNI1
line 577
;577:}
LABELV $267
endproc N_strcpy 24 0
export Com_TruncateLongString
proc Com_TruncateLongString 8 12
line 580
;578:
;579:void Com_TruncateLongString( char *buffer, const char *s )
;580:{
line 581
;581:	uint64_t length = strlen( s );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 4
ADDRGP4 strlen
CALLU4
ASGNU4
ADDRLP4 0
ADDRLP4 4
INDIRU4
ASGNU4
line 583
;582:
;583:	if( length <= TRUNCATE_LENGTH )
ADDRLP4 0
INDIRU4
CNSTU4 64
GTU4 $272
line 584
;584:		N_strncpyz( buffer, s, TRUNCATE_LENGTH );
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
CNSTU4 64
ARGU4
ADDRGP4 N_strncpyz
CALLV
pop
ADDRGP4 $273
JUMPV
LABELV $272
line 585
;585:	else {
line 586
;586:		N_strncpyz( buffer, s, ( TRUNCATE_LENGTH / 2 ) - 3 );
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
CNSTU4 29
ARGU4
ADDRGP4 N_strncpyz
CALLV
pop
line 587
;587:		N_strcat( buffer, TRUNCATE_LENGTH, " ... " );
ADDRFP4 0
INDIRP4
ARGP4
CNSTU4 64
ARGU4
ADDRGP4 $274
ARGP4
ADDRGP4 N_strcat
CALLV
pop
line 588
;588:		N_strcat( buffer, TRUNCATE_LENGTH, s + length - ( TRUNCATE_LENGTH / 2 ) + 3 );
ADDRFP4 0
INDIRP4
ARGP4
CNSTU4 64
ARGU4
ADDRLP4 0
INDIRU4
ADDRFP4 4
INDIRP4
ADDP4
CNSTI4 -29
ADDP4
ARGP4
ADDRGP4 N_strcat
CALLV
pop
line 589
;589:	}
LABELV $273
line 590
;590:}
LABELV $271
endproc Com_TruncateLongString 8 12
export N_strncpyz
proc N_strncpyz 0 12
line 594
;591:
;592:
;593:void N_strncpyz (char *dest, const char *src, size_t count)
;594:{
line 595
;595:	if (!dest)
ADDRFP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $276
line 596
;596:		N_Error(ERR_FATAL, "N_strncpyz: NULL dest");
CNSTI4 0
ARGI4
ADDRGP4 $278
ARGP4
ADDRGP4 N_Error
CALLV
pop
LABELV $276
line 597
;597:	if (!src)
ADDRFP4 4
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $279
line 598
;598:		N_Error(ERR_FATAL, "N_strncpyz: NULL src");
CNSTI4 0
ARGI4
ADDRGP4 $281
ARGP4
ADDRGP4 N_Error
CALLV
pop
LABELV $279
line 599
;599:	if (count < 1)
ADDRFP4 8
INDIRU4
CNSTU4 1
GEU4 $282
line 600
;600:		N_Error(ERR_FATAL, "N_strncpyz: bad count");
CNSTI4 0
ARGI4
ADDRGP4 $284
ARGP4
ADDRGP4 N_Error
CALLV
pop
LABELV $282
line 610
;601:	
;602:#if 0 // [glnomad] this ain't quake 3
;603:	// do not fill whole remaining buffer with zeros
;604:	// this is obvious behavior change but actually it may affect only buggy QVMs
;605:	// which passes overlapping or short buffers to cvar reading routines
;606:	// what is rather good than bad because it will no longer cause overwrites, maybe
;607:	while ( --count > 0 && (*dest++ = *src++) != '\0' );
;608:	*dest = '\0';
;609:#else
;610:	strncpy( dest, src, count-1 );
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRU4
CNSTU4 1
SUBU4
ARGU4
ADDRGP4 strncpy
CALLI4
pop
line 611
;611:	dest[ count-1 ] = '\0';
ADDRFP4 8
INDIRU4
CNSTU4 1
SUBU4
ADDRFP4 0
INDIRP4
ADDP4
CNSTI1 0
ASGNI1
line 613
;612:#endif
;613:}
LABELV $275
endproc N_strncpyz 0 12
export N_strncpy
proc N_strncpy 20 0
line 616
;614:
;615:void N_strncpy (char *dest, const char *src, size_t count)
;616:{
ADDRGP4 $287
JUMPV
LABELV $286
line 618
;617:	while (*src && count--)
;618:		*dest++ = *src++;
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 8
CNSTI4 1
ASGNI4
ADDRFP4 0
ADDRLP4 0
INDIRP4
ADDRLP4 8
INDIRI4
ADDP4
ASGNP4
ADDRLP4 4
ADDRFP4 4
INDIRP4
ASGNP4
ADDRFP4 4
ADDRLP4 4
INDIRP4
ADDRLP4 8
INDIRI4
ADDP4
ASGNP4
ADDRLP4 0
INDIRP4
ADDRLP4 4
INDIRP4
INDIRI1
ASGNI1
LABELV $287
line 617
ADDRFP4 4
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
EQI4 $289
ADDRLP4 12
ADDRFP4 8
INDIRU4
ASGNU4
ADDRFP4 8
ADDRLP4 12
INDIRU4
CNSTU4 1
SUBU4
ASGNU4
ADDRLP4 12
INDIRU4
CNSTU4 0
NEU4 $286
LABELV $289
line 620
;619:
;620:	if (count)
ADDRFP4 8
INDIRU4
CNSTU4 0
EQU4 $290
line 621
;621:		*dest++ = 0;
ADDRLP4 16
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 16
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 16
INDIRP4
CNSTI1 0
ASGNI1
LABELV $290
line 622
;622:}
LABELV $285
endproc N_strncpy 20 0
proc Com_CharIsOneOfCharset 12 4
ADDRFP4 0
ADDRFP4 0
INDIRI4
CVII1 4
ASGNI1
line 630
;623:
;624:/*
;625:==================
;626:Com_CharIsOneOfCharset
;627:==================
;628:*/
;629:static qboolean Com_CharIsOneOfCharset( char c, const char *set )
;630:{
line 631
;631:	uint64_t i, n = (uint64_t)(strlen(set));
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 8
ADDRGP4 strlen
CALLU4
ASGNU4
ADDRLP4 4
ADDRLP4 8
INDIRU4
ASGNU4
line 633
;632:
;633:	for( i = 0; i < n; i++ ) {
ADDRLP4 0
CNSTU4 0
ASGNU4
ADDRGP4 $296
JUMPV
LABELV $293
line 634
;634:		if( set[ i ] == c )
ADDRLP4 0
INDIRU4
ADDRFP4 4
INDIRP4
ADDP4
INDIRI1
CVII4 1
ADDRFP4 0
INDIRI1
CVII4 1
NEI4 $297
line 635
;635:			return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $292
JUMPV
LABELV $297
line 636
;636:	}
LABELV $294
line 633
ADDRLP4 0
ADDRLP4 0
INDIRU4
CNSTU4 1
ADDU4
ASGNU4
LABELV $296
ADDRLP4 0
INDIRU4
ADDRLP4 4
INDIRU4
LTU4 $293
line 638
;637:
;638:	return qfalse;
CNSTI4 0
RETI4
LABELV $292
endproc Com_CharIsOneOfCharset 12 4
export Com_SkipCharset
proc Com_SkipCharset 8 8
line 647
;639:}
;640:
;641:/*
;642:==================
;643:Com_SkipCharset
;644:==================
;645:*/
;646:const char *Com_SkipCharset( const char *s, const char *sep )
;647:{
line 648
;648:	const char	*p = s;
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
ADDRGP4 $301
JUMPV
LABELV $300
line 650
;649:
;650:	while( p ) {
line 651
;651:		if( Com_CharIsOneOfCharset( *p, sep ) )
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
ARGI4
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 4
ADDRGP4 Com_CharIsOneOfCharset
CALLI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $302
line 652
;652:			p++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 654
;653:		else
;654:			break;
LABELV $304
line 655
;655:	}
LABELV $301
line 650
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $300
LABELV $302
line 657
;656:
;657:	return p;
ADDRLP4 0
INDIRP4
RETP4
LABELV $299
endproc Com_SkipCharset 8 8
data
align 4
LABELV $306
byte 4 0
bss
align 1
LABELV $307
skip 64000
export va
code
proc va 12 12
line 665
;658:}
;659:
;660:
;661:/*
;662:Not thread safe
;663:*/
;664:const char* GDR_ATTRIBUTE((format(printf, 1, 2))) GDR_DECL va(const char *format, ...)
;665:{
line 671
;666:	char *buf;
;667:	va_list argptr;
;668:	static uint32_t index = 0;
;669:	static char string[2][32000];	// in case va is called by nested functions
;670:
;671:	buf = string[ index ];
ADDRLP4 0
CNSTU4 32000
ADDRGP4 $306
INDIRU4
MULU4
ADDRGP4 $307
ADDP4
ASGNP4
line 672
;672:	index ^= 1;
ADDRLP4 8
ADDRGP4 $306
ASGNP4
ADDRLP4 8
INDIRP4
ADDRLP4 8
INDIRP4
INDIRU4
CNSTU4 1
BXORU4
ASGNU4
line 674
;673:
;674:	va_start( argptr, format );
ADDRLP4 4
ADDRFP4 0+4
ASGNP4
line 675
;675:	vsprintf( buf, format, argptr );
ADDRLP4 0
INDIRP4
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 4
INDIRP4
ARGP4
ADDRGP4 vsprintf
CALLI4
pop
line 676
;676:	va_end( argptr );
ADDRLP4 4
CNSTP4 0
ASGNP4
line 678
;677:
;678:	return buf;
ADDRLP4 0
INDIRP4
RETP4
LABELV $305
endproc va 12 12
export Com_SkipTokens
proc Com_SkipTokens 20 8
line 687
;679:}
;680:
;681:/*
;682:==================
;683:Com_SkipTokens
;684:==================
;685:*/
;686:const char *Com_SkipTokens( const char *s, uint64_t numTokens, const char *sep )
;687:{
line 688
;688:	uint64_t sepCount = 0;
ADDRLP4 4
CNSTU4 0
ASGNU4
line 689
;689:	const char	*p = s;
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
ADDRGP4 $311
JUMPV
LABELV $310
line 691
;690:
;691:	while( sepCount < numTokens ) {
line 692
;692:		if( Com_CharIsOneOfCharset( *p++, sep ) ) {
ADDRLP4 8
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 8
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 8
INDIRP4
INDIRI1
CVII4 1
ARGI4
ADDRFP4 8
INDIRP4
ARGP4
ADDRLP4 12
ADDRGP4 Com_CharIsOneOfCharset
CALLI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 0
EQI4 $313
line 693
;693:			sepCount++;
ADDRLP4 4
ADDRLP4 4
INDIRU4
CNSTU4 1
ADDU4
ASGNU4
ADDRGP4 $316
JUMPV
LABELV $315
line 695
;694:			while( Com_CharIsOneOfCharset( *p, sep ) )
;695:				p++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
LABELV $316
line 694
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
ARGI4
ADDRFP4 8
INDIRP4
ARGP4
ADDRLP4 16
ADDRGP4 Com_CharIsOneOfCharset
CALLI4
ASGNI4
ADDRLP4 16
INDIRI4
CNSTI4 0
NEI4 $315
line 696
;696:		}
ADDRGP4 $314
JUMPV
LABELV $313
line 697
;697:		else if( *p == '\0' )
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $318
line 698
;698:			break;
ADDRGP4 $312
JUMPV
LABELV $318
LABELV $314
line 699
;699:	}
LABELV $311
line 691
ADDRLP4 4
INDIRU4
ADDRFP4 4
INDIRU4
LTU4 $310
LABELV $312
line 701
;700:
;701:	if( sepCount == numTokens )
ADDRLP4 4
INDIRU4
ADDRFP4 4
INDIRU4
NEU4 $320
line 702
;702:		return p;
ADDRLP4 0
INDIRP4
RETP4
ADDRGP4 $309
JUMPV
LABELV $320
line 704
;703:	else
;704:		return s;
ADDRFP4 0
INDIRP4
RETP4
LABELV $309
endproc Com_SkipTokens 20 8
export N_strlwr
proc N_strlwr 8 0
line 709
;705:}
;706:
;707:
;708:char *N_strlwr(char *s1)
;709:{
line 712
;710:	char	*s;
;711:
;712:	s = s1;
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
ADDRGP4 $324
JUMPV
LABELV $323
line 713
;713:	while ( *s ) {
line 714
;714:		*s = locase[(byte)*s];
ADDRLP4 0
INDIRP4
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CVIU4 4
CVUU1 4
CVUI4 1
ADDRGP4 locase
ADDP4
INDIRU1
CVUI4 1
CVII1 4
ASGNI1
line 715
;715:		s++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 716
;716:	}
LABELV $324
line 713
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $323
line 717
;717:	return s1;
ADDRFP4 0
INDIRP4
RETP4
LABELV $322
endproc N_strlwr 8 0
export N_strupr
proc N_strupr 12 0
line 721
;718:}
;719:
;720:char *N_strupr(char *s1)
;721:{
line 724
;722:	char *s;
;723:
;724:	s = s1;
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
ADDRGP4 $328
JUMPV
LABELV $327
line 725
;725:	while (*s) {
line 726
;726:		if (*s >= 'a' && *s <= 'z')
ADDRLP4 4
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 97
LTI4 $330
ADDRLP4 4
INDIRI4
CNSTI4 122
GTI4 $330
line 727
;727:			*s = *s - 'a' + 'A';
ADDRLP4 0
INDIRP4
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 97
SUBI4
CNSTI4 65
ADDI4
CVII1 4
ASGNI1
LABELV $330
line 728
;728:		s++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 729
;729:	}
LABELV $328
line 725
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $327
line 730
;730:	return s1;
ADDRFP4 0
INDIRP4
RETP4
LABELV $326
endproc N_strupr 12 0
export N_strcat
proc N_strcat 12 12
line 735
;731:}
;732:
;733:// never goes past bounds or leaves without a terminating 0
;734:void N_strcat(char *dest, size_t size, const char *src)
;735:{
line 738
;736:	size_t l1;
;737:
;738:	l1 = strlen(dest);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 4
ADDRGP4 strlen
CALLU4
ASGNU4
ADDRLP4 0
ADDRLP4 4
INDIRU4
ASGNU4
line 739
;739:	if (l1 >= size)
ADDRLP4 0
INDIRU4
ADDRFP4 4
INDIRU4
LTU4 $333
line 740
;740:		N_Error( ERR_FATAL, "N_strcat: already overflowed" );
CNSTI4 0
ARGI4
ADDRGP4 $335
ARGP4
ADDRGP4 N_Error
CALLV
pop
LABELV $333
line 742
;741:	
;742:	N_strncpy( dest + l1, src, size - l1 );
ADDRLP4 0
INDIRU4
ADDRFP4 0
INDIRP4
ADDP4
ARGP4
ADDRFP4 8
INDIRP4
ARGP4
ADDRFP4 4
INDIRU4
ADDRLP4 0
INDIRU4
SUBU4
ARGU4
ADDRGP4 N_strncpy
CALLV
pop
line 743
;743:}
LABELV $332
endproc N_strcat 12 12
export N_stradd
proc N_stradd 13 0
line 746
;744:
;745:char *N_stradd(char *dst, const char *src)
;746:{
ADDRGP4 $338
JUMPV
LABELV $337
line 749
;747:	char c;
;748:	while ( (c = *src++) != '\0' )
;749:		*dst++ = c;
ADDRLP4 4
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 4
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
INDIRP4
ADDRLP4 0
INDIRI1
ASGNI1
LABELV $338
line 748
ADDRLP4 8
ADDRFP4 4
INDIRP4
ASGNP4
ADDRFP4 4
ADDRLP4 8
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 12
ADDRLP4 8
INDIRP4
INDIRI1
ASGNI1
ADDRLP4 0
ADDRLP4 12
INDIRI1
ASGNI1
ADDRLP4 12
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $337
line 750
;750:	*dst = '\0';
ADDRFP4 0
INDIRP4
CNSTI1 0
ASGNI1
line 751
;751:	return dst;
ADDRFP4 0
INDIRP4
RETP4
LABELV $336
endproc N_stradd 13 0
export N_stristr
proc N_stristr 36 12
line 759
;752:}
;753:
;754:
;755:/*
;756:* Find the first occurrence of find in s.
;757:*/
;758:const char *N_stristr(const char *s, const char *find)
;759:{
line 763
;760:	char c, sc;
;761:	size_t len;
;762:
;763:	if ((c = *find++) != 0) {
ADDRLP4 8
ADDRFP4 4
INDIRP4
ASGNP4
ADDRFP4 4
ADDRLP4 8
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 12
ADDRLP4 8
INDIRP4
INDIRI1
ASGNI1
ADDRLP4 1
ADDRLP4 12
INDIRI1
ASGNI1
ADDRLP4 12
INDIRI1
CVII4 1
CNSTI4 0
EQI4 $341
line 764
;764:		if (c >= 'a' && c <= 'z') {
ADDRLP4 16
ADDRLP4 1
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 16
INDIRI4
CNSTI4 97
LTI4 $343
ADDRLP4 16
INDIRI4
CNSTI4 122
GTI4 $343
line 765
;765:	    	c -= ('a' - 'A');
ADDRLP4 1
ADDRLP4 1
INDIRI1
CVII4 1
CNSTI4 32
SUBI4
CVII1 4
ASGNI1
line 766
;766:		}
LABELV $343
line 767
;767: 	   	len = strlen(find);
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 20
ADDRGP4 strlen
CALLU4
ASGNU4
ADDRLP4 4
ADDRLP4 20
INDIRU4
ASGNU4
LABELV $345
line 768
;768:    	do {
LABELV $348
line 769
;769:    		do {
line 770
;770:        		if ((sc = *s++) == 0)
ADDRLP4 24
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 24
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 28
ADDRLP4 24
INDIRP4
INDIRI1
ASGNI1
ADDRLP4 0
ADDRLP4 28
INDIRI1
ASGNI1
ADDRLP4 28
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $351
line 771
;771:          			return NULL;
CNSTP4 0
RETP4
ADDRGP4 $340
JUMPV
LABELV $351
line 772
;772:        		if (sc >= 'a' && sc <= 'z') {
ADDRLP4 32
ADDRLP4 0
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 32
INDIRI4
CNSTI4 97
LTI4 $353
ADDRLP4 32
INDIRI4
CNSTI4 122
GTI4 $353
line 773
;773:          			sc -= ('a' - 'A');
ADDRLP4 0
ADDRLP4 0
INDIRI1
CVII4 1
CNSTI4 32
SUBI4
CVII1 4
ASGNI1
line 774
;774:        		}
LABELV $353
line 775
;775:      		} while (sc != c);
LABELV $349
ADDRLP4 0
INDIRI1
CVII4 1
ADDRLP4 1
INDIRI1
CVII4 1
NEI4 $348
line 776
;776:    	} while (N_stricmpn(s, find, len) != 0);
LABELV $346
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 4
INDIRU4
ARGU4
ADDRLP4 24
ADDRGP4 N_stricmpn
CALLI4
ASGNI4
ADDRLP4 24
INDIRI4
CNSTI4 0
NEI4 $345
line 777
;777:   		s--;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 -1
ADDP4
ASGNP4
line 778
;778:  	}
LABELV $341
line 779
;779:  	return s;
ADDRFP4 0
INDIRP4
RETP4
LABELV $340
endproc N_stristr 36 12
export N_replace
proc N_replace 84 8
line 783
;780:}
;781:
;782:int N_replace(const char *str1, const char *str2, char *src, size_t max_len)
;783:{
line 789
;784:	size_t len1, len2, count;
;785:	ssize_t d;
;786:	const char *s0, *s1, *s2, *max;
;787:	char *match, *dst;
;788:
;789:	match = strstr(src, str1);
ADDRFP4 8
INDIRP4
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 40
ADDRGP4 strstr
CALLP4
ASGNP4
ADDRLP4 4
ADDRLP4 40
INDIRP4
ASGNP4
line 791
;790:
;791:	if (!match)
ADDRLP4 4
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $356
line 792
;792:		return 0;
CNSTI4 0
RETI4
ADDRGP4 $355
JUMPV
LABELV $356
line 794
;793:
;794:	count = 0; // replace count
ADDRLP4 20
CNSTU4 0
ASGNU4
line 796
;795:
;796:    len1 = strlen(str1);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 44
ADDRGP4 strlen
CALLU4
ASGNU4
ADDRLP4 24
ADDRLP4 44
INDIRU4
ASGNU4
line 797
;797:    len2 = strlen(str2);
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 48
ADDRGP4 strlen
CALLU4
ASGNU4
ADDRLP4 36
ADDRLP4 48
INDIRU4
ASGNU4
line 798
;798:    d = len2 - len1;
ADDRLP4 28
ADDRLP4 36
INDIRU4
ADDRLP4 24
INDIRU4
SUBU4
CVUI4 4
ASGNI4
line 800
;799:
;800:    if (d > 0) { // expand and replace mode
ADDRLP4 28
INDIRI4
CNSTI4 0
LEI4 $358
line 801
;801:        max = src + max_len;
ADDRLP4 32
ADDRFP4 12
INDIRU4
ADDRFP4 8
INDIRP4
ADDP4
ASGNP4
line 802
;802:        src += strlen(src);
ADDRFP4 8
INDIRP4
ARGP4
ADDRLP4 52
ADDRGP4 strlen
CALLU4
ASGNU4
ADDRFP4 8
ADDRLP4 52
INDIRU4
ADDRFP4 8
INDIRP4
ADDP4
ASGNP4
LABELV $360
line 804
;803:
;804:        do { // expand source string
line 805
;805:			s1 = src;
ADDRLP4 8
ADDRFP4 8
INDIRP4
ASGNP4
line 806
;806:            src += d;
ADDRFP4 8
ADDRLP4 28
INDIRI4
ADDRFP4 8
INDIRP4
ADDP4
ASGNP4
line 807
;807:            if (src >= max)
ADDRFP4 8
INDIRP4
CVPU4 4
ADDRLP4 32
INDIRP4
CVPU4 4
LTU4 $363
line 808
;808:                return count;
ADDRLP4 20
INDIRU4
CVUI4 4
RETI4
ADDRGP4 $355
JUMPV
LABELV $363
line 809
;809:            dst = src;
ADDRLP4 12
ADDRFP4 8
INDIRP4
ASGNP4
line 811
;810:            
;811:            s0 = match + len1;
ADDRLP4 16
ADDRLP4 24
INDIRU4
ADDRLP4 4
INDIRP4
ADDP4
ASGNP4
ADDRGP4 $366
JUMPV
LABELV $365
line 814
;812:
;813:            while (s1 >= s0)
;814:                *dst-- = *s1--;
ADDRLP4 56
ADDRLP4 12
INDIRP4
ASGNP4
ADDRLP4 64
CNSTI4 -1
ASGNI4
ADDRLP4 12
ADDRLP4 56
INDIRP4
ADDRLP4 64
INDIRI4
ADDP4
ASGNP4
ADDRLP4 60
ADDRLP4 8
INDIRP4
ASGNP4
ADDRLP4 8
ADDRLP4 60
INDIRP4
ADDRLP4 64
INDIRI4
ADDP4
ASGNP4
ADDRLP4 56
INDIRP4
ADDRLP4 60
INDIRP4
INDIRI1
ASGNI1
LABELV $366
line 813
ADDRLP4 8
INDIRP4
CVPU4 4
ADDRLP4 16
INDIRP4
CVPU4 4
GEU4 $365
line 817
;815:			
;816:			// replace match
;817:            s2 = str2;
ADDRLP4 0
ADDRFP4 4
INDIRP4
ASGNP4
ADDRGP4 $369
JUMPV
LABELV $368
line 819
;818:			while (*s2)
;819:                *match++ = *s2++;
ADDRLP4 68
ADDRLP4 4
INDIRP4
ASGNP4
ADDRLP4 76
CNSTI4 1
ASGNI4
ADDRLP4 4
ADDRLP4 68
INDIRP4
ADDRLP4 76
INDIRI4
ADDP4
ASGNP4
ADDRLP4 72
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 72
INDIRP4
ADDRLP4 76
INDIRI4
ADDP4
ASGNP4
ADDRLP4 68
INDIRP4
ADDRLP4 72
INDIRP4
INDIRI1
ASGNI1
LABELV $369
line 818
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $368
line 821
;820:			
;821:            match = strstr(match, str1);
ADDRLP4 4
INDIRP4
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 80
ADDRGP4 strstr
CALLP4
ASGNP4
ADDRLP4 4
ADDRLP4 80
INDIRP4
ASGNP4
line 823
;822:
;823:            count++;
ADDRLP4 20
ADDRLP4 20
INDIRU4
CNSTU4 1
ADDU4
ASGNU4
line 824
;824:		} while (match);
LABELV $361
ADDRLP4 4
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $360
line 826
;825:
;826:        return count;
ADDRLP4 20
INDIRU4
CVUI4 4
RETI4
ADDRGP4 $355
JUMPV
LABELV $358
line 828
;827:    } 
;828:    else if (d < 0) { // shrink and replace mode
ADDRLP4 28
INDIRI4
CNSTI4 0
GEI4 $371
LABELV $373
line 829
;829:        do  { // shrink source string
line 830
;830:            s1 = match + len1;
ADDRLP4 8
ADDRLP4 24
INDIRU4
ADDRLP4 4
INDIRP4
ADDP4
ASGNP4
line 831
;831:            dst = match + len2;
ADDRLP4 12
ADDRLP4 36
INDIRU4
ADDRLP4 4
INDIRP4
ADDP4
ASGNP4
LABELV $376
line 832
;832:            while ( (*dst++ = *s1++) != '\0' );
LABELV $377
ADDRLP4 52
ADDRLP4 12
INDIRP4
ASGNP4
ADDRLP4 60
CNSTI4 1
ASGNI4
ADDRLP4 12
ADDRLP4 52
INDIRP4
ADDRLP4 60
INDIRI4
ADDP4
ASGNP4
ADDRLP4 56
ADDRLP4 8
INDIRP4
ASGNP4
ADDRLP4 8
ADDRLP4 56
INDIRP4
ADDRLP4 60
INDIRI4
ADDP4
ASGNP4
ADDRLP4 64
ADDRLP4 56
INDIRP4
INDIRI1
ASGNI1
ADDRLP4 52
INDIRP4
ADDRLP4 64
INDIRI1
ASGNI1
ADDRLP4 64
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $376
line 835
;833:			
;834:			//replace match
;835:            s2 = str2;
ADDRLP4 0
ADDRFP4 4
INDIRP4
ASGNP4
ADDRGP4 $380
JUMPV
LABELV $379
line 836
;836:			while ( *s2 ) {
line 837
;837:				*match++ = *s2++;
ADDRLP4 68
ADDRLP4 4
INDIRP4
ASGNP4
ADDRLP4 76
CNSTI4 1
ASGNI4
ADDRLP4 4
ADDRLP4 68
INDIRP4
ADDRLP4 76
INDIRI4
ADDP4
ASGNP4
ADDRLP4 72
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 72
INDIRP4
ADDRLP4 76
INDIRI4
ADDP4
ASGNP4
ADDRLP4 68
INDIRP4
ADDRLP4 72
INDIRP4
INDIRI1
ASGNI1
line 838
;838:			}
LABELV $380
line 836
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $379
line 840
;839:
;840:            match = strstr( match, str1 );
ADDRLP4 4
INDIRP4
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 68
ADDRGP4 strstr
CALLP4
ASGNP4
ADDRLP4 4
ADDRLP4 68
INDIRP4
ASGNP4
line 842
;841:
;842:            count++;
ADDRLP4 20
ADDRLP4 20
INDIRU4
CNSTU4 1
ADDU4
ASGNU4
line 843
;843:        } 
LABELV $374
line 844
;844:        while ( match );
ADDRLP4 4
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $373
line 846
;845:
;846:        return count;
ADDRLP4 20
INDIRU4
CVUI4 4
RETI4
ADDRGP4 $355
JUMPV
LABELV $371
line 848
;847:    }
;848:    else {
LABELV $382
line 849
;849:	    do { // just replace match
line 850
;850:    	    s2 = str2;
ADDRLP4 0
ADDRFP4 4
INDIRP4
ASGNP4
ADDRGP4 $386
JUMPV
LABELV $385
line 852
;851:			while (*s2)
;852:				*match++ = *s2++;
ADDRLP4 52
ADDRLP4 4
INDIRP4
ASGNP4
ADDRLP4 60
CNSTI4 1
ASGNI4
ADDRLP4 4
ADDRLP4 52
INDIRP4
ADDRLP4 60
INDIRI4
ADDP4
ASGNP4
ADDRLP4 56
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 56
INDIRP4
ADDRLP4 60
INDIRI4
ADDP4
ASGNP4
ADDRLP4 52
INDIRP4
ADDRLP4 56
INDIRP4
INDIRI1
ASGNI1
LABELV $386
line 851
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $385
line 854
;853:
;854:    	    match = strstr(match, str1);
ADDRLP4 4
INDIRP4
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 64
ADDRGP4 strstr
CALLP4
ASGNP4
ADDRLP4 4
ADDRLP4 64
INDIRP4
ASGNP4
line 855
;855:    	    count++;
ADDRLP4 20
ADDRLP4 20
INDIRU4
CNSTU4 1
ADDU4
ASGNU4
line 856
;856:		}  while (match);
LABELV $383
ADDRLP4 4
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $382
line 857
;857:	}
line 859
;858:
;859:	return count;
ADDRLP4 20
INDIRU4
CVUI4 4
RETI4
LABELV $355
endproc N_replace 84 8
export N_strlen
proc N_strlen 4 0
line 863
;860:}
;861:
;862:size_t N_strlen (const char *str)
;863:{
line 864
;864:	size_t count = 0;
ADDRLP4 0
CNSTU4 0
ASGNU4
ADDRGP4 $390
JUMPV
LABELV $389
line 865
;865:    while (str[count]) {
line 866
;866:        ++count;
ADDRLP4 0
ADDRLP4 0
INDIRU4
CNSTU4 1
ADDU4
ASGNU4
line 867
;867:    }
LABELV $390
line 865
ADDRLP4 0
INDIRU4
ADDRFP4 0
INDIRP4
ADDP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $389
line 868
;868:	return count;
ADDRLP4 0
INDIRU4
RETU4
LABELV $388
endproc N_strlen 4 0
export N_strrchr
proc N_strrchr 20 4
ADDRFP4 4
ADDRFP4 4
INDIRI4
CVII1 4
ASGNI1
line 872
;869:}
;870:
;871:char *N_strrchr(char *str, char c)
;872:{
line 873
;873:    char *s = str;
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
line 874
;874:    size_t len = N_strlen(s);
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 8
ADDRGP4 N_strlen
CALLU4
ASGNU4
ADDRLP4 4
ADDRLP4 8
INDIRU4
ASGNU4
line 875
;875:    s += len;
ADDRLP4 0
ADDRLP4 4
INDIRU4
ADDRLP4 0
INDIRP4
ADDP4
ASGNP4
ADDRGP4 $394
JUMPV
LABELV $393
line 877
;876:    while (len--)
;877:    	if (*--s == c) return s;
ADDRLP4 12
ADDRLP4 0
INDIRP4
CNSTI4 -1
ADDP4
ASGNP4
ADDRLP4 0
ADDRLP4 12
INDIRP4
ASGNP4
ADDRLP4 12
INDIRP4
INDIRI1
CVII4 1
ADDRFP4 4
INDIRI1
CVII4 1
NEI4 $396
ADDRLP4 0
INDIRP4
RETP4
ADDRGP4 $392
JUMPV
LABELV $396
LABELV $394
line 876
ADDRLP4 16
ADDRLP4 4
INDIRU4
ASGNU4
ADDRLP4 4
ADDRLP4 16
INDIRU4
CNSTU4 1
SUBU4
ASGNU4
ADDRLP4 16
INDIRU4
CNSTU4 0
NEU4 $393
line 878
;878:    return 0;
CNSTP4 0
RETP4
LABELV $392
endproc N_strrchr 20 4
export N_strcmp
proc N_strcmp 8 0
line 882
;879:}
;880:
;881:int N_strcmp (const char *str1, const char *str2)
;882:{
line 883
;883:    const char *s1 = str1;
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
line 884
;884:    const char *s2 = str2;
ADDRLP4 4
ADDRFP4 4
INDIRP4
ASGNP4
ADDRGP4 $400
JUMPV
LABELV $399
line 885
;885:	while (1) {
line 886
;886:		if (*s1 != *s2)
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
ADDRLP4 4
INDIRP4
INDIRI1
CVII4 1
EQI4 $402
line 887
;887:			return -1;              // strings not equal    
CNSTI4 -1
RETI4
ADDRGP4 $398
JUMPV
LABELV $402
line 888
;888:		if (!*s1)
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $404
line 889
;889:			return 1;               // strings are equal
CNSTI4 1
RETI4
ADDRGP4 $398
JUMPV
LABELV $404
line 890
;890:		s1++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 891
;891:		s2++;
ADDRLP4 4
ADDRLP4 4
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 892
;892:	}
LABELV $400
line 885
ADDRGP4 $399
JUMPV
line 894
;893:	
;894:	return 0;
CNSTI4 0
RETI4
LABELV $398
endproc N_strcmp 8 0
export N_streq
proc N_streq 20 0
line 898
;895:}
;896:
;897:qboolean N_streq(const char *str1, const char *str2)
;898:{
line 899
;899:	const char *s1 = str1;
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
line 900
;900:	const char *s2 = str2;
ADDRLP4 4
ADDRFP4 4
INDIRP4
ASGNP4
ADDRGP4 $408
JUMPV
LABELV $407
line 902
;901:	
;902:	while (*s2 && *s1) {
line 903
;903:		if (*s1++ != *s2++)
ADDRLP4 8
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 16
CNSTI4 1
ASGNI4
ADDRLP4 0
ADDRLP4 8
INDIRP4
ADDRLP4 16
INDIRI4
ADDP4
ASGNP4
ADDRLP4 12
ADDRLP4 4
INDIRP4
ASGNP4
ADDRLP4 4
ADDRLP4 12
INDIRP4
ADDRLP4 16
INDIRI4
ADDP4
ASGNP4
ADDRLP4 8
INDIRP4
INDIRI1
CVII4 1
ADDRLP4 12
INDIRP4
INDIRI1
CVII4 1
EQI4 $410
line 904
;904:			return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $406
JUMPV
LABELV $410
line 905
;905:	}
LABELV $408
line 902
ADDRLP4 8
CNSTI4 0
ASGNI4
ADDRLP4 4
INDIRP4
INDIRI1
CVII4 1
ADDRLP4 8
INDIRI4
EQI4 $412
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
ADDRLP4 8
INDIRI4
NEI4 $407
LABELV $412
line 906
;906:	return qtrue;
CNSTI4 1
RETI4
LABELV $406
endproc N_streq 20 0
export N_strneq
proc N_strneq 20 0
line 910
;907:}
;908:
;909:qboolean N_strneq(const char *str1, const char *str2, size_t n)
;910:{
line 911
;911:	const char *s1 = str1;
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
line 912
;912:	const char *s2 = str2;
ADDRLP4 4
ADDRFP4 4
INDIRP4
ASGNP4
ADDRGP4 $415
JUMPV
LABELV $414
line 914
;913:
;914:	while (*s1 && n) {
line 915
;915:		if (*s1++ != *s2++)
ADDRLP4 8
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 16
CNSTI4 1
ASGNI4
ADDRLP4 0
ADDRLP4 8
INDIRP4
ADDRLP4 16
INDIRI4
ADDP4
ASGNP4
ADDRLP4 12
ADDRLP4 4
INDIRP4
ASGNP4
ADDRLP4 4
ADDRLP4 12
INDIRP4
ADDRLP4 16
INDIRI4
ADDP4
ASGNP4
ADDRLP4 8
INDIRP4
INDIRI1
CVII4 1
ADDRLP4 12
INDIRP4
INDIRI1
CVII4 1
EQI4 $417
line 916
;916:			return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $413
JUMPV
LABELV $417
line 917
;917:		n--;
ADDRFP4 8
ADDRFP4 8
INDIRU4
CNSTU4 1
SUBU4
ASGNU4
line 918
;918:	}
LABELV $415
line 914
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
EQI4 $419
ADDRFP4 8
INDIRU4
CNSTU4 0
NEU4 $414
LABELV $419
line 919
;919:	return qtrue;
CNSTI4 1
RETI4
LABELV $413
endproc N_strneq 20 0
export N_strncmp
proc N_strncmp 24 0
line 923
;920:}
;921:
;922:int N_strncmp( const char *s1, const char *s2, size_t n )
;923:{
LABELV $421
line 926
;924:	int c1, c2;
;925:	
;926:	do {
line 927
;927:		c1 = *s1++;
ADDRLP4 8
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 8
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 0
ADDRLP4 8
INDIRP4
INDIRI1
CVII4 1
ASGNI4
line 928
;928:		c2 = *s2++;
ADDRLP4 12
ADDRFP4 4
INDIRP4
ASGNP4
ADDRFP4 4
ADDRLP4 12
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
ADDRLP4 12
INDIRP4
INDIRI1
CVII4 1
ASGNI4
line 930
;929:
;930:		if (!n--) {
ADDRLP4 16
ADDRFP4 8
INDIRU4
ASGNU4
ADDRFP4 8
ADDRLP4 16
INDIRU4
CNSTU4 1
SUBU4
ASGNU4
ADDRLP4 16
INDIRU4
CNSTU4 0
NEU4 $424
line 931
;931:			return 0;		// strings are equal until end point
CNSTI4 0
RETI4
ADDRGP4 $420
JUMPV
LABELV $424
line 934
;932:		}
;933:		
;934:		if (c1 != c2) {
ADDRLP4 0
INDIRI4
ADDRLP4 4
INDIRI4
EQI4 $426
line 935
;935:			return c1 < c2 ? -1 : 1;
ADDRLP4 0
INDIRI4
ADDRLP4 4
INDIRI4
GEI4 $429
ADDRLP4 20
CNSTI4 -1
ASGNI4
ADDRGP4 $430
JUMPV
LABELV $429
ADDRLP4 20
CNSTI4 1
ASGNI4
LABELV $430
ADDRLP4 20
INDIRI4
RETI4
ADDRGP4 $420
JUMPV
LABELV $426
line 937
;936:		}
;937:	} while (c1);
LABELV $422
ADDRLP4 0
INDIRI4
CNSTI4 0
NEI4 $421
line 939
;938:	
;939:	return 0;		// strings are equal
CNSTI4 0
RETI4
LABELV $420
endproc N_strncmp 24 0
export N_stricmpn
proc N_stricmpn 32 0
line 943
;940:}
;941:
;942:int N_stricmpn (const char *str1, const char *str2, size_t n)
;943:{
line 947
;944:	int c1, c2;
;945:
;946:	// bk001129 - moved in 1.17 fix not in id codebase
;947:    if (str1 == NULL) {
ADDRFP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $432
line 948
;948:    	if (str2 == NULL) {
ADDRFP4 4
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $434
line 949
;949:            return 0;
CNSTI4 0
RETI4
ADDRGP4 $431
JUMPV
LABELV $434
line 951
;950:		}
;951:        else {
line 952
;952:            return -1;
CNSTI4 -1
RETI4
ADDRGP4 $431
JUMPV
LABELV $432
line 955
;953:		}
;954:    }
;955:    else if (str2 == NULL) {
ADDRFP4 4
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $436
line 956
;956:        return 1;
CNSTI4 1
RETI4
ADDRGP4 $431
JUMPV
LABELV $436
LABELV $438
line 959
;957:	}
;958:	
;959:	do {
line 960
;960:		c1 = *str1++;
ADDRLP4 8
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 8
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 0
ADDRLP4 8
INDIRP4
INDIRI1
CVII4 1
ASGNI4
line 961
;961:		c2 = *str2++;
ADDRLP4 12
ADDRFP4 4
INDIRP4
ASGNP4
ADDRFP4 4
ADDRLP4 12
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
ADDRLP4 12
INDIRP4
INDIRI1
CVII4 1
ASGNI4
line 963
;962:
;963:		if (!n--) {
ADDRLP4 16
ADDRFP4 8
INDIRU4
ASGNU4
ADDRFP4 8
ADDRLP4 16
INDIRU4
CNSTU4 1
SUBU4
ASGNU4
ADDRLP4 16
INDIRU4
CNSTU4 0
NEU4 $441
line 964
;964:			return 0;		// strings are equal until end point
CNSTI4 0
RETI4
ADDRGP4 $431
JUMPV
LABELV $441
line 967
;965:		}
;966:		
;967:		if (c1 != c2) {
ADDRLP4 0
INDIRI4
ADDRLP4 4
INDIRI4
EQI4 $443
line 968
;968:			if (c1 >= 'a' && c1 <= 'z') {
ADDRLP4 0
INDIRI4
CNSTI4 97
LTI4 $445
ADDRLP4 0
INDIRI4
CNSTI4 122
GTI4 $445
line 969
;969:				c1 -= ('a' - 'A');
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 32
SUBI4
ASGNI4
line 970
;970:			}
LABELV $445
line 971
;971:			if (c2 >= 'a' && c2 <= 'z') {
ADDRLP4 4
INDIRI4
CNSTI4 97
LTI4 $447
ADDRLP4 4
INDIRI4
CNSTI4 122
GTI4 $447
line 972
;972:				c2 -= ('a' - 'A');
ADDRLP4 4
ADDRLP4 4
INDIRI4
CNSTI4 32
SUBI4
ASGNI4
line 973
;973:			}
LABELV $447
line 974
;974:			if (c1 != c2) {
ADDRLP4 0
INDIRI4
ADDRLP4 4
INDIRI4
EQI4 $449
line 975
;975:				return c1 < c2 ? -1 : 1;
ADDRLP4 0
INDIRI4
ADDRLP4 4
INDIRI4
GEI4 $452
ADDRLP4 28
CNSTI4 -1
ASGNI4
ADDRGP4 $453
JUMPV
LABELV $452
ADDRLP4 28
CNSTI4 1
ASGNI4
LABELV $453
ADDRLP4 28
INDIRI4
RETI4
ADDRGP4 $431
JUMPV
LABELV $449
line 977
;976:			}
;977:		}
LABELV $443
line 978
;978:	} while (c1);
LABELV $439
ADDRLP4 0
INDIRI4
CNSTI4 0
NEI4 $438
line 980
;979:	
;980:	return 0;		// strings are equal
CNSTI4 0
RETI4
LABELV $431
endproc N_stricmpn 32 0
export N_stricmp
proc N_stricmp 24 0
line 984
;981:}
;982:
;983:int N_stricmp( const char *s1, const char *s2 ) 
;984:{
line 987
;985:	unsigned char c1, c2;
;986:
;987:	if (s1 == NULL)  {
ADDRFP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $455
line 988
;988:		if (s2 == NULL)
ADDRFP4 4
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $457
line 989
;989:			return 0;
CNSTI4 0
RETI4
ADDRGP4 $454
JUMPV
LABELV $457
line 991
;990:		else
;991:			return -1;
CNSTI4 -1
RETI4
ADDRGP4 $454
JUMPV
LABELV $455
line 993
;992:	}
;993:	else if (s2 == NULL)
ADDRFP4 4
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $459
line 994
;994:		return 1;
CNSTI4 1
RETI4
ADDRGP4 $454
JUMPV
LABELV $459
LABELV $461
line 996
;995:	
;996:	do {
line 997
;997:		c1 = *s1++;
ADDRLP4 4
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 4
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 0
ADDRLP4 4
INDIRP4
INDIRI1
CVII4 1
CVIU4 4
CVUU1 4
ASGNU1
line 998
;998:		c2 = *s2++;
ADDRLP4 8
ADDRFP4 4
INDIRP4
ASGNP4
ADDRFP4 4
ADDRLP4 8
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 1
ADDRLP4 8
INDIRP4
INDIRI1
CVII4 1
CVIU4 4
CVUU1 4
ASGNU1
line 1000
;999:
;1000:		if (c1 != c2) {
ADDRLP4 0
INDIRU1
CVUI4 1
ADDRLP4 1
INDIRU1
CVUI4 1
EQI4 $464
line 1001
;1001:			if ( c1 <= 'Z' && c1 >= 'A' )
ADDRLP4 12
ADDRLP4 0
INDIRU1
CVUI4 1
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 90
GTI4 $466
ADDRLP4 12
INDIRI4
CNSTI4 65
LTI4 $466
line 1002
;1002:				c1 += ('a' - 'A');
ADDRLP4 0
ADDRLP4 0
INDIRU1
CVUI4 1
CNSTI4 32
ADDI4
CVIU4 4
CVUU1 4
ASGNU1
LABELV $466
line 1004
;1003:
;1004:			if ( c2 <= 'Z' && c2 >= 'A' )
ADDRLP4 16
ADDRLP4 1
INDIRU1
CVUI4 1
ASGNI4
ADDRLP4 16
INDIRI4
CNSTI4 90
GTI4 $468
ADDRLP4 16
INDIRI4
CNSTI4 65
LTI4 $468
line 1005
;1005:				c2 += ('a' - 'A');
ADDRLP4 1
ADDRLP4 1
INDIRU1
CVUI4 1
CNSTI4 32
ADDI4
CVIU4 4
CVUU1 4
ASGNU1
LABELV $468
line 1007
;1006:
;1007:			if ( c1 != c2 ) 
ADDRLP4 0
INDIRU1
CVUI4 1
ADDRLP4 1
INDIRU1
CVUI4 1
EQI4 $470
line 1008
;1008:				return c1 < c2 ? -1 : 1;
ADDRLP4 0
INDIRU1
CVUI4 1
ADDRLP4 1
INDIRU1
CVUI4 1
GEI4 $473
ADDRLP4 20
CNSTI4 -1
ASGNI4
ADDRGP4 $474
JUMPV
LABELV $473
ADDRLP4 20
CNSTI4 1
ASGNI4
LABELV $474
ADDRLP4 20
INDIRI4
RETI4
ADDRGP4 $454
JUMPV
LABELV $470
line 1009
;1009:		}
LABELV $464
line 1010
;1010:	} while ( c1 != '\0' );
LABELV $462
ADDRLP4 0
INDIRU1
CVUI4 1
CNSTI4 0
NEI4 $461
line 1012
;1011:
;1012:	return 0;
CNSTI4 0
RETI4
LABELV $454
endproc N_stricmp 24 0
export N_atoi
proc N_atoi 40 0
line 1016
;1013:}
;1014:
;1015:int N_atoi (const char *s)
;1016:{
line 1020
;1017:	int val;
;1018:	int sign;
;1019:	int c;
;1020:    const char* str = s;
ADDRLP4 8
ADDRFP4 0
INDIRP4
ASGNP4
line 1022
;1021:	
;1022:	if (*str == '-') {
ADDRLP4 8
INDIRP4
INDIRI1
CVII4 1
CNSTI4 45
NEI4 $476
line 1023
;1023:		sign = -1;
ADDRLP4 12
CNSTI4 -1
ASGNI4
line 1024
;1024:		str++;
ADDRLP4 8
ADDRLP4 8
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1025
;1025:	}
ADDRGP4 $477
JUMPV
LABELV $476
line 1027
;1026:	else
;1027:		sign = 1;
ADDRLP4 12
CNSTI4 1
ASGNI4
LABELV $477
line 1029
;1028:		
;1029:	val = 0;
ADDRLP4 4
CNSTI4 0
ASGNI4
line 1034
;1030:
;1031:    //
;1032:    // check for hex
;1033:    //
;1034:	if (str[0] == '0' && (str[1] == 'x' || str[1] == 'X') ) {
ADDRLP4 8
INDIRP4
INDIRI1
CVII4 1
CNSTI4 48
NEI4 $478
ADDRLP4 20
ADDRLP4 8
INDIRP4
CNSTI4 1
ADDP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 20
INDIRI4
CNSTI4 120
EQI4 $480
ADDRLP4 20
INDIRI4
CNSTI4 88
NEI4 $478
LABELV $480
line 1035
;1035:		str += 2;
ADDRLP4 8
ADDRLP4 8
INDIRP4
CNSTI4 2
ADDP4
ASGNP4
ADDRGP4 $482
JUMPV
LABELV $481
line 1036
;1036:		while (1) {
line 1037
;1037:			c = *str++;
ADDRLP4 24
ADDRLP4 8
INDIRP4
ASGNP4
ADDRLP4 8
ADDRLP4 24
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 0
ADDRLP4 24
INDIRP4
INDIRI1
CVII4 1
ASGNI4
line 1038
;1038:			if (c >= '0' && c <= '9')
ADDRLP4 0
INDIRI4
CNSTI4 48
LTI4 $484
ADDRLP4 0
INDIRI4
CNSTI4 57
GTI4 $484
line 1039
;1039:				val = (val<<4) + c - '0';
ADDRLP4 4
ADDRLP4 4
INDIRI4
CNSTI4 4
LSHI4
ADDRLP4 0
INDIRI4
ADDI4
CNSTI4 48
SUBI4
ASGNI4
ADDRGP4 $485
JUMPV
LABELV $484
line 1040
;1040:			else if (c >= 'a' && c <= 'f')
ADDRLP4 0
INDIRI4
CNSTI4 97
LTI4 $486
ADDRLP4 0
INDIRI4
CNSTI4 102
GTI4 $486
line 1041
;1041:				val = (val<<4) + c - 'a' + 10;
ADDRLP4 4
ADDRLP4 4
INDIRI4
CNSTI4 4
LSHI4
ADDRLP4 0
INDIRI4
ADDI4
CNSTI4 97
SUBI4
CNSTI4 10
ADDI4
ASGNI4
ADDRGP4 $487
JUMPV
LABELV $486
line 1042
;1042:			else if (c >= 'A' && c <= 'F')
ADDRLP4 0
INDIRI4
CNSTI4 65
LTI4 $488
ADDRLP4 0
INDIRI4
CNSTI4 70
GTI4 $488
line 1043
;1043:				val = (val<<4) + c - 'A' + 10;
ADDRLP4 4
ADDRLP4 4
INDIRI4
CNSTI4 4
LSHI4
ADDRLP4 0
INDIRI4
ADDI4
CNSTI4 65
SUBI4
CNSTI4 10
ADDI4
ASGNI4
ADDRGP4 $489
JUMPV
LABELV $488
line 1045
;1044:			else
;1045:				return val*sign;
ADDRLP4 4
INDIRI4
ADDRLP4 12
INDIRI4
MULI4
RETI4
ADDRGP4 $475
JUMPV
LABELV $489
LABELV $487
LABELV $485
line 1046
;1046:		}
LABELV $482
line 1036
ADDRGP4 $481
JUMPV
line 1047
;1047:	}
LABELV $478
line 1052
;1048:	
;1049:    //
;1050:    // check for character
;1051:    //
;1052:	if (str[0] == '\'')
ADDRLP4 8
INDIRP4
INDIRI1
CVII4 1
CNSTI4 39
NEI4 $493
line 1053
;1053:		return sign * str[1];
ADDRLP4 12
INDIRI4
ADDRLP4 8
INDIRP4
CNSTI4 1
ADDP4
INDIRI1
CVII4 1
MULI4
RETI4
ADDRGP4 $475
JUMPV
LABELV $492
line 1058
;1054:	
;1055:    //
;1056:    // assume decimal
;1057:    //
;1058:	while (1) {
line 1059
;1059:		c = *str++;
ADDRLP4 24
ADDRLP4 8
INDIRP4
ASGNP4
ADDRLP4 8
ADDRLP4 24
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 0
ADDRLP4 24
INDIRP4
INDIRI1
CVII4 1
ASGNI4
line 1060
;1060:		if (c <'0' || c > '9')
ADDRLP4 0
INDIRI4
CNSTI4 48
LTI4 $497
ADDRLP4 0
INDIRI4
CNSTI4 57
LEI4 $495
LABELV $497
line 1061
;1061:			return val*sign;
ADDRLP4 4
INDIRI4
ADDRLP4 12
INDIRI4
MULI4
RETI4
ADDRGP4 $475
JUMPV
LABELV $495
line 1062
;1062:		val = val*10 + c - '0';
ADDRLP4 4
CNSTI4 10
ADDRLP4 4
INDIRI4
MULI4
ADDRLP4 0
INDIRI4
ADDI4
CNSTI4 48
SUBI4
ASGNI4
line 1063
;1063:	}
LABELV $493
line 1058
ADDRGP4 $492
JUMPV
line 1065
;1064:	
;1065:	return 0;
CNSTI4 0
RETI4
LABELV $475
endproc N_atoi 40 0
export Com_snprintf
proc Com_snprintf 32016 12
line 1073
;1066:}
;1067:
;1068:#if	defined(_DEBUG) && defined(_WIN32)
;1069:#include <windows.h>
;1070:#endif
;1071:
;1072:int GDR_ATTRIBUTE((format(printf, 3, 4))) GDR_DECL Com_snprintf( char *dest, uint32_t size, const char *fmt, ...)
;1073:{
line 1078
;1074:	int		len;
;1075:	va_list	argptr;
;1076:	char	bigbuffer[32000];	// big, but small enough to fit in PPC stack
;1077:
;1078:	if ( !dest )  {
ADDRFP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $499
line 1079
;1079:		N_Error( ERR_FATAL, "Com_snprintf: NULL dest" );
CNSTI4 0
ARGI4
ADDRGP4 $501
ARGP4
ADDRGP4 N_Error
CALLV
pop
line 1083
;1080:#if	defined(_DEBUG) && defined(_WIN32)
;1081:		DebugBreak();
;1082:#endif
;1083:		return 0;
CNSTI4 0
RETI4
ADDRGP4 $498
JUMPV
LABELV $499
line 1086
;1084:	}
;1085:
;1086:	va_start( argptr, fmt );
ADDRLP4 4
ADDRFP4 8+4
ASGNP4
line 1087
;1087:	len = vsprintf( bigbuffer, fmt, argptr );
ADDRLP4 8
ARGP4
ADDRFP4 8
INDIRP4
ARGP4
ADDRLP4 4
INDIRP4
ARGP4
ADDRLP4 32008
ADDRGP4 vsprintf
CALLI4
ASGNI4
ADDRLP4 0
ADDRLP4 32008
INDIRI4
ASGNI4
line 1088
;1088:	va_end( argptr );
ADDRLP4 4
CNSTP4 0
ASGNP4
line 1090
;1089:
;1090:	if ( len >= sizeof( bigbuffer ) || len < 0 )  {
ADDRLP4 0
INDIRI4
CVIU4 4
CNSTU4 32000
GEU4 $505
ADDRLP4 0
INDIRI4
CNSTI4 0
GEI4 $503
LABELV $505
line 1091
;1091:		N_Error( ERR_FATAL, "Com_smprintf: overflowed bigbuffer" );
CNSTI4 0
ARGI4
ADDRGP4 $506
ARGP4
ADDRGP4 N_Error
CALLV
pop
line 1095
;1092:#if	defined(_DEBUG) && defined(_WIN32)
;1093:		DebugBreak();
;1094:#endif
;1095:		return 0;
CNSTI4 0
RETI4
ADDRGP4 $498
JUMPV
LABELV $503
line 1098
;1096:	}
;1097:
;1098:	if ( len >= size )  {
ADDRLP4 0
INDIRI4
CVIU4 4
ADDRFP4 4
INDIRU4
LTU4 $507
line 1099
;1099:		Con_Printf( COLOR_YELLOW "Com_snprintf: overflow of %i in %u\n", len, size );
ADDRGP4 $509
ARGP4
ADDRLP4 0
INDIRI4
ARGI4
ADDRFP4 4
INDIRU4
ARGU4
ADDRGP4 Con_Printf
CALLV
pop
line 1103
;1100:#if	defined(_DEBUG) && defined(_WIN32)
;1101:		DebugBreak();
;1102:#endif
;1103:		len = size - 1;
ADDRLP4 0
ADDRFP4 4
INDIRU4
CNSTU4 1
SUBU4
CVUI4 4
ASGNI4
line 1104
;1104:	}
LABELV $507
line 1108
;1105:
;1106:	//Q_strncpyz( dest, bigbuffer, size );
;1107:	//strncpy( dest, bigbuffer, len );
;1108:	memcpy( dest, bigbuffer, len );
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 8
ARGP4
ADDRLP4 0
INDIRI4
CVIU4 4
ARGU4
ADDRGP4 memcpy
CALLP4
pop
line 1109
;1109:	dest[ len ] = '\0';
ADDRLP4 0
INDIRI4
ADDRFP4 0
INDIRP4
ADDP4
CNSTI1 0
ASGNI1
line 1111
;1110:
;1111:	return len;
ADDRLP4 0
INDIRI4
RETI4
LABELV $498
endproc Com_snprintf 32016 12
export COM_SkipPath
proc COM_SkipPath 4 0
line 1120
;1112:}
;1113:
;1114:/*
;1115:============
;1116:COM_SkipPath
;1117:============
;1118:*/
;1119:char *COM_SkipPath (char *pathname)
;1120:{
line 1123
;1121:	char	*last;
;1122:	
;1123:	last = pathname;
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
ADDRGP4 $512
JUMPV
LABELV $511
line 1124
;1124:	while (*pathname) {
line 1125
;1125:		if (*pathname=='/')
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 47
NEI4 $514
line 1126
;1126:			last = pathname+1;
ADDRLP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
LABELV $514
line 1127
;1127:		pathname++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1128
;1128:	}
LABELV $512
line 1124
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $511
line 1129
;1129:	return last;
ADDRLP4 0
INDIRP4
RETP4
LABELV $510
endproc COM_SkipPath 4 0
export COM_GetExtension
proc COM_GetExtension 20 8
line 1138
;1130:}
;1131:
;1132:/*
;1133:============
;1134:COM_GetExtension
;1135:============
;1136:*/
;1137:const char *COM_GetExtension( const char *name )
;1138:{
line 1139
;1139:	const char *dot = (const char *)strrchr(name, '.'), *slash;
ADDRFP4 0
INDIRP4
ARGP4
CNSTI4 46
ARGI4
ADDRLP4 8
ADDRGP4 strrchr
CALLI4
ASGNI4
ADDRLP4 0
ADDRLP4 8
INDIRI4
CVIU4 4
CVUP4 4
ASGNP4
line 1140
;1140:	if (dot && ((slash = (const char *)strrchr(name, '/')) == NULL || slash < dot))
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $517
ADDRFP4 0
INDIRP4
ARGP4
CNSTI4 47
ARGI4
ADDRLP4 12
ADDRGP4 strrchr
CALLI4
ASGNI4
ADDRLP4 16
ADDRLP4 12
INDIRI4
CVIU4 4
CVUP4 4
ASGNP4
ADDRLP4 4
ADDRLP4 16
INDIRP4
ASGNP4
ADDRLP4 16
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $519
ADDRLP4 4
INDIRP4
CVPU4 4
ADDRLP4 0
INDIRP4
CVPU4 4
GEU4 $517
LABELV $519
line 1141
;1141:		return dot + 1;
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
RETP4
ADDRGP4 $516
JUMPV
LABELV $517
line 1143
;1142:	else
;1143:		return "";
ADDRGP4 $520
RETP4
LABELV $516
endproc COM_GetExtension 20 8
export COM_BeginParseSession
proc COM_BeginParseSession 0 16
line 1163
;1144:}
;1145:
;1146:/*
;1147:===============================================================
;1148:
;1149:Parsing
;1150:
;1151:===============================================================
;1152:*/
;1153:
;1154:static	char	com_token[MAX_TOKEN_CHARS];
;1155:static	char	com_parsename[MAX_TOKEN_CHARS];
;1156:static	uint64_t com_lines;
;1157:static  uint64_t com_tokenline;
;1158:
;1159:// for complex parser
;1160:tokenType_t		com_tokentype;
;1161:
;1162:void COM_BeginParseSession( const char *name )
;1163:{
line 1164
;1164:	com_lines = 1;
ADDRGP4 com_lines
CNSTU4 1
ASGNU4
line 1165
;1165:	com_tokenline = 0;
ADDRGP4 com_tokenline
CNSTU4 0
ASGNU4
line 1166
;1166:	Com_snprintf(com_parsename, sizeof(com_parsename), "%s", name);
ADDRGP4 com_parsename
ARGP4
CNSTU4 1024
ARGU4
ADDRGP4 $522
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRGP4 Com_snprintf
CALLI4
pop
line 1167
;1167:}
LABELV $521
endproc COM_BeginParseSession 0 16
export COM_GetCurrentParseLine
proc COM_GetCurrentParseLine 0 0
line 1171
;1168:
;1169:
;1170:uint64_t COM_GetCurrentParseLine( void )
;1171:{
line 1172
;1172:	if ( com_tokenline )
ADDRGP4 com_tokenline
INDIRU4
CNSTU4 0
EQU4 $524
line 1173
;1173:	{
line 1174
;1174:		return com_tokenline;
ADDRGP4 com_tokenline
INDIRU4
RETU4
ADDRGP4 $523
JUMPV
LABELV $524
line 1177
;1175:	}
;1176:
;1177:	return com_lines;
ADDRGP4 com_lines
INDIRU4
RETU4
LABELV $523
endproc COM_GetCurrentParseLine 0 0
export COM_Parse
proc COM_Parse 4 8
line 1182
;1178:}
;1179:
;1180:
;1181:const char *COM_Parse( const char **data_p )
;1182:{
line 1183
;1183:	return COM_ParseExt( data_p, qtrue );
ADDRFP4 0
INDIRP4
ARGP4
CNSTI4 1
ARGI4
ADDRLP4 0
ADDRGP4 COM_ParseExt
CALLP4
ASGNP4
ADDRLP4 0
INDIRP4
RETP4
LABELV $526
endproc COM_Parse 4 8
bss
align 1
LABELV $528
skip 4096
export COM_ParseError
code
proc COM_ParseError 8 16
line 1187
;1184:}
;1185:
;1186:void COM_ParseError( const char *format, ... )
;1187:{
line 1191
;1188:	va_list argptr;
;1189:	static char string[4096];
;1190:
;1191:	va_start( argptr, format );
ADDRLP4 0
ADDRFP4 0+4
ASGNP4
line 1192
;1192:	vsprintf (string, format, argptr);
ADDRGP4 $528
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 vsprintf
CALLI4
pop
line 1193
;1193:	va_end( argptr );
ADDRLP4 0
CNSTP4 0
ASGNP4
line 1195
;1194:
;1195:	Con_Printf( COLOR_RED "ERROR: %s, line %lu: %s\n", com_parsename, COM_GetCurrentParseLine(), string );
ADDRLP4 4
ADDRGP4 COM_GetCurrentParseLine
CALLU4
ASGNU4
ADDRGP4 $530
ARGP4
ADDRGP4 com_parsename
ARGP4
ADDRLP4 4
INDIRU4
ARGU4
ADDRGP4 $528
ARGP4
ADDRGP4 Con_Printf
CALLV
pop
line 1196
;1196:}
LABELV $527
endproc COM_ParseError 8 16
bss
align 1
LABELV $532
skip 4096
export COM_ParseWarning
code
proc COM_ParseWarning 8 16
line 1199
;1197:
;1198:void COM_ParseWarning( const char *format, ... )
;1199:{
line 1203
;1200:	va_list argptr;
;1201:	static char string[4096];
;1202:
;1203:	va_start( argptr, format );
ADDRLP4 0
ADDRFP4 0+4
ASGNP4
line 1204
;1204:	vsprintf (string, format, argptr);
ADDRGP4 $532
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 vsprintf
CALLI4
pop
line 1205
;1205:	va_end( argptr );
ADDRLP4 0
CNSTP4 0
ASGNP4
line 1207
;1206:
;1207:	Con_Printf( COLOR_YELLOW "WARNING: %s, line %lu: %s\n", com_parsename, COM_GetCurrentParseLine(), string );
ADDRLP4 4
ADDRGP4 COM_GetCurrentParseLine
CALLU4
ASGNU4
ADDRGP4 $534
ARGP4
ADDRGP4 com_parsename
ARGP4
ADDRLP4 4
INDIRU4
ARGU4
ADDRGP4 $532
ARGP4
ADDRGP4 Con_Printf
CALLV
pop
line 1208
;1208:}
LABELV $531
endproc COM_ParseWarning 8 16
export SkipWhitespace
proc SkipWhitespace 8 0
line 1223
;1209:
;1210:
;1211:/*
;1212:==============
;1213:COM_Parse
;1214:
;1215:Parse a token out of a string
;1216:Will never return NULL, just empty strings
;1217:
;1218:If "allowLineBreaks" is qtrue then an empty
;1219:string will be returned if the next token is
;1220:a newline.
;1221:==============
;1222:*/
;1223:const char *SkipWhitespace( const char *data, qboolean *hasNewLines ) {
ADDRGP4 $537
JUMPV
LABELV $536
line 1226
;1224:	int c;
;1225:
;1226:	while( (c = *data) <= ' ') {
line 1227
;1227:		if( !c ) {
ADDRLP4 0
INDIRI4
CNSTI4 0
NEI4 $539
line 1228
;1228:			return NULL;
CNSTP4 0
RETP4
ADDRGP4 $535
JUMPV
LABELV $539
line 1230
;1229:		}
;1230:		if( c == '\n' ) {
ADDRLP4 0
INDIRI4
CNSTI4 10
NEI4 $541
line 1231
;1231:			com_lines++;
ADDRLP4 4
ADDRGP4 com_lines
ASGNP4
ADDRLP4 4
INDIRP4
ADDRLP4 4
INDIRP4
INDIRU4
CNSTU4 1
ADDU4
ASGNU4
line 1232
;1232:			*hasNewLines = qtrue;
ADDRFP4 4
INDIRP4
CNSTI4 1
ASGNI4
line 1233
;1233:		}
LABELV $541
line 1234
;1234:		data++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1235
;1235:	}
LABELV $537
line 1226
ADDRLP4 4
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 0
ADDRLP4 4
INDIRI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 32
LEI4 $536
line 1237
;1236:
;1237:	return data;
ADDRFP4 0
INDIRP4
RETP4
LABELV $535
endproc SkipWhitespace 8 0
export COM_Compress
proc COM_Compress 48 0
line 1240
;1238:}
;1239:
;1240:uintptr_t COM_Compress( char *data_p ) {
line 1244
;1241:	const char *in;
;1242:	char *out;
;1243:	int c;
;1244:	qboolean newline = qfalse, whitespace = qfalse;
ADDRLP4 12
CNSTI4 0
ASGNI4
ADDRLP4 16
CNSTI4 0
ASGNI4
line 1246
;1245:
;1246:	in = out = data_p;
ADDRLP4 20
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 8
ADDRLP4 20
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 20
INDIRP4
ASGNP4
ADDRGP4 $545
JUMPV
LABELV $544
line 1247
;1247:	while ((c = *in) != '\0') {
line 1249
;1248:		// skip double slash comments
;1249:		if ( c == '/' && in[1] == '/' ) {
ADDRLP4 24
CNSTI4 47
ASGNI4
ADDRLP4 4
INDIRI4
ADDRLP4 24
INDIRI4
NEI4 $547
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
INDIRI1
CVII4 1
ADDRLP4 24
INDIRI4
NEI4 $547
ADDRGP4 $550
JUMPV
LABELV $549
line 1250
;1250:			while (*in && *in != '\n') {
line 1251
;1251:				in++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1252
;1252:			}
LABELV $550
line 1250
ADDRLP4 28
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 28
INDIRI4
CNSTI4 0
EQI4 $552
ADDRLP4 28
INDIRI4
CNSTI4 10
NEI4 $549
LABELV $552
line 1254
;1253:		// skip /* */ comments
;1254:		} else if ( c == '/' && in[1] == '*' ) {
ADDRGP4 $548
JUMPV
LABELV $547
ADDRLP4 4
INDIRI4
CNSTI4 47
NEI4 $553
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
INDIRI1
CVII4 1
CNSTI4 42
NEI4 $553
ADDRGP4 $556
JUMPV
LABELV $555
line 1256
;1255:			while ( *in && ( *in != '*' || in[1] != '/' ) ) 
;1256:				in++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
LABELV $556
line 1255
ADDRLP4 32
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 32
INDIRI4
CNSTI4 0
EQI4 $558
ADDRLP4 32
INDIRI4
CNSTI4 42
NEI4 $555
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
INDIRI1
CVII4 1
CNSTI4 47
NEI4 $555
LABELV $558
line 1257
;1257:			if ( *in ) 
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
EQI4 $554
line 1258
;1258:				in += 2;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 2
ADDP4
ASGNP4
line 1260
;1259:			// record when we hit a newline
;1260:		} else if ( c == '\n' || c == '\r' ) {
ADDRGP4 $554
JUMPV
LABELV $553
ADDRLP4 4
INDIRI4
CNSTI4 10
EQI4 $563
ADDRLP4 4
INDIRI4
CNSTI4 13
NEI4 $561
LABELV $563
line 1261
;1261:			newline = qtrue;
ADDRLP4 12
CNSTI4 1
ASGNI4
line 1262
;1262:			in++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1264
;1263:			// record when we hit whitespace
;1264:		} else if ( c == ' ' || c == '\t') {
ADDRGP4 $562
JUMPV
LABELV $561
ADDRLP4 4
INDIRI4
CNSTI4 32
EQI4 $566
ADDRLP4 4
INDIRI4
CNSTI4 9
NEI4 $564
LABELV $566
line 1265
;1265:			whitespace = qtrue;
ADDRLP4 16
CNSTI4 1
ASGNI4
line 1266
;1266:			in++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1268
;1267:			// an actual token
;1268:		} else {
ADDRGP4 $565
JUMPV
LABELV $564
line 1270
;1269:			// if we have a pending newline, emit it (and it counts as whitespace)
;1270:			if (newline) {
ADDRLP4 12
INDIRI4
CNSTI4 0
EQI4 $567
line 1271
;1271:				*out++ = '\n';
ADDRLP4 36
ADDRLP4 8
INDIRP4
ASGNP4
ADDRLP4 8
ADDRLP4 36
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 36
INDIRP4
CNSTI1 10
ASGNI1
line 1272
;1272:				newline = qfalse;
ADDRLP4 12
CNSTI4 0
ASGNI4
line 1273
;1273:				whitespace = qfalse;
ADDRLP4 16
CNSTI4 0
ASGNI4
line 1274
;1274:			} else if (whitespace) {
ADDRGP4 $568
JUMPV
LABELV $567
ADDRLP4 16
INDIRI4
CNSTI4 0
EQI4 $569
line 1275
;1275:				*out++ = ' ';
ADDRLP4 36
ADDRLP4 8
INDIRP4
ASGNP4
ADDRLP4 8
ADDRLP4 36
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 36
INDIRP4
CNSTI1 32
ASGNI1
line 1276
;1276:				whitespace = qfalse;
ADDRLP4 16
CNSTI4 0
ASGNI4
line 1277
;1277:			}
LABELV $569
LABELV $568
line 1279
;1278:			// copy quoted strings unmolested
;1279:			if (c == '"') {
ADDRLP4 4
INDIRI4
CNSTI4 34
NEI4 $571
line 1280
;1280:				*out++ = c;
ADDRLP4 36
ADDRLP4 8
INDIRP4
ASGNP4
ADDRLP4 8
ADDRLP4 36
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 36
INDIRP4
ADDRLP4 4
INDIRI4
CVII1 4
ASGNI1
line 1281
;1281:				in++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRGP4 $574
JUMPV
LABELV $573
line 1282
;1282:				while (1) {
line 1283
;1283:					c = *in;
ADDRLP4 4
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
line 1284
;1284:					if (c && c != '"') {
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $575
ADDRLP4 4
INDIRI4
CNSTI4 34
EQI4 $575
line 1285
;1285:						*out++ = c;
ADDRLP4 44
ADDRLP4 8
INDIRP4
ASGNP4
ADDRLP4 8
ADDRLP4 44
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 44
INDIRP4
ADDRLP4 4
INDIRI4
CVII1 4
ASGNI1
line 1286
;1286:						in++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1287
;1287:					} else {
line 1288
;1288:						break;
LABELV $577
line 1290
;1289:					}
;1290:				}
LABELV $574
line 1282
ADDRGP4 $573
JUMPV
LABELV $575
line 1291
;1291:				if (c == '"') {
ADDRLP4 4
INDIRI4
CNSTI4 34
NEI4 $572
line 1292
;1292:					*out++ = c;
ADDRLP4 40
ADDRLP4 8
INDIRP4
ASGNP4
ADDRLP4 8
ADDRLP4 40
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 40
INDIRP4
ADDRLP4 4
INDIRI4
CVII1 4
ASGNI1
line 1293
;1293:					in++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1294
;1294:				}
line 1295
;1295:			} else {
ADDRGP4 $572
JUMPV
LABELV $571
line 1296
;1296:				*out++ = c;
ADDRLP4 36
ADDRLP4 8
INDIRP4
ASGNP4
ADDRLP4 8
ADDRLP4 36
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 36
INDIRP4
ADDRLP4 4
INDIRI4
CVII1 4
ASGNI1
line 1297
;1297:				in++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1298
;1298:			}
LABELV $572
line 1299
;1299:		}
LABELV $565
LABELV $562
LABELV $554
LABELV $548
line 1300
;1300:	}
LABELV $545
line 1247
ADDRLP4 24
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 4
ADDRLP4 24
INDIRI4
ASGNI4
ADDRLP4 24
INDIRI4
CNSTI4 0
NEI4 $544
line 1302
;1301:
;1302:	*out = '\0';
ADDRLP4 8
INDIRP4
CNSTI1 0
ASGNI1
line 1304
;1303:
;1304:	return (uintptr_t)(out - data_p);
ADDRLP4 8
INDIRP4
CVPU4 4
ADDRFP4 0
INDIRP4
CVPU4 4
SUBU4
CVUI4 4
CVIU4 4
RETU4
LABELV $543
endproc COM_Compress 48 0
export COM_ParseExt
proc COM_ParseExt 36 8
line 1308
;1305:}
;1306:
;1307:const char *COM_ParseExt( const char **data_p, qboolean allowLineBreaks )
;1308:{
line 1309
;1309:	int c = 0, len;
ADDRLP4 4
CNSTI4 0
ASGNI4
line 1310
;1310:	qboolean hasNewLines = qfalse;
ADDRLP4 12
CNSTI4 0
ASGNI4
line 1313
;1311:	const char *data;
;1312:
;1313:	data = *data_p;
ADDRLP4 0
ADDRFP4 0
INDIRP4
INDIRP4
ASGNP4
line 1314
;1314:	len = 0;
ADDRLP4 8
CNSTI4 0
ASGNI4
line 1315
;1315:	com_token[0] = '\0';
ADDRGP4 com_token
CNSTI1 0
ASGNI1
line 1316
;1316:	com_tokenline = 0;
ADDRGP4 com_tokenline
CNSTU4 0
ASGNU4
line 1319
;1317:
;1318:	// make sure incoming data is valid
;1319:	if ( !data ) {
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $584
line 1320
;1320:		*data_p = NULL;
ADDRFP4 0
INDIRP4
CNSTP4 0
ASGNP4
line 1321
;1321:		return com_token;
ADDRGP4 com_token
RETP4
ADDRGP4 $580
JUMPV
LABELV $583
line 1324
;1322:	}
;1323:
;1324:	while ( 1 ) {
line 1326
;1325:		// skip whitespace
;1326:		data = SkipWhitespace( data, &hasNewLines );
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 12
ARGP4
ADDRLP4 16
ADDRGP4 SkipWhitespace
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 16
INDIRP4
ASGNP4
line 1327
;1327:		if ( !data ) {
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $586
line 1328
;1328:			*data_p = NULL;
ADDRFP4 0
INDIRP4
CNSTP4 0
ASGNP4
line 1329
;1329:			return com_token;
ADDRGP4 com_token
RETP4
ADDRGP4 $580
JUMPV
LABELV $586
line 1331
;1330:		}
;1331:		if ( hasNewLines && !allowLineBreaks ) {
ADDRLP4 20
CNSTI4 0
ASGNI4
ADDRLP4 12
INDIRI4
ADDRLP4 20
INDIRI4
EQI4 $588
ADDRFP4 4
INDIRI4
ADDRLP4 20
INDIRI4
NEI4 $588
line 1332
;1332:			*data_p = data;
ADDRFP4 0
INDIRP4
ADDRLP4 0
INDIRP4
ASGNP4
line 1333
;1333:			return com_token;
ADDRGP4 com_token
RETP4
ADDRGP4 $580
JUMPV
LABELV $588
line 1336
;1334:		}
;1335:
;1336:		c = *data;
ADDRLP4 4
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
line 1339
;1337:
;1338:		// skip double slash comments
;1339:		if ( c == '/' && data[1] == '/' ) {
ADDRLP4 24
CNSTI4 47
ASGNI4
ADDRLP4 4
INDIRI4
ADDRLP4 24
INDIRI4
NEI4 $590
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
INDIRI1
CVII4 1
ADDRLP4 24
INDIRI4
NEI4 $590
line 1340
;1340:			data += 2;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 2
ADDP4
ASGNP4
ADDRGP4 $593
JUMPV
LABELV $592
line 1341
;1341:			while (*data && *data != '\n') {
line 1342
;1342:				data++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1343
;1343:			}
LABELV $593
line 1341
ADDRLP4 28
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 28
INDIRI4
CNSTI4 0
EQI4 $595
ADDRLP4 28
INDIRI4
CNSTI4 10
NEI4 $592
LABELV $595
line 1344
;1344:		}
ADDRGP4 $591
JUMPV
LABELV $590
line 1346
;1345:		// skip /* */ comments
;1346:		else if ( c == '/' && data[1] == '*' ) {
ADDRLP4 4
INDIRI4
CNSTI4 47
NEI4 $585
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
INDIRI1
CVII4 1
CNSTI4 42
NEI4 $585
line 1347
;1347:			data += 2;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 2
ADDP4
ASGNP4
ADDRGP4 $599
JUMPV
LABELV $598
line 1348
;1348:			while ( *data && ( *data != '*' || data[1] != '/' ) ) {
line 1349
;1349:				if ( *data == '\n' ) {
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 10
NEI4 $601
line 1350
;1350:					com_lines++;
ADDRLP4 28
ADDRGP4 com_lines
ASGNP4
ADDRLP4 28
INDIRP4
ADDRLP4 28
INDIRP4
INDIRU4
CNSTU4 1
ADDU4
ASGNU4
line 1351
;1351:				}
LABELV $601
line 1352
;1352:				data++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1353
;1353:			}
LABELV $599
line 1348
ADDRLP4 32
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 32
INDIRI4
CNSTI4 0
EQI4 $603
ADDRLP4 32
INDIRI4
CNSTI4 42
NEI4 $598
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
INDIRI1
CVII4 1
CNSTI4 47
NEI4 $598
LABELV $603
line 1354
;1354:			if ( *data ) {
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
EQI4 $597
line 1355
;1355:				data += 2;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 2
ADDP4
ASGNP4
line 1356
;1356:			}
line 1357
;1357:		}
line 1358
;1358:		else {
line 1359
;1359:			break;
LABELV $597
LABELV $591
line 1361
;1360:		}
;1361:	}
LABELV $584
line 1324
ADDRGP4 $583
JUMPV
LABELV $585
line 1364
;1362:
;1363:	// token starts on this line
;1364:	com_tokenline = com_lines;
ADDRGP4 com_tokenline
ADDRGP4 com_lines
INDIRU4
ASGNU4
line 1367
;1365:
;1366:	// handle quoted strings
;1367:	if ( c == '"' )
ADDRLP4 4
INDIRI4
CNSTI4 34
NEI4 $606
line 1368
;1368:	{
line 1369
;1369:		data++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRGP4 $609
JUMPV
LABELV $608
line 1371
;1370:		while ( 1 )
;1371:		{
line 1372
;1372:			c = *data;
ADDRLP4 4
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
line 1373
;1373:			if ( c == '"' || c == '\0' )
ADDRLP4 4
INDIRI4
CNSTI4 34
EQI4 $613
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $611
LABELV $613
line 1374
;1374:			{
line 1375
;1375:				if ( c == '"' )
ADDRLP4 4
INDIRI4
CNSTI4 34
NEI4 $614
line 1376
;1376:					data++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
LABELV $614
line 1377
;1377:				com_token[ len ] = '\0';
ADDRLP4 8
INDIRI4
ADDRGP4 com_token
ADDP4
CNSTI1 0
ASGNI1
line 1378
;1378:				*data_p = data;
ADDRFP4 0
INDIRP4
ADDRLP4 0
INDIRP4
ASGNP4
line 1379
;1379:				return com_token;
ADDRGP4 com_token
RETP4
ADDRGP4 $580
JUMPV
LABELV $611
line 1381
;1380:			}
;1381:			data++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1382
;1382:			if ( c == '\n' )
ADDRLP4 4
INDIRI4
CNSTI4 10
NEI4 $616
line 1383
;1383:			{
line 1384
;1384:				com_lines++;
ADDRLP4 20
ADDRGP4 com_lines
ASGNP4
ADDRLP4 20
INDIRP4
ADDRLP4 20
INDIRP4
INDIRU4
CNSTU4 1
ADDU4
ASGNU4
line 1385
;1385:			}
LABELV $616
line 1386
;1386:			if ( len < arraylen( com_token )-1 )
ADDRLP4 8
INDIRI4
CVIU4 4
CNSTU4 1023
GEU4 $618
line 1387
;1387:			{
line 1388
;1388:				com_token[ len ] = c;
ADDRLP4 8
INDIRI4
ADDRGP4 com_token
ADDP4
ADDRLP4 4
INDIRI4
CVII1 4
ASGNI1
line 1389
;1389:				len++;
ADDRLP4 8
ADDRLP4 8
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
line 1390
;1390:			}
LABELV $618
line 1391
;1391:		}
LABELV $609
line 1370
ADDRGP4 $608
JUMPV
line 1392
;1392:	}
LABELV $606
LABELV $620
line 1396
;1393:
;1394:	// parse a regular word
;1395:	do
;1396:	{
line 1397
;1397:		if ( len < arraylen( com_token )-1 )
ADDRLP4 8
INDIRI4
CVIU4 4
CNSTU4 1023
GEU4 $623
line 1398
;1398:		{
line 1399
;1399:			com_token[ len ] = c;
ADDRLP4 8
INDIRI4
ADDRGP4 com_token
ADDP4
ADDRLP4 4
INDIRI4
CVII1 4
ASGNI1
line 1400
;1400:			len++;
ADDRLP4 8
ADDRLP4 8
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
line 1401
;1401:		}
LABELV $623
line 1402
;1402:		data++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1403
;1403:		c = *data;
ADDRLP4 4
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
line 1404
;1404:	} while ( c > ' ' );
LABELV $621
ADDRLP4 4
INDIRI4
CNSTI4 32
GTI4 $620
line 1406
;1405:
;1406:	com_token[ len ] = '\0';
ADDRLP4 8
INDIRI4
ADDRGP4 com_token
ADDP4
CNSTI1 0
ASGNI1
line 1408
;1407:
;1408:	*data_p = data;
ADDRFP4 0
INDIRP4
ADDRLP4 0
INDIRP4
ASGNP4
line 1409
;1409:	return com_token;
ADDRGP4 com_token
RETP4
LABELV $580
endproc COM_ParseExt 36 8
lit
align 1
LABELV $626
byte 1 1
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 1
byte 1 1
byte 1 0
byte 1 0
byte 1 1
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 1
byte 1 1
byte 1 1
byte 1 1
byte 1 1
byte 1 1
byte 1 1
byte 1 1
byte 1 1
byte 1 1
byte 1 1
byte 1 1
byte 1 1
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 1
byte 1 1
byte 1 1
byte 1 1
byte 1 1
byte 1 1
byte 1 1
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 1
byte 1 0
byte 1 1
byte 1 1
byte 1 0
byte 1 1
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 0
byte 1 1
byte 1 1
byte 1 1
byte 1 1
byte 1 1
skip 128
export COM_ParseComplex
code
proc COM_ParseComplex 208 0
line 1419
;1410:}
;1411:	
;1412:
;1413:/*
;1414:==============
;1415:COM_ParseComplex
;1416:==============
;1417:*/
;1418:char *COM_ParseComplex( const char **data_p, qboolean allowLineBreaks )
;1419:{
line 1443
;1420:	static const byte is_separator[ 256 ] =
;1421:	{
;1422:	// \0 . . . . . . .\b\t\n . .\r . .
;1423:		1,0,0,0,0,0,0,0,0,1,1,0,0,1,0,0,
;1424:	//  . . . . . . . . . . . . . . . .
;1425:		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
;1426:	//    ! " # $ % & ' ( ) * + , - . /
;1427:		1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0, // excl. '-' '.' '/'
;1428:	//  0 1 2 3 4 5 6 7 8 9 : ; < = > ?
;1429:		0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,
;1430:	//  @ A B C D E F G H I J K L M N O
;1431:		1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
;1432:	//  P Q R S T U V W X Y Z [ \ ] ^ _
;1433:		0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0, // excl. '\\' '_'
;1434:	//  ` a b c d e f g h i j k l m n o
;1435:		1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
;1436:	//  p q r s t u v w x y z { | } ~ 
;1437:		0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1
;1438:	};
;1439:
;1440:	int c, len, shift;
;1441:	const byte *str;
;1442:
;1443:	str = (byte*)*data_p;
ADDRLP4 0
ADDRFP4 0
INDIRP4
INDIRP4
ASGNP4
line 1444
;1444:	len = 0; 
ADDRLP4 8
CNSTI4 0
ASGNI4
line 1445
;1445:	shift = 0; // token line shift relative to com_lines
ADDRLP4 12
CNSTI4 0
ASGNI4
line 1446
;1446:	com_tokentype = TK_GENEGIC;
ADDRGP4 com_tokentype
CNSTI4 0
ASGNI4
LABELV $627
line 1449
;1447:	
;1448:__reswitch:
;1449:	switch ( *str )
ADDRLP4 16
ADDRLP4 0
INDIRP4
INDIRU1
CVUI4 1
ASGNI4
ADDRLP4 16
INDIRI4
CNSTI4 32
LTI4 $701
ADDRLP4 16
INDIRI4
CNSTI4 63
GTI4 $702
ADDRLP4 16
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 $703-128
ADDP4
INDIRP4
JUMPV
lit
align 4
LABELV $703
address $632
address $678
address $662
address $628
address $628
address $674
address $693
address $628
address $676
address $677
address $675
address $674
address $674
address $628
address $628
address $641
address $628
address $628
address $628
address $628
address $628
address $628
address $628
address $628
address $628
address $628
address $674
address $674
address $687
address $681
address $684
address $674
code
LABELV $701
ADDRLP4 28
CNSTI4 0
ASGNI4
ADDRLP4 16
INDIRI4
ADDRLP4 28
INDIRI4
EQI4 $631
ADDRLP4 16
INDIRI4
ADDRLP4 28
INDIRI4
LTI4 $628
LABELV $705
ADDRLP4 16
INDIRI4
CNSTI4 9
EQI4 $632
ADDRLP4 16
INDIRI4
CNSTI4 10
EQI4 $636
ADDRLP4 16
INDIRI4
CNSTI4 13
EQI4 $636
ADDRGP4 $628
JUMPV
LABELV $702
ADDRLP4 16
INDIRI4
CNSTI4 91
LTI4 $628
ADDRLP4 16
INDIRI4
CNSTI4 96
GTI4 $706
ADDRLP4 16
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 $707-364
ADDP4
INDIRP4
JUMPV
lit
align 4
LABELV $707
address $674
address $628
address $674
address $674
address $628
address $674
code
LABELV $706
ADDRLP4 16
INDIRI4
CNSTI4 123
LTI4 $628
ADDRLP4 16
INDIRI4
CNSTI4 126
GTI4 $628
ADDRLP4 16
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 $709-492
ADDP4
INDIRP4
JUMPV
lit
align 4
LABELV $709
address $674
address $690
address $674
address $674
code
line 1450
;1450:	{
LABELV $631
line 1452
;1451:	case '\0':
;1452:		com_tokentype = TK_EOF;
ADDRGP4 com_tokentype
CNSTI4 15
ASGNI4
line 1453
;1453:		break;
ADDRGP4 $629
JUMPV
LABELV $632
line 1458
;1454:
;1455:	// whitespace
;1456:	case ' ':
;1457:	case '\t':
;1458:		str++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRGP4 $634
JUMPV
LABELV $633
line 1460
;1459:		while ( (c = *str) == ' ' || c == '\t' )
;1460:			str++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
LABELV $634
line 1459
ADDRLP4 44
ADDRLP4 0
INDIRP4
INDIRU1
CVUI4 1
ASGNI4
ADDRLP4 4
ADDRLP4 44
INDIRI4
ASGNI4
ADDRLP4 44
INDIRI4
CNSTI4 32
EQI4 $633
ADDRLP4 4
INDIRI4
CNSTI4 9
EQI4 $633
line 1461
;1461:		goto __reswitch;
ADDRGP4 $627
JUMPV
LABELV $636
line 1466
;1462:
;1463:	// newlines
;1464:	case '\n':
;1465:	case '\r':
;1466:	com_lines++;
ADDRLP4 48
ADDRGP4 com_lines
ASGNP4
ADDRLP4 48
INDIRP4
ADDRLP4 48
INDIRP4
INDIRU4
CNSTU4 1
ADDU4
ASGNU4
line 1467
;1467:		if ( *str == '\r' && str[1] == '\n' )
ADDRLP4 0
INDIRP4
INDIRU1
CVUI4 1
CNSTI4 13
NEI4 $637
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
INDIRU1
CVUI4 1
CNSTI4 10
NEI4 $637
line 1468
;1468:			str += 2; // CR+LF
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 2
ADDP4
ASGNP4
ADDRGP4 $638
JUMPV
LABELV $637
line 1470
;1469:		else
;1470:			str++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
LABELV $638
line 1471
;1471:		if ( !allowLineBreaks ) {
ADDRFP4 4
INDIRI4
CNSTI4 0
NEI4 $627
line 1472
;1472:			com_tokentype = TK_NEWLINE;
ADDRGP4 com_tokentype
CNSTI4 14
ASGNI4
line 1473
;1473:			break;
ADDRGP4 $629
JUMPV
line 1475
;1474:		}
;1475:		goto __reswitch;
LABELV $641
line 1480
;1476:
;1477:	// comments, single slash
;1478:	case '/':
;1479:		// until end of line
;1480:		if ( str[1] == '/' ) {
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
INDIRU1
CVUI4 1
CNSTI4 47
NEI4 $642
line 1481
;1481:			str += 2;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 2
ADDP4
ASGNP4
ADDRGP4 $645
JUMPV
LABELV $644
line 1483
;1482:			while ( (c = *str) != '\0' && c != '\n' && c != '\r' )
;1483:				str++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
LABELV $645
line 1482
ADDRLP4 56
ADDRLP4 0
INDIRP4
INDIRU1
CVUI4 1
ASGNI4
ADDRLP4 4
ADDRLP4 56
INDIRI4
ASGNI4
ADDRLP4 56
INDIRI4
CNSTI4 0
EQI4 $648
ADDRLP4 4
INDIRI4
CNSTI4 10
EQI4 $648
ADDRLP4 4
INDIRI4
CNSTI4 13
NEI4 $644
LABELV $648
line 1484
;1484:			goto __reswitch;
ADDRGP4 $627
JUMPV
LABELV $642
line 1488
;1485:		}
;1486:
;1487:		// comment
;1488:		if ( str[1] == '*' ) {
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
INDIRU1
CVUI4 1
CNSTI4 42
NEI4 $649
line 1489
;1489:			str += 2;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 2
ADDP4
ASGNP4
ADDRGP4 $652
JUMPV
LABELV $651
line 1490
;1490:			while ( (c = *str) != '\0' && ( c != '*' || str[1] != '/' ) ) {
line 1491
;1491:				if ( c == '\n' || c == '\r' ) {
ADDRLP4 4
INDIRI4
CNSTI4 10
EQI4 $656
ADDRLP4 4
INDIRI4
CNSTI4 13
NEI4 $654
LABELV $656
line 1492
;1492:					com_lines++;
ADDRLP4 60
ADDRGP4 com_lines
ASGNP4
ADDRLP4 60
INDIRP4
ADDRLP4 60
INDIRP4
INDIRU4
CNSTU4 1
ADDU4
ASGNU4
line 1493
;1493:					if ( c == '\r' && str[1] == '\n' ) // CR+LF?
ADDRLP4 4
INDIRI4
CNSTI4 13
NEI4 $657
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
INDIRU1
CVUI4 1
CNSTI4 10
NEI4 $657
line 1494
;1494:						str++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
LABELV $657
line 1495
;1495:				}
LABELV $654
line 1496
;1496:				str++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1497
;1497:			}
LABELV $652
line 1490
ADDRLP4 60
ADDRLP4 0
INDIRP4
INDIRU1
CVUI4 1
ASGNI4
ADDRLP4 4
ADDRLP4 60
INDIRI4
ASGNI4
ADDRLP4 60
INDIRI4
CNSTI4 0
EQI4 $659
ADDRLP4 4
INDIRI4
CNSTI4 42
NEI4 $651
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
INDIRU1
CVUI4 1
CNSTI4 47
NEI4 $651
LABELV $659
line 1498
;1498:			if ( c != '\0' && str[1] != '\0' ) {
ADDRLP4 64
CNSTI4 0
ASGNI4
ADDRLP4 4
INDIRI4
ADDRLP4 64
INDIRI4
EQI4 $627
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
INDIRU1
CVUI4 1
ADDRLP4 64
INDIRI4
EQI4 $627
line 1499
;1499:				str += 2;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 2
ADDP4
ASGNP4
line 1500
;1500:			} else {
line 1502
;1501:				// FIXME: unterminated comment?
;1502:			}
line 1503
;1503:			goto __reswitch;
ADDRGP4 $627
JUMPV
LABELV $649
line 1507
;1504:		}
;1505:
;1506:		// single slash
;1507:		com_token[ len++ ] = *str++;
ADDRLP4 56
ADDRLP4 8
INDIRI4
ASGNI4
ADDRLP4 64
CNSTI4 1
ASGNI4
ADDRLP4 8
ADDRLP4 56
INDIRI4
ADDRLP4 64
INDIRI4
ADDI4
ASGNI4
ADDRLP4 60
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 60
INDIRP4
ADDRLP4 64
INDIRI4
ADDP4
ASGNP4
ADDRLP4 56
INDIRI4
ADDRGP4 com_token
ADDP4
ADDRLP4 60
INDIRP4
INDIRU1
CVUI4 1
CVII1 4
ASGNI1
line 1508
;1508:		break;
ADDRGP4 $629
JUMPV
LABELV $662
line 1512
;1509:	
;1510:	// quoted string?
;1511:	case '"':
;1512:		str++; // skip leading '"'
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRGP4 $664
JUMPV
LABELV $663
line 1514
;1513:		//com_tokenline = com_lines;
;1514:		while ( (c = *str) != '\0' && c != '"' ) {
line 1515
;1515:			if ( c == '\n' || c == '\r' ) {
ADDRLP4 4
INDIRI4
CNSTI4 10
EQI4 $668
ADDRLP4 4
INDIRI4
CNSTI4 13
NEI4 $666
LABELV $668
line 1516
;1516:				com_lines++; // FIXME: unterminated quoted string?
ADDRLP4 72
ADDRGP4 com_lines
ASGNP4
ADDRLP4 72
INDIRP4
ADDRLP4 72
INDIRP4
INDIRU4
CNSTU4 1
ADDU4
ASGNU4
line 1517
;1517:				shift++;
ADDRLP4 12
ADDRLP4 12
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
line 1518
;1518:			}
LABELV $666
line 1519
;1519:			if ( len < MAX_TOKEN_CHARS-1 ) // overflow check
ADDRLP4 8
INDIRI4
CNSTI4 1023
GEI4 $669
line 1520
;1520:				com_token[ len++ ] = c;
ADDRLP4 72
ADDRLP4 8
INDIRI4
ASGNI4
ADDRLP4 8
ADDRLP4 72
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 72
INDIRI4
ADDRGP4 com_token
ADDP4
ADDRLP4 4
INDIRI4
CVII1 4
ASGNI1
LABELV $669
line 1521
;1521:			str++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1522
;1522:		}
LABELV $664
line 1514
ADDRLP4 68
ADDRLP4 0
INDIRP4
INDIRU1
CVUI4 1
ASGNI4
ADDRLP4 4
ADDRLP4 68
INDIRI4
ASGNI4
ADDRLP4 68
INDIRI4
CNSTI4 0
EQI4 $671
ADDRLP4 4
INDIRI4
CNSTI4 34
NEI4 $663
LABELV $671
line 1523
;1523:		if ( c != '\0' ) {
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $672
line 1524
;1524:			str++; // skip ending '"'
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1525
;1525:		} else {
LABELV $672
line 1527
;1526:			// FIXME: unterminated quoted string?
;1527:		}
LABELV $673
line 1528
;1528:		com_tokentype = TK_QUOTED;
ADDRGP4 com_tokentype
CNSTI4 2
ASGNI4
line 1529
;1529:		break;
ADDRGP4 $629
JUMPV
LABELV $674
line 1539
;1530:
;1531:	// single tokens:
;1532:	case '+': case '`':
;1533:	/*case '*':*/ case '~':
;1534:	case '{': case '}':
;1535:	case '[': case ']':
;1536:	case '?': case ',':
;1537:	case ':': case ';':
;1538:	case '%': case '^':
;1539:		com_token[ len++ ] = *str++;
ADDRLP4 72
ADDRLP4 8
INDIRI4
ASGNI4
ADDRLP4 80
CNSTI4 1
ASGNI4
ADDRLP4 8
ADDRLP4 72
INDIRI4
ADDRLP4 80
INDIRI4
ADDI4
ASGNI4
ADDRLP4 76
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 76
INDIRP4
ADDRLP4 80
INDIRI4
ADDP4
ASGNP4
ADDRLP4 72
INDIRI4
ADDRGP4 com_token
ADDP4
ADDRLP4 76
INDIRP4
INDIRU1
CVUI4 1
CVII1 4
ASGNI1
line 1540
;1540:		break;
ADDRGP4 $629
JUMPV
LABELV $675
line 1543
;1541:
;1542:	case '*':
;1543:		com_token[ len++ ] = *str++;
ADDRLP4 84
ADDRLP4 8
INDIRI4
ASGNI4
ADDRLP4 92
CNSTI4 1
ASGNI4
ADDRLP4 8
ADDRLP4 84
INDIRI4
ADDRLP4 92
INDIRI4
ADDI4
ASGNI4
ADDRLP4 88
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 88
INDIRP4
ADDRLP4 92
INDIRI4
ADDP4
ASGNP4
ADDRLP4 84
INDIRI4
ADDRGP4 com_token
ADDP4
ADDRLP4 88
INDIRP4
INDIRU1
CVUI4 1
CVII1 4
ASGNI1
line 1544
;1544:		com_tokentype = TK_MATCH;
ADDRGP4 com_tokentype
CNSTI4 9
ASGNI4
line 1545
;1545:		break;
ADDRGP4 $629
JUMPV
LABELV $676
line 1548
;1546:
;1547:	case '(':
;1548:		com_token[ len++ ] = *str++;
ADDRLP4 96
ADDRLP4 8
INDIRI4
ASGNI4
ADDRLP4 104
CNSTI4 1
ASGNI4
ADDRLP4 8
ADDRLP4 96
INDIRI4
ADDRLP4 104
INDIRI4
ADDI4
ASGNI4
ADDRLP4 100
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 100
INDIRP4
ADDRLP4 104
INDIRI4
ADDP4
ASGNP4
ADDRLP4 96
INDIRI4
ADDRGP4 com_token
ADDP4
ADDRLP4 100
INDIRP4
INDIRU1
CVUI4 1
CVII1 4
ASGNI1
line 1549
;1549:		com_tokentype = TK_SCOPE_OPEN;
ADDRGP4 com_tokentype
CNSTI4 12
ASGNI4
line 1550
;1550:		break;
ADDRGP4 $629
JUMPV
LABELV $677
line 1553
;1551:
;1552:	case ')':
;1553:		com_token[ len++ ] = *str++;
ADDRLP4 108
ADDRLP4 8
INDIRI4
ASGNI4
ADDRLP4 116
CNSTI4 1
ASGNI4
ADDRLP4 8
ADDRLP4 108
INDIRI4
ADDRLP4 116
INDIRI4
ADDI4
ASGNI4
ADDRLP4 112
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 112
INDIRP4
ADDRLP4 116
INDIRI4
ADDP4
ASGNP4
ADDRLP4 108
INDIRI4
ADDRGP4 com_token
ADDP4
ADDRLP4 112
INDIRP4
INDIRU1
CVUI4 1
CVII1 4
ASGNI1
line 1554
;1554:		com_tokentype = TK_SCOPE_CLOSE;
ADDRGP4 com_tokentype
CNSTI4 13
ASGNI4
line 1555
;1555:		break;
ADDRGP4 $629
JUMPV
LABELV $678
line 1559
;1556:
;1557:	// !, !=
;1558:	case '!':
;1559:		com_token[ len++ ] = *str++;
ADDRLP4 120
ADDRLP4 8
INDIRI4
ASGNI4
ADDRLP4 128
CNSTI4 1
ASGNI4
ADDRLP4 8
ADDRLP4 120
INDIRI4
ADDRLP4 128
INDIRI4
ADDI4
ASGNI4
ADDRLP4 124
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 124
INDIRP4
ADDRLP4 128
INDIRI4
ADDP4
ASGNP4
ADDRLP4 120
INDIRI4
ADDRGP4 com_token
ADDP4
ADDRLP4 124
INDIRP4
INDIRU1
CVUI4 1
CVII1 4
ASGNI1
line 1560
;1560:		if ( *str == '=' ) {
ADDRLP4 0
INDIRP4
INDIRU1
CVUI4 1
CNSTI4 61
NEI4 $629
line 1561
;1561:			com_token[ len++ ] = *str++;
ADDRLP4 132
ADDRLP4 8
INDIRI4
ASGNI4
ADDRLP4 140
CNSTI4 1
ASGNI4
ADDRLP4 8
ADDRLP4 132
INDIRI4
ADDRLP4 140
INDIRI4
ADDI4
ASGNI4
ADDRLP4 136
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 136
INDIRP4
ADDRLP4 140
INDIRI4
ADDP4
ASGNP4
ADDRLP4 132
INDIRI4
ADDRGP4 com_token
ADDP4
ADDRLP4 136
INDIRP4
INDIRU1
CVUI4 1
CVII1 4
ASGNI1
line 1562
;1562:			com_tokentype = TK_NEQ;
ADDRGP4 com_tokentype
CNSTI4 4
ASGNI4
line 1563
;1563:		}
line 1564
;1564:		break;
ADDRGP4 $629
JUMPV
LABELV $681
line 1568
;1565:
;1566:	// =, ==
;1567:	case '=':
;1568:		com_token[ len++ ] = *str++;
ADDRLP4 132
ADDRLP4 8
INDIRI4
ASGNI4
ADDRLP4 140
CNSTI4 1
ASGNI4
ADDRLP4 8
ADDRLP4 132
INDIRI4
ADDRLP4 140
INDIRI4
ADDI4
ASGNI4
ADDRLP4 136
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 136
INDIRP4
ADDRLP4 140
INDIRI4
ADDP4
ASGNP4
ADDRLP4 132
INDIRI4
ADDRGP4 com_token
ADDP4
ADDRLP4 136
INDIRP4
INDIRU1
CVUI4 1
CVII1 4
ASGNI1
line 1569
;1569:		if ( *str == '=' ) {
ADDRLP4 0
INDIRP4
INDIRU1
CVUI4 1
CNSTI4 61
NEI4 $629
line 1570
;1570:			com_token[ len++ ] = *str++;
ADDRLP4 144
ADDRLP4 8
INDIRI4
ASGNI4
ADDRLP4 152
CNSTI4 1
ASGNI4
ADDRLP4 8
ADDRLP4 144
INDIRI4
ADDRLP4 152
INDIRI4
ADDI4
ASGNI4
ADDRLP4 148
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 148
INDIRP4
ADDRLP4 152
INDIRI4
ADDP4
ASGNP4
ADDRLP4 144
INDIRI4
ADDRGP4 com_token
ADDP4
ADDRLP4 148
INDIRP4
INDIRU1
CVUI4 1
CVII1 4
ASGNI1
line 1571
;1571:			com_tokentype = TK_EQ;
ADDRGP4 com_tokentype
CNSTI4 3
ASGNI4
line 1572
;1572:		}
line 1573
;1573:		break;
ADDRGP4 $629
JUMPV
LABELV $684
line 1577
;1574:
;1575:	// >, >=
;1576:	case '>':
;1577:		com_token[ len++ ] = *str++;
ADDRLP4 144
ADDRLP4 8
INDIRI4
ASGNI4
ADDRLP4 152
CNSTI4 1
ASGNI4
ADDRLP4 8
ADDRLP4 144
INDIRI4
ADDRLP4 152
INDIRI4
ADDI4
ASGNI4
ADDRLP4 148
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 148
INDIRP4
ADDRLP4 152
INDIRI4
ADDP4
ASGNP4
ADDRLP4 144
INDIRI4
ADDRGP4 com_token
ADDP4
ADDRLP4 148
INDIRP4
INDIRU1
CVUI4 1
CVII1 4
ASGNI1
line 1578
;1578:		if ( *str == '=' ) {
ADDRLP4 0
INDIRP4
INDIRU1
CVUI4 1
CNSTI4 61
NEI4 $685
line 1579
;1579:			com_token[ len++ ] = *str++;
ADDRLP4 156
ADDRLP4 8
INDIRI4
ASGNI4
ADDRLP4 164
CNSTI4 1
ASGNI4
ADDRLP4 8
ADDRLP4 156
INDIRI4
ADDRLP4 164
INDIRI4
ADDI4
ASGNI4
ADDRLP4 160
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 160
INDIRP4
ADDRLP4 164
INDIRI4
ADDP4
ASGNP4
ADDRLP4 156
INDIRI4
ADDRGP4 com_token
ADDP4
ADDRLP4 160
INDIRP4
INDIRU1
CVUI4 1
CVII1 4
ASGNI1
line 1580
;1580:			com_tokentype = TK_GTE;
ADDRGP4 com_tokentype
CNSTI4 6
ASGNI4
line 1581
;1581:		} else {
ADDRGP4 $629
JUMPV
LABELV $685
line 1582
;1582:			com_tokentype = TK_GT;
ADDRGP4 com_tokentype
CNSTI4 5
ASGNI4
line 1583
;1583:		}
line 1584
;1584:		break;
ADDRGP4 $629
JUMPV
LABELV $687
line 1588
;1585:
;1586:	//  <, <=
;1587:	case '<':
;1588:		com_token[ len++ ] = *str++;
ADDRLP4 156
ADDRLP4 8
INDIRI4
ASGNI4
ADDRLP4 164
CNSTI4 1
ASGNI4
ADDRLP4 8
ADDRLP4 156
INDIRI4
ADDRLP4 164
INDIRI4
ADDI4
ASGNI4
ADDRLP4 160
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 160
INDIRP4
ADDRLP4 164
INDIRI4
ADDP4
ASGNP4
ADDRLP4 156
INDIRI4
ADDRGP4 com_token
ADDP4
ADDRLP4 160
INDIRP4
INDIRU1
CVUI4 1
CVII1 4
ASGNI1
line 1589
;1589:		if ( *str == '=' ) {
ADDRLP4 0
INDIRP4
INDIRU1
CVUI4 1
CNSTI4 61
NEI4 $688
line 1590
;1590:			com_token[ len++ ] = *str++;
ADDRLP4 168
ADDRLP4 8
INDIRI4
ASGNI4
ADDRLP4 176
CNSTI4 1
ASGNI4
ADDRLP4 8
ADDRLP4 168
INDIRI4
ADDRLP4 176
INDIRI4
ADDI4
ASGNI4
ADDRLP4 172
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 172
INDIRP4
ADDRLP4 176
INDIRI4
ADDP4
ASGNP4
ADDRLP4 168
INDIRI4
ADDRGP4 com_token
ADDP4
ADDRLP4 172
INDIRP4
INDIRU1
CVUI4 1
CVII1 4
ASGNI1
line 1591
;1591:			com_tokentype = TK_LTE;
ADDRGP4 com_tokentype
CNSTI4 8
ASGNI4
line 1592
;1592:		} else {
ADDRGP4 $629
JUMPV
LABELV $688
line 1593
;1593:			com_tokentype = TK_LT;
ADDRGP4 com_tokentype
CNSTI4 7
ASGNI4
line 1594
;1594:		}
line 1595
;1595:		break;
ADDRGP4 $629
JUMPV
LABELV $690
line 1599
;1596:
;1597:	// |, ||
;1598:	case '|':
;1599:		com_token[ len++ ] = *str++;
ADDRLP4 168
ADDRLP4 8
INDIRI4
ASGNI4
ADDRLP4 176
CNSTI4 1
ASGNI4
ADDRLP4 8
ADDRLP4 168
INDIRI4
ADDRLP4 176
INDIRI4
ADDI4
ASGNI4
ADDRLP4 172
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 172
INDIRP4
ADDRLP4 176
INDIRI4
ADDP4
ASGNP4
ADDRLP4 168
INDIRI4
ADDRGP4 com_token
ADDP4
ADDRLP4 172
INDIRP4
INDIRU1
CVUI4 1
CVII1 4
ASGNI1
line 1600
;1600:		if ( *str == '|' ) {
ADDRLP4 0
INDIRP4
INDIRU1
CVUI4 1
CNSTI4 124
NEI4 $629
line 1601
;1601:			com_token[ len++ ] = *str++;
ADDRLP4 180
ADDRLP4 8
INDIRI4
ASGNI4
ADDRLP4 188
CNSTI4 1
ASGNI4
ADDRLP4 8
ADDRLP4 180
INDIRI4
ADDRLP4 188
INDIRI4
ADDI4
ASGNI4
ADDRLP4 184
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 184
INDIRP4
ADDRLP4 188
INDIRI4
ADDP4
ASGNP4
ADDRLP4 180
INDIRI4
ADDRGP4 com_token
ADDP4
ADDRLP4 184
INDIRP4
INDIRU1
CVUI4 1
CVII1 4
ASGNI1
line 1602
;1602:			com_tokentype = TK_OR;
ADDRGP4 com_tokentype
CNSTI4 10
ASGNI4
line 1603
;1603:		}
line 1604
;1604:		break;
ADDRGP4 $629
JUMPV
LABELV $693
line 1608
;1605:
;1606:	// &, &&
;1607:	case '&':
;1608:		com_token[ len++ ] = *str++;
ADDRLP4 180
ADDRLP4 8
INDIRI4
ASGNI4
ADDRLP4 188
CNSTI4 1
ASGNI4
ADDRLP4 8
ADDRLP4 180
INDIRI4
ADDRLP4 188
INDIRI4
ADDI4
ASGNI4
ADDRLP4 184
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 184
INDIRP4
ADDRLP4 188
INDIRI4
ADDP4
ASGNP4
ADDRLP4 180
INDIRI4
ADDRGP4 com_token
ADDP4
ADDRLP4 184
INDIRP4
INDIRU1
CVUI4 1
CVII1 4
ASGNI1
line 1609
;1609:		if ( *str == '&' ) {
ADDRLP4 0
INDIRP4
INDIRU1
CVUI4 1
CNSTI4 38
NEI4 $629
line 1610
;1610:			com_token[ len++ ] = *str++;
ADDRLP4 192
ADDRLP4 8
INDIRI4
ASGNI4
ADDRLP4 200
CNSTI4 1
ASGNI4
ADDRLP4 8
ADDRLP4 192
INDIRI4
ADDRLP4 200
INDIRI4
ADDI4
ASGNI4
ADDRLP4 196
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 196
INDIRP4
ADDRLP4 200
INDIRI4
ADDP4
ASGNP4
ADDRLP4 192
INDIRI4
ADDRGP4 com_token
ADDP4
ADDRLP4 196
INDIRP4
INDIRU1
CVUI4 1
CVII1 4
ASGNI1
line 1611
;1611:			com_tokentype = TK_AND;
ADDRGP4 com_tokentype
CNSTI4 11
ASGNI4
line 1612
;1612:		}
line 1613
;1613:		break;
ADDRGP4 $629
JUMPV
LABELV $628
line 1617
;1614:
;1615:	// rest of the charset
;1616:	default:
;1617:		com_token[ len++ ] = *str++;
ADDRLP4 192
ADDRLP4 8
INDIRI4
ASGNI4
ADDRLP4 200
CNSTI4 1
ASGNI4
ADDRLP4 8
ADDRLP4 192
INDIRI4
ADDRLP4 200
INDIRI4
ADDI4
ASGNI4
ADDRLP4 196
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 196
INDIRP4
ADDRLP4 200
INDIRI4
ADDP4
ASGNP4
ADDRLP4 192
INDIRI4
ADDRGP4 com_token
ADDP4
ADDRLP4 196
INDIRP4
INDIRU1
CVUI4 1
CVII1 4
ASGNI1
ADDRGP4 $697
JUMPV
LABELV $696
line 1618
;1618:		while ( !is_separator[ (c = *str) ] ) {
line 1619
;1619:			if ( len < MAX_TOKEN_CHARS-1 )
ADDRLP4 8
INDIRI4
CNSTI4 1023
GEI4 $699
line 1620
;1620:				com_token[ len++ ] = c;
ADDRLP4 204
ADDRLP4 8
INDIRI4
ASGNI4
ADDRLP4 8
ADDRLP4 204
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 204
INDIRI4
ADDRGP4 com_token
ADDP4
ADDRLP4 4
INDIRI4
CVII1 4
ASGNI1
LABELV $699
line 1621
;1621:			str++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1622
;1622:		}
LABELV $697
line 1618
ADDRLP4 204
ADDRLP4 0
INDIRP4
INDIRU1
CVUI4 1
ASGNI4
ADDRLP4 4
ADDRLP4 204
INDIRI4
ASGNI4
ADDRLP4 204
INDIRI4
ADDRGP4 $626
ADDP4
INDIRU1
CVUI4 1
CNSTI4 0
EQI4 $696
line 1623
;1623:		com_tokentype = TK_STRING;
ADDRGP4 com_tokentype
CNSTI4 1
ASGNI4
line 1624
;1624:		break;
LABELV $629
line 1628
;1625:
;1626:	} // switch ( *str )
;1627:
;1628:	com_tokenline = com_lines - shift;
ADDRGP4 com_tokenline
ADDRGP4 com_lines
INDIRU4
ADDRLP4 12
INDIRI4
CVIU4 4
SUBU4
ASGNU4
line 1629
;1629:	com_token[ len ] = '\0';
ADDRLP4 8
INDIRI4
ADDRGP4 com_token
ADDP4
CNSTI1 0
ASGNI1
line 1630
;1630:	*data_p = ( char * )str;
ADDRFP4 0
INDIRP4
ADDRLP4 0
INDIRP4
ASGNP4
line 1631
;1631:	return com_token;
ADDRGP4 com_token
RETP4
LABELV $625
endproc COM_ParseComplex 208 0
export COM_MatchToken
proc COM_MatchToken 12 16
line 1640
;1632:}
;1633:
;1634:
;1635:/*
;1636:==================
;1637:COM_MatchToken
;1638:==================
;1639:*/
;1640:void COM_MatchToken( const char **buf_p, const char *match ) {
line 1643
;1641:	const char *token;
;1642:
;1643:	token = COM_Parse( buf_p );
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 4
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 4
INDIRP4
ASGNP4
line 1644
;1644:	if ( strcmp( token, match ) ) {
ADDRLP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 8
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 0
EQI4 $712
line 1645
;1645:		N_Error( ERR_DROP, "MatchToken: %s != %s", token, match );
CNSTI4 1
ARGI4
ADDRGP4 $714
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRGP4 N_Error
CALLV
pop
line 1646
;1646:	}
LABELV $712
line 1647
;1647:}
LABELV $711
endproc COM_MatchToken 12 16
export SkipBracedSection
proc SkipBracedSection 8 8
line 1659
;1648:
;1649:
;1650:/*
;1651:=================
;1652:SkipBracedSection
;1653:
;1654:The next token should be an open brace or set depth to 1 if already parsed it.
;1655:Skips until a matching close brace is found.
;1656:Internal brace depths are properly skipped.
;1657:=================
;1658:*/
;1659:qboolean SkipBracedSection( const char **program, int depth ) {
LABELV $716
line 1662
;1660:	const char			*token;
;1661:
;1662:	do {
line 1663
;1663:		token = COM_ParseExt( program, qtrue );
ADDRFP4 0
INDIRP4
ARGP4
CNSTI4 1
ARGI4
ADDRLP4 4
ADDRGP4 COM_ParseExt
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 4
INDIRP4
ASGNP4
line 1664
;1664:		if( token[1] == 0 ) {
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $719
line 1665
;1665:			if( token[0] == '{' ) {
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 123
NEI4 $721
line 1666
;1666:				depth++;
ADDRFP4 4
ADDRFP4 4
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
line 1667
;1667:			}
ADDRGP4 $722
JUMPV
LABELV $721
line 1668
;1668:			else if( token[0] == '}' ) {
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 125
NEI4 $723
line 1669
;1669:				depth--;
ADDRFP4 4
ADDRFP4 4
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
line 1670
;1670:			}
LABELV $723
LABELV $722
line 1671
;1671:		}
LABELV $719
line 1672
;1672:	} while( depth && *program );
LABELV $717
ADDRFP4 4
INDIRI4
CNSTI4 0
EQI4 $725
ADDRFP4 0
INDIRP4
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $716
LABELV $725
line 1674
;1673:
;1674:	return (qboolean)( depth == 0 );
ADDRFP4 4
INDIRI4
CNSTI4 0
NEI4 $727
ADDRLP4 4
CNSTI4 1
ASGNI4
ADDRGP4 $728
JUMPV
LABELV $727
ADDRLP4 4
CNSTI4 0
ASGNI4
LABELV $728
ADDRLP4 4
INDIRI4
RETI4
LABELV $715
endproc SkipBracedSection 8 8
export SkipRestOfLine
proc SkipRestOfLine 12 0
line 1683
;1675:}
;1676:
;1677:
;1678:/*
;1679:=================
;1680:SkipRestOfLine
;1681:=================
;1682:*/
;1683:void SkipRestOfLine( const char **data ) {
line 1687
;1684:	const char *p;
;1685:	int		c;
;1686:
;1687:	p = *data;
ADDRLP4 0
ADDRFP4 0
INDIRP4
INDIRP4
ASGNP4
line 1689
;1688:
;1689:	if ( !*p )
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $733
line 1690
;1690:		return;
ADDRGP4 $729
JUMPV
LABELV $732
line 1692
;1691:
;1692:	while ( (c = *p) != '\0' ) {
line 1693
;1693:		p++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1694
;1694:		if ( c == '\n' ) {
ADDRLP4 4
INDIRI4
CNSTI4 10
NEI4 $735
line 1695
;1695:			com_lines++;
ADDRLP4 8
ADDRGP4 com_lines
ASGNP4
ADDRLP4 8
INDIRP4
ADDRLP4 8
INDIRP4
INDIRU4
CNSTU4 1
ADDU4
ASGNU4
line 1696
;1696:			break;
ADDRGP4 $734
JUMPV
LABELV $735
line 1698
;1697:		}
;1698:	}
LABELV $733
line 1692
ADDRLP4 8
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 4
ADDRLP4 8
INDIRI4
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 0
NEI4 $732
LABELV $734
line 1700
;1699:
;1700:	*data = p;
ADDRFP4 0
INDIRP4
ADDRLP4 0
INDIRP4
ASGNP4
line 1701
;1701:}
LABELV $729
endproc SkipRestOfLine 12 0
export ParseHex
proc ParseHex 20 0
line 1704
;1702:
;1703:int ParseHex(const char *text)
;1704:{
line 1708
;1705:    int value;
;1706:    int c;
;1707:
;1708:    value = 0;
ADDRLP4 4
CNSTI4 0
ASGNI4
ADDRGP4 $739
JUMPV
LABELV $738
line 1709
;1709:    while ((c = *text++) != 0) {
line 1710
;1710:        if (c >= '0' && c <= '9') {
ADDRLP4 0
INDIRI4
CNSTI4 48
LTI4 $741
ADDRLP4 0
INDIRI4
CNSTI4 57
GTI4 $741
line 1711
;1711:            value = value * 16 + c - '0';
ADDRLP4 4
ADDRLP4 4
INDIRI4
CNSTI4 4
LSHI4
ADDRLP4 0
INDIRI4
ADDI4
CNSTI4 48
SUBI4
ASGNI4
line 1712
;1712:            continue;
ADDRGP4 $739
JUMPV
LABELV $741
line 1714
;1713:        }
;1714:        if (c >= 'a' && c <= 'f') {
ADDRLP4 0
INDIRI4
CNSTI4 97
LTI4 $743
ADDRLP4 0
INDIRI4
CNSTI4 102
GTI4 $743
line 1715
;1715:            value = value * 16 + 10 + c - 'a';
ADDRLP4 4
ADDRLP4 4
INDIRI4
CNSTI4 4
LSHI4
CNSTI4 10
ADDI4
ADDRLP4 0
INDIRI4
ADDI4
CNSTI4 97
SUBI4
ASGNI4
line 1716
;1716:            continue;
ADDRGP4 $739
JUMPV
LABELV $743
line 1718
;1717:        }
;1718:        if (c >= 'A' && c <= 'F') {
ADDRLP4 0
INDIRI4
CNSTI4 65
LTI4 $745
ADDRLP4 0
INDIRI4
CNSTI4 70
GTI4 $745
line 1719
;1719:            value = value * 16 + 10 + c - 'A';
ADDRLP4 4
ADDRLP4 4
INDIRI4
CNSTI4 4
LSHI4
CNSTI4 10
ADDI4
ADDRLP4 0
INDIRI4
ADDI4
CNSTI4 65
SUBI4
ASGNI4
line 1720
;1720:            continue;
LABELV $745
line 1722
;1721:        }
;1722:    }
LABELV $739
line 1709
ADDRLP4 8
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 8
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 12
ADDRLP4 8
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 0
ADDRLP4 12
INDIRI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 0
NEI4 $738
line 1724
;1723:
;1724:    return value;
ADDRLP4 4
INDIRI4
RETI4
LABELV $737
endproc ParseHex 20 0
export Parse1DMatrix
proc Parse1DMatrix 16 8
line 1727
;1725:}
;1726:
;1727:void Parse1DMatrix( const char **buf_p, int x, float *m ) {
line 1731
;1728:	const char	*token;
;1729:	int		i;
;1730:
;1731:	COM_MatchToken( buf_p, "(" );
ADDRFP4 0
INDIRP4
ARGP4
ADDRGP4 $748
ARGP4
ADDRGP4 COM_MatchToken
CALLV
pop
line 1733
;1732:
;1733:	for (i = 0 ; i < x; i++) {
ADDRLP4 0
CNSTI4 0
ASGNI4
ADDRGP4 $752
JUMPV
LABELV $749
line 1734
;1734:		token = COM_Parse( buf_p );
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 8
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 4
ADDRLP4 8
INDIRP4
ASGNP4
line 1735
;1735:		m[i] = N_atof( token );
ADDRLP4 4
INDIRP4
ARGP4
ADDRLP4 12
ADDRGP4 N_atof
CALLF4
ASGNF4
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 8
INDIRP4
ADDP4
ADDRLP4 12
INDIRF4
ASGNF4
line 1736
;1736:	}
LABELV $750
line 1733
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $752
ADDRLP4 0
INDIRI4
ADDRFP4 4
INDIRI4
LTI4 $749
line 1738
;1737:
;1738:	COM_MatchToken( buf_p, ")" );
ADDRFP4 0
INDIRP4
ARGP4
ADDRGP4 $753
ARGP4
ADDRGP4 COM_MatchToken
CALLV
pop
line 1739
;1739:}
LABELV $747
endproc Parse1DMatrix 16 8
export Parse2DMatrix
proc Parse2DMatrix 8 12
line 1741
;1740:
;1741:void Parse2DMatrix( const char **buf_p, int y, int x, float *m ) {
line 1744
;1742:	int		i;
;1743:
;1744:	COM_MatchToken( buf_p, "(" );
ADDRFP4 0
INDIRP4
ARGP4
ADDRGP4 $748
ARGP4
ADDRGP4 COM_MatchToken
CALLV
pop
line 1746
;1745:
;1746:	for (i = 0 ; i < y ; i++) {
ADDRLP4 0
CNSTI4 0
ASGNI4
ADDRGP4 $758
JUMPV
LABELV $755
line 1747
;1747:		Parse1DMatrix (buf_p, x, m + i * x);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 4
ADDRFP4 8
INDIRI4
ASGNI4
ADDRLP4 4
INDIRI4
ARGI4
ADDRLP4 0
INDIRI4
ADDRLP4 4
INDIRI4
MULI4
CNSTI4 2
LSHI4
ADDRFP4 12
INDIRP4
ADDP4
ARGP4
ADDRGP4 Parse1DMatrix
CALLV
pop
line 1748
;1748:	}
LABELV $756
line 1746
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $758
ADDRLP4 0
INDIRI4
ADDRFP4 4
INDIRI4
LTI4 $755
line 1750
;1749:
;1750:	COM_MatchToken( buf_p, ")" );
ADDRFP4 0
INDIRP4
ARGP4
ADDRGP4 $753
ARGP4
ADDRGP4 COM_MatchToken
CALLV
pop
line 1751
;1751:}
LABELV $754
endproc Parse2DMatrix 8 12
export Parse3DMatrix
proc Parse3DMatrix 12 16
line 1753
;1752:
;1753:void Parse3DMatrix( const char **buf_p, int z, int y, int x, float *m ) {
line 1756
;1754:	int		i;
;1755:
;1756:	COM_MatchToken( buf_p, "(" );
ADDRFP4 0
INDIRP4
ARGP4
ADDRGP4 $748
ARGP4
ADDRGP4 COM_MatchToken
CALLV
pop
line 1758
;1757:
;1758:	for (i = 0 ; i < z ; i++) {
ADDRLP4 0
CNSTI4 0
ASGNI4
ADDRGP4 $763
JUMPV
LABELV $760
line 1759
;1759:		Parse2DMatrix (buf_p, y, x, m + i * x*y);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 4
ADDRFP4 8
INDIRI4
ASGNI4
ADDRLP4 4
INDIRI4
ARGI4
ADDRLP4 8
ADDRFP4 12
INDIRI4
ASGNI4
ADDRLP4 8
INDIRI4
ARGI4
ADDRLP4 0
INDIRI4
ADDRLP4 8
INDIRI4
MULI4
ADDRLP4 4
INDIRI4
MULI4
CNSTI4 2
LSHI4
ADDRFP4 16
INDIRP4
ADDP4
ARGP4
ADDRGP4 Parse2DMatrix
CALLV
pop
line 1760
;1760:	}
LABELV $761
line 1758
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $763
ADDRLP4 0
INDIRI4
ADDRFP4 4
INDIRI4
LTI4 $760
line 1762
;1761:
;1762:	COM_MatchToken( buf_p, ")" );
ADDRFP4 0
INDIRP4
ARGP4
ADDRGP4 $753
ARGP4
ADDRGP4 COM_MatchToken
CALLV
pop
line 1763
;1763:}
LABELV $759
endproc Parse3DMatrix 12 16
export Hex
proc Hex 12 0
ADDRFP4 0
ADDRFP4 0
INDIRI4
CVII1 4
ASGNI1
line 1766
;1764:
;1765:int Hex( char c )
;1766:{
line 1767
;1767:	if ( c >= '0' && c <= '9' ) {
ADDRLP4 0
ADDRFP4 0
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 48
LTI4 $765
ADDRLP4 0
INDIRI4
CNSTI4 57
GTI4 $765
line 1768
;1768:		return c - '0';
ADDRFP4 0
INDIRI1
CVII4 1
CNSTI4 48
SUBI4
RETI4
ADDRGP4 $764
JUMPV
LABELV $765
line 1771
;1769:	}
;1770:	else
;1771:	if ( c >= 'A' && c <= 'F' ) {
ADDRLP4 4
ADDRFP4 0
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 65
LTI4 $767
ADDRLP4 4
INDIRI4
CNSTI4 70
GTI4 $767
line 1772
;1772:		return 10 + c - 'A';
ADDRFP4 0
INDIRI1
CVII4 1
CNSTI4 10
ADDI4
CNSTI4 65
SUBI4
RETI4
ADDRGP4 $764
JUMPV
LABELV $767
line 1775
;1773:	}
;1774:	else
;1775:	if ( c >= 'a' && c <= 'f' ) {
ADDRLP4 8
ADDRFP4 0
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 97
LTI4 $769
ADDRLP4 8
INDIRI4
CNSTI4 102
GTI4 $769
line 1776
;1776:		return 10 + c - 'a';
ADDRFP4 0
INDIRI1
CVII4 1
CNSTI4 10
ADDI4
CNSTI4 97
SUBI4
RETI4
ADDRGP4 $764
JUMPV
LABELV $769
line 1779
;1777:	}
;1778:
;1779:	return -1;
CNSTI4 -1
RETI4
LABELV $764
endproc Hex 12 0
export Com_HexStrToInt
proc Com_HexStrToInt 28 4
line 1789
;1780:}
;1781:
;1782:
;1783:/*
;1784:===================
;1785:Com_HexStrToInt
;1786:===================
;1787:*/
;1788:int32_t Com_HexStrToInt(const char *str)
;1789:{
line 1790
;1790:	if (!str)
ADDRFP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $772
line 1791
;1791:		return -1;
CNSTI4 -1
RETI4
ADDRGP4 $771
JUMPV
LABELV $772
line 1794
;1792:
;1793:	// check for hex code
;1794:	if (str[ 0 ] == '0' && str[ 1 ] == 'x' && str[ 2 ] != '\0') {
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 48
NEI4 $774
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
INDIRI1
CVII4 1
CNSTI4 120
NEI4 $774
ADDRLP4 0
INDIRP4
CNSTI4 2
ADDP4
INDIRI1
CVII4 1
CNSTI4 0
EQI4 $774
line 1795
;1795:	    int32_t i, digit, n = 0, len = strlen( str );
ADDRLP4 12
CNSTI4 0
ASGNI4
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 20
ADDRGP4 strlen
CALLU4
ASGNU4
ADDRLP4 16
ADDRLP4 20
INDIRU4
CVUI4 4
ASGNI4
line 1797
;1796:
;1797:		for (i = 2; i < len; i++) {
ADDRLP4 4
CNSTI4 2
ASGNI4
ADDRGP4 $779
JUMPV
LABELV $776
line 1798
;1798:			n *= 16;
ADDRLP4 12
ADDRLP4 12
INDIRI4
CNSTI4 4
LSHI4
ASGNI4
line 1800
;1799:
;1800:			digit = Hex( str[ i ] );
ADDRLP4 4
INDIRI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRI1
CVII4 1
ARGI4
ADDRLP4 24
ADDRGP4 Hex
CALLI4
ASGNI4
ADDRLP4 8
ADDRLP4 24
INDIRI4
ASGNI4
line 1802
;1801:
;1802:			if ( digit < 0 )
ADDRLP4 8
INDIRI4
CNSTI4 0
GEI4 $780
line 1803
;1803:				return -1;
CNSTI4 -1
RETI4
ADDRGP4 $771
JUMPV
LABELV $780
line 1805
;1804:
;1805:			n += digit;
ADDRLP4 12
ADDRLP4 12
INDIRI4
ADDRLP4 8
INDIRI4
ADDI4
ASGNI4
line 1806
;1806:		}
LABELV $777
line 1797
ADDRLP4 4
ADDRLP4 4
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $779
ADDRLP4 4
INDIRI4
ADDRLP4 16
INDIRI4
LTI4 $776
line 1808
;1807:
;1808:		return n;
ADDRLP4 12
INDIRI4
RETI4
ADDRGP4 $771
JUMPV
LABELV $774
line 1811
;1809:	}
;1810:
;1811:	return -1;
CNSTI4 -1
RETI4
LABELV $771
endproc Com_HexStrToInt 28 4
export Com_GetHashColor
proc Com_GetHashColor 60 4
line 1815
;1812:}
;1813:
;1814:qboolean Com_GetHashColor(const char *str, byte *color)
;1815:{
line 1818
;1816:	int32_t i, len, hex[6];
;1817:
;1818:	color[0] = color[1] = color[2] = 0;
ADDRLP4 32
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 36
CNSTU1 0
ASGNU1
ADDRLP4 32
INDIRP4
CNSTI4 2
ADDP4
ADDRLP4 36
INDIRU1
ASGNU1
ADDRLP4 32
INDIRP4
CNSTI4 1
ADDP4
ADDRLP4 36
INDIRU1
ASGNU1
ADDRLP4 32
INDIRP4
ADDRLP4 36
INDIRU1
ASGNU1
line 1820
;1819:
;1820:	if ( *str++ != '#' ) {
ADDRLP4 40
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 40
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 40
INDIRP4
INDIRI1
CVII4 1
CNSTI4 35
EQI4 $783
line 1821
;1821:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $782
JUMPV
LABELV $783
line 1824
;1822:	}
;1823:
;1824:	len = (int)strlen( str );
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 44
ADDRGP4 strlen
CALLU4
ASGNU4
ADDRLP4 28
ADDRLP4 44
INDIRU4
CVUI4 4
ASGNI4
line 1825
;1825:	if ( len <= 0 || len > 6 ) {
ADDRLP4 28
INDIRI4
CNSTI4 0
LEI4 $787
ADDRLP4 28
INDIRI4
CNSTI4 6
LEI4 $785
LABELV $787
line 1826
;1826:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $782
JUMPV
LABELV $785
line 1829
;1827:	}
;1828:
;1829:	for ( i = 0; i < len; i++ ) {
ADDRLP4 0
CNSTI4 0
ASGNI4
ADDRGP4 $791
JUMPV
LABELV $788
line 1830
;1830:		hex[i] = Hex( str[i] );
ADDRLP4 0
INDIRI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRI1
CVII4 1
ARGI4
ADDRLP4 56
ADDRGP4 Hex
CALLI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRLP4 4
ADDP4
ADDRLP4 56
INDIRI4
ASGNI4
line 1831
;1831:		if ( hex[i] < 0 ) {
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRLP4 4
ADDP4
INDIRI4
CNSTI4 0
GEI4 $792
line 1832
;1832:			return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $782
JUMPV
LABELV $792
line 1834
;1833:		}
;1834:	}
LABELV $789
line 1829
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $791
ADDRLP4 0
INDIRI4
ADDRLP4 28
INDIRI4
LTI4 $788
line 1836
;1835:
;1836:	switch ( len ) {
ADDRLP4 28
INDIRI4
CNSTI4 3
EQI4 $796
ADDRLP4 28
INDIRI4
CNSTI4 6
EQI4 $801
ADDRGP4 $794
JUMPV
LABELV $796
line 1838
;1837:		case 3: // #rgb
;1838:			color[0] = hex[0] << 4 | hex[0];
ADDRLP4 56
ADDRLP4 4
INDIRI4
ASGNI4
ADDRFP4 4
INDIRP4
ADDRLP4 56
INDIRI4
CNSTI4 4
LSHI4
ADDRLP4 56
INDIRI4
BORI4
CVIU4 4
CVUU1 4
ASGNU1
line 1839
;1839:			color[1] = hex[1] << 4 | hex[1];
ADDRFP4 4
INDIRP4
CNSTI4 1
ADDP4
ADDRLP4 4+4
INDIRI4
CNSTI4 4
LSHI4
ADDRLP4 4+4
INDIRI4
BORI4
CVIU4 4
CVUU1 4
ASGNU1
line 1840
;1840:			color[2] = hex[2] << 4 | hex[2];
ADDRFP4 4
INDIRP4
CNSTI4 2
ADDP4
ADDRLP4 4+8
INDIRI4
CNSTI4 4
LSHI4
ADDRLP4 4+8
INDIRI4
BORI4
CVIU4 4
CVUU1 4
ASGNU1
line 1841
;1841:			break;
ADDRGP4 $795
JUMPV
LABELV $801
line 1843
;1842:		case 6: // #rrggbb
;1843:			color[0] = hex[0] << 4 | hex[1];
ADDRFP4 4
INDIRP4
ADDRLP4 4
INDIRI4
CNSTI4 4
LSHI4
ADDRLP4 4+4
INDIRI4
BORI4
CVIU4 4
CVUU1 4
ASGNU1
line 1844
;1844:			color[1] = hex[2] << 4 | hex[3];
ADDRFP4 4
INDIRP4
CNSTI4 1
ADDP4
ADDRLP4 4+8
INDIRI4
CNSTI4 4
LSHI4
ADDRLP4 4+12
INDIRI4
BORI4
CVIU4 4
CVUU1 4
ASGNU1
line 1845
;1845:			color[2] = hex[4] << 4 | hex[5];
ADDRFP4 4
INDIRP4
CNSTI4 2
ADDP4
ADDRLP4 4+16
INDIRI4
CNSTI4 4
LSHI4
ADDRLP4 4+20
INDIRI4
BORI4
CVIU4 4
CVUU1 4
ASGNU1
line 1846
;1846:			break;
ADDRGP4 $795
JUMPV
LABELV $794
line 1848
;1847:		default: // unsupported format
;1848:			return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $782
JUMPV
LABELV $795
line 1851
;1849:	}
;1850:
;1851:	return qtrue;
CNSTI4 1
RETI4
LABELV $782
endproc Com_GetHashColor 60 4
export Com_PrintStartupBegin
proc Com_PrintStartupBegin 8 24
line 1854
;1852:}
;1853:
;1854:void Com_PrintStartupBegin( const char *func ) {
line 1855
;1855:	Con_Printf( "%*c %s %*c", 10, '-', func, 10, '-' );
ADDRGP4 $808
ARGP4
ADDRLP4 0
CNSTI4 10
ASGNI4
ADDRLP4 0
INDIRI4
ARGI4
ADDRLP4 4
CNSTI4 45
ASGNI4
ADDRLP4 4
INDIRI4
ARGI4
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 0
INDIRI4
ARGI4
ADDRLP4 4
INDIRI4
ARGI4
ADDRGP4 Con_Printf
CALLV
pop
line 1856
;1856:}
LABELV $807
endproc Com_PrintStartupBegin 8 24
export Com_PrintStartupEnd
proc Com_PrintStartupEnd 0 12
line 1858
;1857:
;1858:void Com_PrintStartupEnd( void ) {
line 1859
;1859:	Con_Printf( "%*c", 20, '-' );
ADDRGP4 $810
ARGP4
CNSTI4 20
ARGI4
CNSTI4 45
ARGI4
ADDRGP4 Con_Printf
CALLV
pop
line 1860
;1860:}
LABELV $809
endproc Com_PrintStartupEnd 0 12
proc Q_strkey 12 0
line 1871
;1861:
;1862:/*
;1863:=====================================================================
;1864:
;1865:  INFO STRINGS
;1866:
;1867:=====================================================================
;1868:*/
;1869:
;1870:static qboolean Q_strkey( const char *str, const char *key, uint32_t key_len )
;1871:{
line 1874
;1872:	uint32_t i;
;1873:
;1874:	for ( i = 0; i < key_len; i++ )
ADDRLP4 0
CNSTU4 0
ASGNU4
ADDRGP4 $815
JUMPV
LABELV $812
line 1875
;1875:	{
line 1876
;1876:		if ( locase[ (byte)str[i] ] != locase[ (byte)key[i] ] )
ADDRLP4 8
ADDRGP4 locase
ASGNP4
ADDRLP4 0
INDIRU4
ADDRFP4 0
INDIRP4
ADDP4
INDIRI1
CVII4 1
CVIU4 4
CVUU1 4
CVUI4 1
ADDRLP4 8
INDIRP4
ADDP4
INDIRU1
CVUI4 1
ADDRLP4 0
INDIRU4
ADDRFP4 4
INDIRP4
ADDP4
INDIRI1
CVII4 1
CVIU4 4
CVUU1 4
CVUI4 1
ADDRLP4 8
INDIRP4
ADDP4
INDIRU1
CVUI4 1
EQI4 $816
line 1877
;1877:		{
line 1878
;1878:			return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $811
JUMPV
LABELV $816
line 1880
;1879:		}
;1880:	}
LABELV $813
line 1874
ADDRLP4 0
ADDRLP4 0
INDIRU4
CNSTU4 1
ADDU4
ASGNU4
LABELV $815
ADDRLP4 0
INDIRU4
ADDRFP4 8
INDIRU4
LTU4 $812
line 1882
;1881:
;1882:	return qtrue;
CNSTI4 1
RETI4
LABELV $811
endproc Q_strkey 12 0
bss
align 1
LABELV $819
skip 16384
data
align 4
LABELV $820
byte 4 0
export Info_ValueForKey
code
proc Info_ValueForKey 72 12
line 1895
;1883:}
;1884:
;1885:
;1886:/*
;1887:===============
;1888:Info_ValueForKey
;1889:
;1890:Searches the string for the given
;1891:key and returns the associated value, or an empty string.
;1892:===============
;1893:*/
;1894:const char *Info_ValueForKey( const char *s, const char *key )
;1895:{
line 1903
;1896:	static	char value[2][BIG_INFO_VALUE];	// use two buffers so compares
;1897:											// work without stomping on each other
;1898:	static uint32_t valueindex = 0;
;1899:	const char *v, *pkey;
;1900:	char	*o, *o2;
;1901:	uint32_t klen, len;
;1902:	
;1903:	if ( !s || !key || !*key )
ADDRLP4 24
CNSTU4 0
ASGNU4
ADDRFP4 0
INDIRP4
CVPU4 4
ADDRLP4 24
INDIRU4
EQU4 $824
ADDRLP4 28
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 28
INDIRP4
CVPU4 4
ADDRLP4 24
INDIRU4
EQU4 $824
ADDRLP4 28
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $821
LABELV $824
line 1904
;1904:		return "";
ADDRGP4 $520
RETP4
ADDRGP4 $818
JUMPV
LABELV $821
line 1906
;1905:
;1906:	klen = strlen( key );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 32
ADDRGP4 strlen
CALLU4
ASGNU4
ADDRLP4 12
ADDRLP4 32
INDIRU4
ASGNU4
line 1908
;1907:
;1908:	if ( *s == '\\' )
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 92
NEI4 $828
line 1909
;1909:		s++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRGP4 $828
JUMPV
LABELV $827
line 1912
;1910:
;1911:	while (1)
;1912:	{
line 1913
;1913:		pkey = s;
ADDRLP4 8
ADDRFP4 0
INDIRP4
ASGNP4
ADDRGP4 $831
JUMPV
LABELV $830
line 1915
;1914:		while ( *s != '\\' )
;1915:		{
line 1916
;1916:			if ( *s == '\0' )
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $833
line 1917
;1917:				return "";
ADDRGP4 $520
RETP4
ADDRGP4 $818
JUMPV
LABELV $833
line 1918
;1918:			++s;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1919
;1919:		}
LABELV $831
line 1914
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 92
NEI4 $830
line 1920
;1920:		len = (s - pkey);
ADDRLP4 16
ADDRFP4 0
INDIRP4
CVPU4 4
ADDRLP4 8
INDIRP4
CVPU4 4
SUBU4
CVUI4 4
CVIU4 4
ASGNU4
line 1921
;1921:		s++; // skip '\\'
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1923
;1922:
;1923:		v = s;
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
ADDRGP4 $836
JUMPV
LABELV $835
line 1925
;1924:		while ( *s != '\\' && *s !='\0' )
;1925:			s++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
LABELV $836
line 1924
ADDRLP4 36
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 36
INDIRI4
CNSTI4 92
EQI4 $838
ADDRLP4 36
INDIRI4
CNSTI4 0
NEI4 $835
LABELV $838
line 1927
;1926:
;1927:		if ( len == klen && Q_strkey( pkey, key, klen ) )
ADDRLP4 16
INDIRU4
ADDRLP4 12
INDIRU4
NEU4 $839
ADDRLP4 8
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 12
INDIRU4
ARGU4
ADDRLP4 44
ADDRGP4 Q_strkey
CALLI4
ASGNI4
ADDRLP4 44
INDIRI4
CNSTI4 0
EQI4 $839
line 1928
;1928:		{
line 1929
;1929:			o = o2 = value[ valueindex ^= 1 ];
ADDRLP4 48
ADDRGP4 $820
ASGNP4
ADDRLP4 52
ADDRLP4 48
INDIRP4
INDIRU4
CNSTU4 1
BXORU4
ASGNU4
ADDRLP4 48
INDIRP4
ADDRLP4 52
INDIRU4
ASGNU4
ADDRLP4 56
ADDRLP4 52
INDIRU4
CNSTI4 13
LSHU4
ADDRGP4 $819
ADDP4
ASGNP4
ADDRLP4 20
ADDRLP4 56
INDIRP4
ASGNP4
ADDRLP4 4
ADDRLP4 56
INDIRP4
ASGNP4
line 1930
;1930:			if ( (s - v) >= BIG_INFO_VALUE )
ADDRFP4 0
INDIRP4
CVPU4 4
ADDRLP4 0
INDIRP4
CVPU4 4
SUBU4
CVUI4 4
CNSTI4 8192
LTI4 $845
line 1931
;1931:			{
line 1932
;1932:				N_Error( ERR_DROP, "Info_ValueForKey: oversize infostring" );
CNSTI4 1
ARGI4
ADDRGP4 $843
ARGP4
ADDRGP4 N_Error
CALLV
pop
line 1933
;1933:			}
ADDRGP4 $842
JUMPV
line 1935
;1934:			else 
;1935:			{
LABELV $844
line 1937
;1936:				while ( v < s )
;1937:					*o++ = *v++;
ADDRLP4 60
ADDRLP4 4
INDIRP4
ASGNP4
ADDRLP4 68
CNSTI4 1
ASGNI4
ADDRLP4 4
ADDRLP4 60
INDIRP4
ADDRLP4 68
INDIRI4
ADDP4
ASGNP4
ADDRLP4 64
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 64
INDIRP4
ADDRLP4 68
INDIRI4
ADDP4
ASGNP4
ADDRLP4 60
INDIRP4
ADDRLP4 64
INDIRP4
INDIRI1
ASGNI1
LABELV $845
line 1936
ADDRLP4 0
INDIRP4
CVPU4 4
ADDRFP4 0
INDIRP4
CVPU4 4
LTU4 $844
line 1938
;1938:			}
LABELV $842
line 1939
;1939:			*o = '\0';
ADDRLP4 4
INDIRP4
CNSTI1 0
ASGNI1
line 1940
;1940:			return o2;
ADDRLP4 20
INDIRP4
RETP4
ADDRGP4 $818
JUMPV
LABELV $839
line 1943
;1941:		}
;1942:
;1943:		if ( *s == '\0' )
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $847
line 1944
;1944:			break;
ADDRGP4 $829
JUMPV
LABELV $847
line 1946
;1945:
;1946:		s++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1947
;1947:	}
LABELV $828
line 1911
ADDRGP4 $827
JUMPV
LABELV $829
line 1949
;1948:
;1949:	return "";
ADDRGP4 $520
RETP4
LABELV $818
endproc Info_ValueForKey 72 12
bss
align 1
LABELV $850
skip 1024
export Info_Tokenize
code
proc Info_Tokenize 28 0
line 1968
;1950:}
;1951:
;1952:
;1953:#define MAX_INFO_TOKENS ((MAX_INFO_STRING/3)+2)
;1954:
;1955:static const char *info_keys[ MAX_INFO_TOKENS ];
;1956:static const char *info_values[ MAX_INFO_TOKENS ];
;1957:static uint32_t info_tokens;
;1958:
;1959:/*
;1960:===================
;1961:Info_Tokenize
;1962:
;1963:Tokenizes all key/value pairs from specified infostring
;1964:NOT suitable for big infostrings
;1965:===================
;1966:*/
;1967:void Info_Tokenize( const char *s )
;1968:{
line 1970
;1969:	static char tokenBuffer[ MAX_INFO_STRING ];
;1970:	char *o = tokenBuffer;
ADDRLP4 0
ADDRGP4 $850
ASGNP4
line 1972
;1971:
;1972:	info_tokens = 0;
ADDRGP4 info_tokens
CNSTU4 0
ASGNU4
line 1973
;1973:	*o = '\0';
ADDRLP4 0
INDIRP4
CNSTI1 0
ASGNI1
line 1975
;1974:
;1975:	for ( ;; )
line 1976
;1976:	{
ADDRGP4 $856
JUMPV
LABELV $855
line 1978
;1977:		while ( *s == '\\' ) // skip leading/trailing separators
;1978:			s++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
LABELV $856
line 1977
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 92
EQI4 $855
line 1980
;1979:
;1980:		if ( *s == '\0' )
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $858
line 1981
;1981:			break;
ADDRGP4 $853
JUMPV
LABELV $858
line 1983
;1982:
;1983:		info_keys[ info_tokens ] = o;
ADDRGP4 info_tokens
INDIRU4
CNSTI4 2
LSHU4
ADDRGP4 info_keys
ADDP4
ADDRLP4 0
INDIRP4
ASGNP4
ADDRGP4 $861
JUMPV
LABELV $860
line 1985
;1984:		while ( *s != '\\' )
;1985:		{
line 1986
;1986:			if ( *s == '\0' )
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $863
line 1987
;1987:			{
line 1988
;1988:				*o = '\0'; // terminate key
ADDRLP4 0
INDIRP4
CNSTI1 0
ASGNI1
line 1989
;1989:				info_values[ info_tokens++ ] = o;
ADDRLP4 8
ADDRGP4 info_tokens
ASGNP4
ADDRLP4 4
ADDRLP4 8
INDIRP4
INDIRU4
ASGNU4
ADDRLP4 8
INDIRP4
ADDRLP4 4
INDIRU4
CNSTU4 1
ADDU4
ASGNU4
ADDRLP4 4
INDIRU4
CNSTI4 2
LSHU4
ADDRGP4 info_values
ADDP4
ADDRLP4 0
INDIRP4
ASGNP4
line 1990
;1990:				return;
ADDRGP4 $849
JUMPV
LABELV $863
line 1992
;1991:			}
;1992:			*o++ = *s++;
ADDRLP4 4
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 12
CNSTI4 1
ASGNI4
ADDRLP4 0
ADDRLP4 4
INDIRP4
ADDRLP4 12
INDIRI4
ADDP4
ASGNP4
ADDRLP4 8
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 8
INDIRP4
ADDRLP4 12
INDIRI4
ADDP4
ASGNP4
ADDRLP4 4
INDIRP4
ADDRLP4 8
INDIRP4
INDIRI1
ASGNI1
line 1993
;1993:		}
LABELV $861
line 1984
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 92
NEI4 $860
line 1994
;1994:		*o++ = '\0'; // terminate key
ADDRLP4 4
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 4
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
INDIRP4
CNSTI1 0
ASGNI1
line 1995
;1995:		s++; // skip '\\'
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1997
;1996:
;1997:		info_values[ info_tokens++ ] = o;
ADDRLP4 12
ADDRGP4 info_tokens
ASGNP4
ADDRLP4 8
ADDRLP4 12
INDIRP4
INDIRU4
ASGNU4
ADDRLP4 12
INDIRP4
ADDRLP4 8
INDIRU4
CNSTU4 1
ADDU4
ASGNU4
ADDRLP4 8
INDIRU4
CNSTI4 2
LSHU4
ADDRGP4 info_values
ADDP4
ADDRLP4 0
INDIRP4
ASGNP4
ADDRGP4 $866
JUMPV
LABELV $865
line 1999
;1998:		while ( *s != '\\' && *s != '\0' )
;1999:		{
line 2000
;2000:			*o++ = *s++;
ADDRLP4 16
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 24
CNSTI4 1
ASGNI4
ADDRLP4 0
ADDRLP4 16
INDIRP4
ADDRLP4 24
INDIRI4
ADDP4
ASGNP4
ADDRLP4 20
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 20
INDIRP4
ADDRLP4 24
INDIRI4
ADDP4
ASGNP4
ADDRLP4 16
INDIRP4
ADDRLP4 20
INDIRP4
INDIRI1
ASGNI1
line 2001
;2001:		}
LABELV $866
line 1998
ADDRLP4 16
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 16
INDIRI4
CNSTI4 92
EQI4 $868
ADDRLP4 16
INDIRI4
CNSTI4 0
NEI4 $865
LABELV $868
line 2002
;2002:		*o++ = '\0';
ADDRLP4 20
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 20
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 20
INDIRP4
CNSTI1 0
ASGNI1
line 2003
;2003:	}
line 1975
ADDRGP4 $856
JUMPV
LABELV $853
line 2004
;2004:}
LABELV $849
endproc Info_Tokenize 28 0
export Info_ValueForKeyToken
proc Info_ValueForKeyToken 8 8
line 2015
;2005:
;2006:
;2007:/*
;2008:===================
;2009:Info_ValueForKeyToken
;2010:
;2011:Fast lookup from tokenized infostring
;2012:===================
;2013:*/
;2014:const char *Info_ValueForKeyToken( const char *key )
;2015:{
line 2018
;2016:	uint32_t i;
;2017:
;2018:	for ( i = 0; i < info_tokens; i++ )  {
ADDRLP4 0
CNSTU4 0
ASGNU4
ADDRGP4 $873
JUMPV
LABELV $870
line 2019
;2019:		if ( N_stricmp( info_keys[ i ], key ) == 0 )
ADDRLP4 0
INDIRU4
CNSTI4 2
LSHU4
ADDRGP4 info_keys
ADDP4
INDIRP4
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 4
ADDRGP4 N_stricmp
CALLI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $874
line 2020
;2020:		{
line 2021
;2021:			return info_values[ i ];
ADDRLP4 0
INDIRU4
CNSTI4 2
LSHU4
ADDRGP4 info_values
ADDP4
INDIRP4
RETP4
ADDRGP4 $869
JUMPV
LABELV $874
line 2023
;2022:		}
;2023:	}
LABELV $871
line 2018
ADDRLP4 0
ADDRLP4 0
INDIRU4
CNSTU4 1
ADDU4
ASGNU4
LABELV $873
ADDRLP4 0
INDIRU4
ADDRGP4 info_tokens
INDIRU4
LTU4 $870
line 2025
;2024:
;2025:	return "";
ADDRGP4 $520
RETP4
LABELV $869
endproc Info_ValueForKeyToken 8 8
export Info_NextPair
proc Info_NextPair 16 0
line 2037
;2026:}
;2027:
;2028:
;2029:/*
;2030:===================
;2031:Info_NextPair
;2032:
;2033:Used to iterate through all the key/value pairs in an info string
;2034:===================
;2035:*/
;2036:const char *Info_NextPair( const char *s, char *key, char *value )
;2037:{
line 2040
;2038:	char	*o;
;2039:
;2040:	if ( *s == '\\' ) {
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 92
NEI4 $877
line 2041
;2041:		s++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 2042
;2042:	}
LABELV $877
line 2044
;2043:
;2044:	key[0] = '\0';
ADDRFP4 4
INDIRP4
CNSTI1 0
ASGNI1
line 2045
;2045:	value[0] = '\0';
ADDRFP4 8
INDIRP4
CNSTI1 0
ASGNI1
line 2047
;2046:
;2047:	o = key;
ADDRLP4 0
ADDRFP4 4
INDIRP4
ASGNP4
ADDRGP4 $880
JUMPV
LABELV $879
line 2048
;2048:	while ( *s != '\\' ) {
line 2049
;2049:		if ( !*s ) {
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $882
line 2050
;2050:			*o = '\0';
ADDRLP4 0
INDIRP4
CNSTI1 0
ASGNI1
line 2051
;2051:			return s;
ADDRFP4 0
INDIRP4
RETP4
ADDRGP4 $876
JUMPV
LABELV $882
line 2053
;2052:		}
;2053:		*o++ = *s++;
ADDRLP4 4
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 12
CNSTI4 1
ASGNI4
ADDRLP4 0
ADDRLP4 4
INDIRP4
ADDRLP4 12
INDIRI4
ADDP4
ASGNP4
ADDRLP4 8
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 8
INDIRP4
ADDRLP4 12
INDIRI4
ADDP4
ASGNP4
ADDRLP4 4
INDIRP4
ADDRLP4 8
INDIRP4
INDIRI1
ASGNI1
line 2054
;2054:	}
LABELV $880
line 2048
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 92
NEI4 $879
line 2055
;2055:	*o = '\0';
ADDRLP4 0
INDIRP4
CNSTI1 0
ASGNI1
line 2056
;2056:	s++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 2058
;2057:
;2058:	o = value;
ADDRLP4 0
ADDRFP4 8
INDIRP4
ASGNP4
ADDRGP4 $885
JUMPV
LABELV $884
line 2059
;2059:	while ( *s != '\\' && *s ) {
line 2060
;2060:		*o++ = *s++;
ADDRLP4 4
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 12
CNSTI4 1
ASGNI4
ADDRLP4 0
ADDRLP4 4
INDIRP4
ADDRLP4 12
INDIRI4
ADDP4
ASGNP4
ADDRLP4 8
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 8
INDIRP4
ADDRLP4 12
INDIRI4
ADDP4
ASGNP4
ADDRLP4 4
INDIRP4
ADDRLP4 8
INDIRP4
INDIRI1
ASGNI1
line 2061
;2061:	}
LABELV $885
line 2059
ADDRLP4 4
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 92
EQI4 $887
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $884
LABELV $887
line 2062
;2062:	*o = '\0';
ADDRLP4 0
INDIRP4
CNSTI1 0
ASGNI1
line 2064
;2063:
;2064:	return s;
ADDRFP4 0
INDIRP4
RETP4
LABELV $876
endproc Info_NextPair 16 0
export Info_RemoveKey
proc Info_RemoveKey 40 12
line 2076
;2065:}
;2066:
;2067:
;2068:/*
;2069:===================
;2070:Info_RemoveKey
;2071:
;2072:return removed character count
;2073:===================
;2074:*/
;2075:size_t Info_RemoveKey( char *s, const char *key )
;2076:{
line 2081
;2077:	char *start;
;2078:	const char *pkey;
;2079:	size_t key_len, len, ret;
;2080:
;2081:	key_len = strlen( key );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 20
ADDRGP4 strlen
CALLU4
ASGNU4
ADDRLP4 12
ADDRLP4 20
INDIRU4
ASGNU4
line 2082
;2082:	ret = 0;
ADDRLP4 4
CNSTU4 0
ASGNU4
ADDRGP4 $890
JUMPV
LABELV $889
line 2084
;2083:
;2084:	while ( 1 ) {
line 2085
;2085:		start = s;
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
line 2086
;2086:		if ( *s == '\\' ) {
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 92
NEI4 $892
line 2087
;2087:			++s;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 2088
;2088:		}
LABELV $892
line 2089
;2089:		pkey = s;
ADDRLP4 8
ADDRFP4 0
INDIRP4
ASGNP4
ADDRGP4 $895
JUMPV
LABELV $894
line 2090
;2090:		while ( *s != '\\' ) {
line 2091
;2091:			if ( *s == '\0' ) {
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $897
line 2092
;2092:				if ( s != start ) {
ADDRFP4 0
INDIRP4
CVPU4 4
ADDRLP4 0
INDIRP4
CVPU4 4
EQU4 $899
line 2094
;2093:					// remove any trailing empty keys
;2094:					*start = '\0';
ADDRLP4 0
INDIRP4
CNSTI1 0
ASGNI1
line 2095
;2095:					ret += (int)(s - start);
ADDRLP4 4
ADDRLP4 4
INDIRU4
ADDRFP4 0
INDIRP4
CVPU4 4
ADDRLP4 0
INDIRP4
CVPU4 4
SUBU4
CVUI4 4
CVIU4 4
ADDU4
ASGNU4
line 2096
;2096:				}
LABELV $899
line 2097
;2097:				return ret;
ADDRLP4 4
INDIRU4
RETU4
ADDRGP4 $888
JUMPV
LABELV $897
line 2099
;2098:			}
;2099:			++s;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 2100
;2100:		}
LABELV $895
line 2090
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 92
NEI4 $894
line 2101
;2101:		len = (s - pkey);
ADDRLP4 16
ADDRFP4 0
INDIRP4
CVPU4 4
ADDRLP4 8
INDIRP4
CVPU4 4
SUBU4
CVUI4 4
CVIU4 4
ASGNU4
line 2102
;2102:		++s; // skip '\\'
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRGP4 $902
JUMPV
LABELV $901
line 2104
;2103:
;2104:		while ( *s != '\\' && *s != '\0' ) {
line 2105
;2105:			++s;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 2106
;2106:		}
LABELV $902
line 2104
ADDRLP4 24
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 24
INDIRI4
CNSTI4 92
EQI4 $904
ADDRLP4 24
INDIRI4
CNSTI4 0
NEI4 $901
LABELV $904
line 2108
;2107:
;2108:		if ( len == key_len && Q_strkey( pkey, key, key_len ) ) {
ADDRLP4 16
INDIRU4
ADDRLP4 12
INDIRU4
NEU4 $905
ADDRLP4 8
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 12
INDIRU4
ARGU4
ADDRLP4 32
ADDRGP4 Q_strkey
CALLI4
ASGNI4
ADDRLP4 32
INDIRI4
CNSTI4 0
EQI4 $905
line 2109
;2109:			memmove( start, s, strlen( s ) + 1 ); // remove this part
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 36
ADDRGP4 strlen
CALLU4
ASGNU4
ADDRLP4 0
INDIRP4
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 36
INDIRU4
CNSTU4 1
ADDU4
ARGU4
ADDRGP4 memmove
CALLP4
pop
line 2110
;2110:			ret += (int)(s - start);
ADDRLP4 4
ADDRLP4 4
INDIRU4
ADDRFP4 0
INDIRP4
CVPU4 4
ADDRLP4 0
INDIRP4
CVPU4 4
SUBU4
CVUI4 4
CVIU4 4
ADDU4
ASGNU4
line 2111
;2111:			s = start;
ADDRFP4 0
ADDRLP4 0
INDIRP4
ASGNP4
line 2112
;2112:		}
LABELV $905
line 2114
;2113:
;2114:		if ( *s == '\0' ) {
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $907
line 2115
;2115:			break;
ADDRGP4 $891
JUMPV
LABELV $907
line 2117
;2116:		}
;2117:	}
LABELV $890
line 2084
ADDRGP4 $889
JUMPV
LABELV $891
line 2119
;2118:
;2119:	return ret;
ADDRLP4 4
INDIRU4
RETU4
LABELV $888
endproc Info_RemoveKey 40 12
export Info_Validate
proc Info_Validate 16 0
line 2132
;2120:}
;2121:
;2122:
;2123:/*
;2124:==================
;2125:Info_Validate
;2126:
;2127:Some characters are illegal in info strings because they
;2128:can mess up the server's parsing
;2129:==================
;2130:*/
;2131:qboolean Info_Validate( const char *s )
;2132:{
line 2133
;2133:	for ( ;; ) {
LABELV $910
line 2134
;2134:		switch ( *s++ ) {
ADDRLP4 4
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 4
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 0
ADDRLP4 4
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 12
CNSTI4 34
ASGNI4
ADDRLP4 0
INDIRI4
ADDRLP4 12
INDIRI4
EQI4 $918
ADDRLP4 0
INDIRI4
ADDRLP4 12
INDIRI4
GTI4 $920
LABELV $919
ADDRLP4 0
INDIRI4
CNSTI4 0
EQI4 $917
ADDRGP4 $910
JUMPV
LABELV $920
ADDRLP4 0
INDIRI4
CNSTI4 59
EQI4 $918
ADDRGP4 $910
JUMPV
LABELV $917
line 2136
;2135:		case '\0':
;2136:			return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $909
JUMPV
LABELV $918
line 2139
;2137:		case '\"':
;2138:		case ';':
;2139:			return qfalse;
CNSTI4 0
RETI4
line 2141
;2140:		default:
;2141:			break;
line 2142
;2142:		};
line 2143
;2143:	}
line 2133
LABELV $909
endproc Info_Validate 16 0
export Info_ValidateKeyValue
proc Info_ValidateKeyValue 24 0
line 2156
;2144:}
;2145:
;2146:
;2147:/*
;2148:==================
;2149:Info_ValidateKeyValue
;2150:
;2151:Some characters are illegal in key values because they
;2152:can mess up the server's parsing
;2153:==================
;2154:*/
;2155:qboolean Info_ValidateKeyValue( const char *s )
;2156:{
line 2157
;2157:	for ( ;; ) {
LABELV $922
line 2158
;2158:		switch ( *s++ ) {
ADDRLP4 4
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 4
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 0
ADDRLP4 4
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 12
CNSTI4 34
ASGNI4
ADDRLP4 0
INDIRI4
ADDRLP4 12
INDIRI4
EQI4 $930
ADDRLP4 0
INDIRI4
ADDRLP4 12
INDIRI4
GTI4 $932
LABELV $931
ADDRLP4 0
INDIRI4
CNSTI4 0
EQI4 $929
ADDRGP4 $922
JUMPV
LABELV $932
ADDRLP4 20
CNSTI4 59
ASGNI4
ADDRLP4 0
INDIRI4
ADDRLP4 20
INDIRI4
EQI4 $930
ADDRLP4 0
INDIRI4
ADDRLP4 20
INDIRI4
LTI4 $922
LABELV $933
ADDRLP4 0
INDIRI4
CNSTI4 92
EQI4 $930
ADDRGP4 $922
JUMPV
LABELV $929
line 2160
;2159:		case '\0':
;2160:			return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $921
JUMPV
LABELV $930
line 2164
;2161:		case '\\':
;2162:		case '\"':
;2163:		case ';':
;2164:			return qfalse;
CNSTI4 0
RETI4
line 2166
;2165:		default:
;2166:			break;
line 2167
;2167:		};
line 2168
;2168:	}
line 2157
LABELV $921
endproc Info_ValidateKeyValue 24 0
export Info_SetValueForKey_s
proc Info_SetValueForKey_s 8240 20
line 2180
;2169:}
;2170:
;2171:
;2172:/*
;2173:==================
;2174:Info_SetValueForKey_s
;2175:
;2176:Changes or adds a key/value pair
;2177:==================
;2178:*/
;2179:qboolean Info_SetValueForKey_s( char *s, uint32_t slen, const char *key, const char *value )
;2180:{
line 2184
;2181:	char		newi[BIG_INFO_STRING+2];
;2182:	uint32_t	len1, len2;
;2183:
;2184:	len1 = strlen( s );
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 8204
ADDRGP4 strlen
CALLU4
ASGNU4
ADDRLP4 0
ADDRLP4 8204
INDIRU4
ASGNU4
line 2186
;2185:
;2186:	if ( len1 >= slen ) {
ADDRLP4 0
INDIRU4
ADDRFP4 4
INDIRU4
LTU4 $935
line 2187
;2187:		Con_Printf( COLOR_YELLOW "Info_SetValueForKey(%s): oversize infostring\n", key );
ADDRGP4 $937
ARGP4
ADDRFP4 8
INDIRP4
ARGP4
ADDRGP4 Con_Printf
CALLV
pop
line 2188
;2188:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $934
JUMPV
LABELV $935
line 2191
;2189:	}
;2190:
;2191:	if ( !key || !Info_ValidateKeyValue( key ) || *key == '\0' ) {
ADDRLP4 8208
ADDRFP4 8
INDIRP4
ASGNP4
ADDRLP4 8208
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $941
ADDRLP4 8208
INDIRP4
ARGP4
ADDRLP4 8212
ADDRGP4 Info_ValidateKeyValue
CALLI4
ASGNI4
ADDRLP4 8216
CNSTI4 0
ASGNI4
ADDRLP4 8212
INDIRI4
ADDRLP4 8216
INDIRI4
EQI4 $941
ADDRFP4 8
INDIRP4
INDIRI1
CVII4 1
ADDRLP4 8216
INDIRI4
NEI4 $938
LABELV $941
line 2192
;2192:		Con_Printf( COLOR_YELLOW "Invalid key name: '%s'\n", key );
ADDRGP4 $942
ARGP4
ADDRFP4 8
INDIRP4
ARGP4
ADDRGP4 Con_Printf
CALLV
pop
line 2193
;2193:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $934
JUMPV
LABELV $938
line 2196
;2194:	}
;2195:
;2196:	if ( value && !Info_ValidateKeyValue( value ) ) {
ADDRLP4 8220
ADDRFP4 12
INDIRP4
ASGNP4
ADDRLP4 8220
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $943
ADDRLP4 8220
INDIRP4
ARGP4
ADDRLP4 8224
ADDRGP4 Info_ValidateKeyValue
CALLI4
ASGNI4
ADDRLP4 8224
INDIRI4
CNSTI4 0
NEI4 $943
line 2197
;2197:		Con_Printf( COLOR_YELLOW "Invalid value name: '%s'\n", value );
ADDRGP4 $945
ARGP4
ADDRFP4 12
INDIRP4
ARGP4
ADDRGP4 Con_Printf
CALLV
pop
line 2198
;2198:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $934
JUMPV
LABELV $943
line 2201
;2199:	}
;2200:
;2201:	len1 -= Info_RemoveKey( s, key );
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 8
INDIRP4
ARGP4
ADDRLP4 8228
ADDRGP4 Info_RemoveKey
CALLU4
ASGNU4
ADDRLP4 0
ADDRLP4 0
INDIRU4
ADDRLP4 8228
INDIRU4
SUBU4
ASGNU4
line 2202
;2202:	if ( value == NULL || *value == '\0' ) {
ADDRLP4 8232
ADDRFP4 12
INDIRP4
ASGNP4
ADDRLP4 8232
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $948
ADDRLP4 8232
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $946
LABELV $948
line 2203
;2203:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $934
JUMPV
LABELV $946
line 2206
;2204:	}
;2205:
;2206:	len2 = Com_snprintf( newi, sizeof( newi ), "\\%s\\%s", key, value );
ADDRLP4 4
ARGP4
CNSTU4 8194
ARGU4
ADDRGP4 $949
ARGP4
ADDRFP4 8
INDIRP4
ARGP4
ADDRFP4 12
INDIRP4
ARGP4
ADDRLP4 8236
ADDRGP4 Com_snprintf
CALLI4
ASGNI4
ADDRLP4 8200
ADDRLP4 8236
INDIRI4
CVIU4 4
ASGNU4
line 2208
;2207:
;2208:	if ( len1 + len2 >= slen ) {
ADDRLP4 0
INDIRU4
ADDRLP4 8200
INDIRU4
ADDU4
ADDRFP4 4
INDIRU4
LTU4 $950
line 2209
;2209:		Con_Printf( COLOR_YELLOW "Info string length exceeded for key '%s'\n", key );
ADDRGP4 $952
ARGP4
ADDRFP4 8
INDIRP4
ARGP4
ADDRGP4 Con_Printf
CALLV
pop
line 2210
;2210:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $934
JUMPV
LABELV $950
line 2213
;2211:	}
;2212:
;2213:	strcpy( s + len1, newi );
ADDRLP4 0
INDIRU4
ADDRFP4 0
INDIRP4
ADDP4
ARGP4
ADDRLP4 4
ARGP4
ADDRGP4 strcpy
CALLP4
pop
line 2214
;2214:	return qtrue;
CNSTI4 1
RETI4
LABELV $934
endproc Info_SetValueForKey_s 8240 20
import strncpy
import strrchr
bss
align 4
LABELV info_tokens
skip 4
align 4
LABELV info_values
skip 1372
align 4
LABELV info_keys
skip 1372
align 4
LABELV com_tokenline
skip 4
align 4
LABELV com_lines
skip 4
align 1
LABELV com_parsename
skip 1024
align 1
LABELV com_token
skip 1024
import I_GetParm
import Com_TouchMemory
import Hunk_TempIsClear
import Hunk_Check
import Hunk_Print
import Hunk_SetMark
import Hunk_ClearToMark
import Hunk_CheckMark
import Hunk_SmallLog
import Hunk_Log
import Hunk_MemoryRemaining
import Hunk_ClearTempMemory
import Hunk_FreeTempMemory
import Hunk_AllocateTempMemory
import Hunk_Clear
import Hunk_Alloc
import Hunk_InitMemory
import Z_InitMemory
import Z_InitSmallZoneMemory
import CopyString
import Z_AvailableMemory
import Z_FreeTags
import Z_Free
import S_Malloc
import Z_Malloc
import Z_Realloc
import CPU_flags
import FS_ReadLine
import FS_ListFiles
import FS_FreeFileList
import FS_FreeFile
import FS_SetBFFIndex
import FS_GetCurrentChunkList
import FS_Initialized
import FS_FileIsInBFF
import FS_StripExt
import FS_AllowedExtension
import FS_GetFileList
import FS_LoadLibrary
import FS_CopyString
import FS_BuildOSPath
import FS_FilenameCompare
import FS_FileTell
import FS_FileLength
import FS_FileSeek
import FS_FileExists
import FS_LastBFFIndex
import FS_LoadStack
import FS_Rename
import FS_FOpenFileRead
import FS_FOpenAppend
import FS_FOpenRW
import FS_FOpenWrite
import FS_FOpenRead
import FS_FOpenFileWithMode
import FS_FOpenWithMode
import FS_FileToFileno
import FS_Printf
import FS_GetGamePath
import FS_GetHomePath
import FS_GetBasePath
import FS_GetBaseGameDir
import FS_GetCurrentGameDir
import FS_Flush
import FS_ForceFlush
import FS_FClose
import FS_LoadFile
import FS_WriteFile
import FS_Write
import FS_Read
import FS_Remove
import FS_Restart
import FS_Shutdown
import FS_InitFilesystem
import FS_Startup
import FS_VM_CloseFiles
import FS_VM_FileLength
import FS_VM_Read
import FS_VM_Write
import FS_VM_WriteFile
import FS_VM_FClose
import FS_VM_FOpenFileRead
import FS_VM_FOpenFileWrite
import FS_VM_FOpenFile
import FS_VM_FileTell
import FS_VM_FileSeek
import FS_VM_FOpenRW
import FS_VM_FOpenAppend
import FS_VM_FOpenWrite
import FS_VM_FOpenRead
import com_errorMessage
import com_fullyInitialized
import com_errorEntered
import com_cacheLine
import com_frameTime
import com_fps
import com_frameNumber
import com_maxfps
import sys_cpuString
import com_devmode
import com_version
import com_logfile
import com_journal
import com_demo
import Con_HistoryGetNext
import Con_HistoryGetPrev
import Con_SaveField
import Con_ResetHistory
import Field_CompleteCommand
import Field_CompleteFilename
import Field_CompleteKeyBind
import Field_CompleteKeyname
import Field_AutoComplete
import Field_Clear
import Cbuf_Init
import Cbuf_Clear
import Cbuf_AddText
import Cbuf_Execute
import Cbuf_InsertText
import Cbuf_ExecuteText
import Cmd_CompleteArgument
import Cmd_CommandCompletion
import Cmd_Clear
import Cmd_Argv
import Cmd_ArgsFrom
import Cmd_SetCommandCompletionFunc
import Cmd_TokenizeStringIgnoreQuotes
import Cmd_TokenizeString
import Cmd_ArgvBuffer
import Cmd_Argc
import Cmd_ExecuteString
import Cmd_ExecuteText
import Cmd_ArgsBuffer
import Cmd_ExecuteCommand
import Cmd_RemoveCommand
import Cmd_AddCommand
import Cmd_Init
import keys
import Key_WriteBindings
import Key_SetOverstrikeMode
import Key_GetOverstrikeMode
import Key_GetKey
import Key_GetCatcher
import Key_SetCatcher
import Key_ClearStates
import Key_GetBinding
import Key_IsDown
import Key_KeynumToString
import Key_StringToKeynum
import Key_KeynameCompletion
import Com_EventLoop
import Com_KeyEvent
import Com_SendKeyEvents
import Com_QueueEvent
import Com_InitKeyCommands
export com_tokentype
align 4
LABELV com_tokentype
skip 4
import Com_BlockChecksum
import Com_SortFileList
import Com_Base64Decode
import Com_WriteConfig
import Con_RenderConsole
import Com_Shutdown
import Com_Init
import Com_StartupVariable
import Com_EarlyParseCmdLine
import Com_Milliseconds
import Com_Frame
import Sys_SnapVector
import Con_DPrintf
import Con_Printf
import Con_Shutdown
import Con_Init
import Con_DrawConsole
import Con_AddText
import ColorIndexFromChar
import g_color_table
import bytedirs
import N_isnan
import PerpendicularVector
import AngleVectors
import MatrixMultiply
import MakeNormalVectors
import RotateAroundDirection
import RotatePointAroundVector
import ProjectPointOnPlane
import PlaneFromPoints
import AngleDelta
import AngleNormalize180
import AngleNormalize360
import AnglesSubtract
import AngleSubtract
import LerpAngle
import AngleMod
import BoundsIntersectPoint
import BoundsIntersectSphere
import BoundsIntersect
import disBetweenOBJ
import AxisCopy
import AxisClear
import AnglesToAxis
import vectoangles
import N_crandom
import N_random
import N_rand
import N_fabs
import N_acos
import N_log2
import VectorRotate
import Vector4Scale
import VectorNormalize2
import VectorNormalize
import CrossProduct
import VectorInverse
import VectorNormalizeFast
import DistanceSquared
import Distance
import VectorLengthSquared
import VectorLength
import VectorCompare
import AddPointToBounds
import ClearBounds
import RadiusFromBounds
import NormalizeColor
import ColorBytes4
import ColorBytes3
import _VectorMA
import _VectorScale
import _VectorCopy
import _VectorAdd
import _VectorSubtract
import _DotProduct
import ByteToDir
import DirToByte
import ClampShort
import ClampCharMove
import ClampChar
import N_exp2f
import N_log2f
import Q_rsqrt
import N_Error
import colorDkGrey
import colorMdGrey
import colorLtGrey
import colorWhite
import colorCyan
import colorMagenta
import colorYellow
import colorBlue
import colorGreen
import colorRed
import colorBlack
import vec2_origin
import vec3_origin
import mat4_identity
import N_atof
import N_fmaxf
import acos
import fabs
import abs
import tan
import atan2
import cos
import sin
import sqrt
import floor
import ceil
import sscanf
import vsprintf
import rand
import srand
import qsort
import toupper
import tolower
import strncmp
import strcmp
import strstr
import strchr
import strlen
import strcat
import strcpy
import memmove
import memset
import memchr
import memcpy
lit
align 1
LABELV $952
byte 1 94
byte 1 51
byte 1 73
byte 1 110
byte 1 102
byte 1 111
byte 1 32
byte 1 115
byte 1 116
byte 1 114
byte 1 105
byte 1 110
byte 1 103
byte 1 32
byte 1 108
byte 1 101
byte 1 110
byte 1 103
byte 1 116
byte 1 104
byte 1 32
byte 1 101
byte 1 120
byte 1 99
byte 1 101
byte 1 101
byte 1 100
byte 1 101
byte 1 100
byte 1 32
byte 1 102
byte 1 111
byte 1 114
byte 1 32
byte 1 107
byte 1 101
byte 1 121
byte 1 32
byte 1 39
byte 1 37
byte 1 115
byte 1 39
byte 1 10
byte 1 0
align 1
LABELV $949
byte 1 92
byte 1 37
byte 1 115
byte 1 92
byte 1 37
byte 1 115
byte 1 0
align 1
LABELV $945
byte 1 94
byte 1 51
byte 1 73
byte 1 110
byte 1 118
byte 1 97
byte 1 108
byte 1 105
byte 1 100
byte 1 32
byte 1 118
byte 1 97
byte 1 108
byte 1 117
byte 1 101
byte 1 32
byte 1 110
byte 1 97
byte 1 109
byte 1 101
byte 1 58
byte 1 32
byte 1 39
byte 1 37
byte 1 115
byte 1 39
byte 1 10
byte 1 0
align 1
LABELV $942
byte 1 94
byte 1 51
byte 1 73
byte 1 110
byte 1 118
byte 1 97
byte 1 108
byte 1 105
byte 1 100
byte 1 32
byte 1 107
byte 1 101
byte 1 121
byte 1 32
byte 1 110
byte 1 97
byte 1 109
byte 1 101
byte 1 58
byte 1 32
byte 1 39
byte 1 37
byte 1 115
byte 1 39
byte 1 10
byte 1 0
align 1
LABELV $937
byte 1 94
byte 1 51
byte 1 73
byte 1 110
byte 1 102
byte 1 111
byte 1 95
byte 1 83
byte 1 101
byte 1 116
byte 1 86
byte 1 97
byte 1 108
byte 1 117
byte 1 101
byte 1 70
byte 1 111
byte 1 114
byte 1 75
byte 1 101
byte 1 121
byte 1 40
byte 1 37
byte 1 115
byte 1 41
byte 1 58
byte 1 32
byte 1 111
byte 1 118
byte 1 101
byte 1 114
byte 1 115
byte 1 105
byte 1 122
byte 1 101
byte 1 32
byte 1 105
byte 1 110
byte 1 102
byte 1 111
byte 1 115
byte 1 116
byte 1 114
byte 1 105
byte 1 110
byte 1 103
byte 1 10
byte 1 0
align 1
LABELV $843
byte 1 73
byte 1 110
byte 1 102
byte 1 111
byte 1 95
byte 1 86
byte 1 97
byte 1 108
byte 1 117
byte 1 101
byte 1 70
byte 1 111
byte 1 114
byte 1 75
byte 1 101
byte 1 121
byte 1 58
byte 1 32
byte 1 111
byte 1 118
byte 1 101
byte 1 114
byte 1 115
byte 1 105
byte 1 122
byte 1 101
byte 1 32
byte 1 105
byte 1 110
byte 1 102
byte 1 111
byte 1 115
byte 1 116
byte 1 114
byte 1 105
byte 1 110
byte 1 103
byte 1 0
align 1
LABELV $810
byte 1 37
byte 1 42
byte 1 99
byte 1 0
align 1
LABELV $808
byte 1 37
byte 1 42
byte 1 99
byte 1 32
byte 1 37
byte 1 115
byte 1 32
byte 1 37
byte 1 42
byte 1 99
byte 1 0
align 1
LABELV $753
byte 1 41
byte 1 0
align 1
LABELV $748
byte 1 40
byte 1 0
align 1
LABELV $714
byte 1 77
byte 1 97
byte 1 116
byte 1 99
byte 1 104
byte 1 84
byte 1 111
byte 1 107
byte 1 101
byte 1 110
byte 1 58
byte 1 32
byte 1 37
byte 1 115
byte 1 32
byte 1 33
byte 1 61
byte 1 32
byte 1 37
byte 1 115
byte 1 0
align 1
LABELV $534
byte 1 94
byte 1 51
byte 1 87
byte 1 65
byte 1 82
byte 1 78
byte 1 73
byte 1 78
byte 1 71
byte 1 58
byte 1 32
byte 1 37
byte 1 115
byte 1 44
byte 1 32
byte 1 108
byte 1 105
byte 1 110
byte 1 101
byte 1 32
byte 1 37
byte 1 108
byte 1 117
byte 1 58
byte 1 32
byte 1 37
byte 1 115
byte 1 10
byte 1 0
align 1
LABELV $530
byte 1 94
byte 1 49
byte 1 69
byte 1 82
byte 1 82
byte 1 79
byte 1 82
byte 1 58
byte 1 32
byte 1 37
byte 1 115
byte 1 44
byte 1 32
byte 1 108
byte 1 105
byte 1 110
byte 1 101
byte 1 32
byte 1 37
byte 1 108
byte 1 117
byte 1 58
byte 1 32
byte 1 37
byte 1 115
byte 1 10
byte 1 0
align 1
LABELV $522
byte 1 37
byte 1 115
byte 1 0
align 1
LABELV $520
byte 1 0
align 1
LABELV $509
byte 1 94
byte 1 51
byte 1 67
byte 1 111
byte 1 109
byte 1 95
byte 1 115
byte 1 110
byte 1 112
byte 1 114
byte 1 105
byte 1 110
byte 1 116
byte 1 102
byte 1 58
byte 1 32
byte 1 111
byte 1 118
byte 1 101
byte 1 114
byte 1 102
byte 1 108
byte 1 111
byte 1 119
byte 1 32
byte 1 111
byte 1 102
byte 1 32
byte 1 37
byte 1 105
byte 1 32
byte 1 105
byte 1 110
byte 1 32
byte 1 37
byte 1 117
byte 1 10
byte 1 0
align 1
LABELV $506
byte 1 67
byte 1 111
byte 1 109
byte 1 95
byte 1 115
byte 1 109
byte 1 112
byte 1 114
byte 1 105
byte 1 110
byte 1 116
byte 1 102
byte 1 58
byte 1 32
byte 1 111
byte 1 118
byte 1 101
byte 1 114
byte 1 102
byte 1 108
byte 1 111
byte 1 119
byte 1 101
byte 1 100
byte 1 32
byte 1 98
byte 1 105
byte 1 103
byte 1 98
byte 1 117
byte 1 102
byte 1 102
byte 1 101
byte 1 114
byte 1 0
align 1
LABELV $501
byte 1 67
byte 1 111
byte 1 109
byte 1 95
byte 1 115
byte 1 110
byte 1 112
byte 1 114
byte 1 105
byte 1 110
byte 1 116
byte 1 102
byte 1 58
byte 1 32
byte 1 78
byte 1 85
byte 1 76
byte 1 76
byte 1 32
byte 1 100
byte 1 101
byte 1 115
byte 1 116
byte 1 0
align 1
LABELV $335
byte 1 78
byte 1 95
byte 1 115
byte 1 116
byte 1 114
byte 1 99
byte 1 97
byte 1 116
byte 1 58
byte 1 32
byte 1 97
byte 1 108
byte 1 114
byte 1 101
byte 1 97
byte 1 100
byte 1 121
byte 1 32
byte 1 111
byte 1 118
byte 1 101
byte 1 114
byte 1 102
byte 1 108
byte 1 111
byte 1 119
byte 1 101
byte 1 100
byte 1 0
align 1
LABELV $284
byte 1 78
byte 1 95
byte 1 115
byte 1 116
byte 1 114
byte 1 110
byte 1 99
byte 1 112
byte 1 121
byte 1 122
byte 1 58
byte 1 32
byte 1 98
byte 1 97
byte 1 100
byte 1 32
byte 1 99
byte 1 111
byte 1 117
byte 1 110
byte 1 116
byte 1 0
align 1
LABELV $281
byte 1 78
byte 1 95
byte 1 115
byte 1 116
byte 1 114
byte 1 110
byte 1 99
byte 1 112
byte 1 121
byte 1 122
byte 1 58
byte 1 32
byte 1 78
byte 1 85
byte 1 76
byte 1 76
byte 1 32
byte 1 115
byte 1 114
byte 1 99
byte 1 0
align 1
LABELV $278
byte 1 78
byte 1 95
byte 1 115
byte 1 116
byte 1 114
byte 1 110
byte 1 99
byte 1 112
byte 1 121
byte 1 122
byte 1 58
byte 1 32
byte 1 78
byte 1 85
byte 1 76
byte 1 76
byte 1 32
byte 1 100
byte 1 101
byte 1 115
byte 1 116
byte 1 0
align 1
LABELV $274
byte 1 32
byte 1 46
byte 1 46
byte 1 46
byte 1 32
byte 1 0
