data
export vec2_origin
align 4
LABELV vec2_origin
byte 4 0
byte 4 0
export vec3_origin
align 4
LABELV vec3_origin
byte 4 0
byte 4 0
skip 4
export colorBlack
align 4
LABELV colorBlack
byte 4 0
byte 4 0
byte 4 0
byte 4 1065353216
export colorRed
align 4
LABELV colorRed
byte 4 1065353216
byte 4 0
byte 4 0
byte 4 1065353216
export colorGreen
align 4
LABELV colorGreen
byte 4 0
byte 4 1065353216
byte 4 0
byte 4 1065353216
export colorBlue
align 4
LABELV colorBlue
byte 4 0
byte 4 0
byte 4 1065353216
byte 4 1065353216
export colorYellow
align 4
LABELV colorYellow
byte 4 1065353216
byte 4 1065353216
byte 4 0
byte 4 1065353216
export colorMagenta
align 4
LABELV colorMagenta
byte 4 1065353216
byte 4 0
byte 4 1065353216
byte 4 1065353216
export colorCyan
align 4
LABELV colorCyan
byte 4 0
byte 4 1065353216
byte 4 1065353216
byte 4 1065353216
export colorWhite
align 4
LABELV colorWhite
byte 4 1065353216
byte 4 1065353216
byte 4 1065353216
byte 4 1065353216
export colorLtGrey
align 4
LABELV colorLtGrey
byte 4 1061158912
byte 4 1061158912
byte 4 1061158912
byte 4 1065353216
export colorMdGrey
align 4
LABELV colorMdGrey
byte 4 1056964608
byte 4 1056964608
byte 4 1056964608
byte 4 1065353216
export colorDkGrey
align 4
LABELV colorDkGrey
byte 4 1048576000
byte 4 1048576000
byte 4 1048576000
byte 4 1065353216
export g_color_table
align 4
LABELV g_color_table
byte 4 0
byte 4 0
byte 4 0
byte 4 1065353216
byte 4 1065353216
byte 4 0
byte 4 0
byte 4 1065353216
byte 4 0
byte 4 1065353216
byte 4 0
byte 4 1065353216
byte 4 1065353216
byte 4 1065353216
byte 4 0
byte 4 1065353216
byte 4 1045220557
byte 4 1045220557
byte 4 1065353216
byte 4 1065353216
byte 4 0
byte 4 1065353216
byte 4 1065353216
byte 4 1065353216
byte 4 1065353216
byte 4 0
byte 4 1065353216
byte 4 1065353216
byte 4 1065353216
byte 4 1065353216
byte 4 1065353216
byte 4 1065353216
byte 4 1065353216
byte 4 1056964608
byte 4 0
byte 4 1065353216
byte 4 1058642330
byte 4 1058642330
byte 4 1065353216
byte 4 1065353216
byte 4 1065353216
byte 4 0
byte 4 0
byte 4 1065353216
byte 4 1065353216
byte 4 1049178302
byte 4 0
byte 4 1065353216
byte 4 1065353216
byte 4 1056964608
byte 4 0
byte 4 1065353216
byte 4 1065353216
byte 4 1060857761
byte 4 0
byte 4 1065353216
byte 4 1065353216
byte 4 1065353216
byte 4 0
byte 4 1065353216
byte 4 1060857761
byte 4 1065353216
byte 4 0
byte 4 1065353216
byte 4 1056964608
byte 4 1065353216
byte 4 0
byte 4 1065353216
byte 4 1049178302
byte 4 1065353216
byte 4 0
byte 4 1065353216
byte 4 0
byte 4 1065353216
byte 4 0
byte 4 1065353216
byte 4 0
byte 4 1065353216
byte 4 1049178302
byte 4 1065353216
byte 4 0
byte 4 1065353216
byte 4 1056964608
byte 4 1065353216
byte 4 0
byte 4 1065353216
byte 4 1060857761
byte 4 1065353216
byte 4 0
byte 4 1065353216
byte 4 1065353216
byte 4 1065353216
byte 4 0
byte 4 1060857761
byte 4 1065353216
byte 4 1065353216
byte 4 0
byte 4 1056964608
byte 4 1065353216
byte 4 1065353216
byte 4 0
byte 4 1049178302
byte 4 1065353216
byte 4 1065353216
byte 4 0
byte 4 0
byte 4 1065353216
byte 4 1065353216
byte 4 1049178302
byte 4 0
byte 4 1065353216
byte 4 1065353216
byte 4 1056964608
byte 4 0
byte 4 1065353216
byte 4 1065353216
byte 4 1060857761
byte 4 0
byte 4 1065353216
byte 4 1065353216
byte 4 1065353216
byte 4 0
byte 4 1065353216
byte 4 1065353216
byte 4 1065353216
byte 4 0
byte 4 1060857761
byte 4 1065353216
byte 4 1065353216
byte 4 0
byte 4 1056964608
byte 4 1065353216
byte 4 1065353216
byte 4 0
byte 4 1049178302
byte 4 1065353216
byte 4 1065353216
byte 4 1065353216
byte 4 1065353216
byte 4 1065353216
byte 4 1056964608
byte 4 1056964608
byte 4 1056964608
byte 4 1065353216
skip 448
export ColorIndexFromChar
code
proc ColorIndexFromChar 12 0
ADDRFP4 0
ADDRFP4 0
INDIRI4
CVII1 4
ASGNI1
file "../../engine/n_math.c"
line 79
;1:#ifndef GDR_DLLCOMPILE
;2:#include "n_shared.h"
;3:#else
;4:#include "../engine/n_shared.h"
;5:#endif
;6:
;7:#if defined(__SSE2__) || defined(_MSC_SSE2_)
;8:#define USING_SSE2
;9:#ifdef _MSC
;10:#include <intrin.h>
;11:#else
;12:#include <immintrin.h>
;13:#include <xmmintrin.h>
;14:#endif
;15:#endif
;16:
;17:const vec2_t vec2_origin = {0, 0};
;18:const vec3_t vec3_origin = {0, 0};
;19:
;20:const vec4_t		colorBlack	= {0, 0, 0, 1};
;21:const vec4_t		colorRed	= {1, 0, 0, 1};
;22:const vec4_t		colorGreen	= {0, 1, 0, 1};
;23:const vec4_t		colorBlue	= {0, 0, 1, 1};
;24:const vec4_t		colorYellow	= {1, 1, 0, 1};
;25:const vec4_t		colorMagenta= {1, 0, 1, 1};
;26:const vec4_t		colorCyan	= {0, 1, 1, 1};
;27:const vec4_t		colorWhite	= {1, 1, 1, 1};
;28:const vec4_t		colorLtGrey	= {0.75, 0.75, 0.75, 1};
;29:const vec4_t		colorMdGrey	= {0.5, 0.5, 0.5, 1};
;30:const vec4_t		colorDkGrey	= {0.25, 0.25, 0.25, 1};
;31:
;32:// actually there are 35 colors but we want to use bitmask safely
;33:const vec4_t g_color_table[ 64 ] = {
;34:
;35:	{0.0f, 0.0f, 0.0f, 1.0f},
;36:	{1.0f, 0.0f, 0.0f, 1.0f},
;37:	{0.0f, 1.0f, 0.0f, 1.0f},
;38:	{1.0f, 1.0f, 0.0f, 1.0f},
;39:	{0.2f, 0.2f, 1.0f, 1.0f}, //{0.0, 0.0, 1.0, 1.0},
;40:	{0.0f, 1.0f, 1.0f, 1.0f},
;41:	{1.0f, 0.0f, 1.0f, 1.0f},
;42:	{1.0f, 1.0f, 1.0f, 1.0f},
;43:
;44:	// extended color codes from CPMA/CNQ3:
;45:	{ 1.00000f, 0.50000f, 0.00000f, 1.00000f },	// 8
;46:	{ 0.60000f, 0.60000f, 1.00000f, 1.00000f },	// 9
;47:
;48:	// CPMA's alphabet rainbow
;49:	{ 1.00000f, 0.00000f, 0.00000f, 1.00000f },	// a
;50:	{ 1.00000f, 0.26795f, 0.00000f, 1.00000f },	// b
;51:	{ 1.00000f, 0.50000f, 0.00000f, 1.00000f },	// c
;52:	{ 1.00000f, 0.73205f, 0.00000f, 1.00000f },	// d
;53:	{ 1.00000f, 1.00000f, 0.00000f, 1.00000f },	// e
;54:	{ 0.73205f, 1.00000f, 0.00000f, 1.00000f },	// f
;55:	{ 0.50000f, 1.00000f, 0.00000f, 1.00000f },	// g
;56:	{ 0.26795f, 1.00000f, 0.00000f, 1.00000f },	// h
;57:	{ 0.00000f, 1.00000f, 0.00000f, 1.00000f },	// i
;58:	{ 0.00000f, 1.00000f, 0.26795f, 1.00000f },	// j
;59:	{ 0.00000f, 1.00000f, 0.50000f, 1.00000f },	// k
;60:	{ 0.00000f, 1.00000f, 0.73205f, 1.00000f },	// l
;61:	{ 0.00000f, 1.00000f, 1.00000f, 1.00000f },	// m
;62:	{ 0.00000f, 0.73205f, 1.00000f, 1.00000f },	// n
;63:	{ 0.00000f, 0.50000f, 1.00000f, 1.00000f },	// o
;64:	{ 0.00000f, 0.26795f, 1.00000f, 1.00000f },	// p
;65:	{ 0.00000f, 0.00000f, 1.00000f, 1.00000f },	// q
;66:	{ 0.26795f, 0.00000f, 1.00000f, 1.00000f },	// r
;67:	{ 0.50000f, 0.00000f, 1.00000f, 1.00000f },	// s
;68:	{ 0.73205f, 0.00000f, 1.00000f, 1.00000f },	// t
;69:	{ 1.00000f, 0.00000f, 1.00000f, 1.00000f },	// u
;70:	{ 1.00000f, 0.00000f, 0.73205f, 1.00000f },	// v
;71:	{ 1.00000f, 0.00000f, 0.50000f, 1.00000f },	// w
;72:	{ 1.00000f, 0.00000f, 0.26795f, 1.00000f },	// x
;73:	{ 1.0, 1.0, 1.0, 1.0 }, // y, white, duped so all colors can be expressed with this palette
;74:	{ 0.5, 0.5, 0.5, 1.0 }, // z, grey
;75:};
;76:
;77:
;78:int ColorIndexFromChar( char ccode )
;79:{
line 80
;80:	if ( ccode >= '0' && ccode <= '9' ) {
ADDRLP4 0
ADDRFP4 0
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 48
LTI4 $25
ADDRLP4 0
INDIRI4
CNSTI4 57
GTI4 $25
line 81
;81:		return ( ccode - '0' );
ADDRFP4 0
INDIRI1
CVII4 1
CNSTI4 48
SUBI4
RETI4
ADDRGP4 $24
JUMPV
LABELV $25
line 83
;82:	}
;83:	else if ( ccode >= 'a' && ccode <= 'z' ) {
ADDRLP4 4
ADDRFP4 0
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 97
LTI4 $27
ADDRLP4 4
INDIRI4
CNSTI4 122
GTI4 $27
line 84
;84:		return ( ccode - 'a' + 10 );
ADDRFP4 0
INDIRI1
CVII4 1
CNSTI4 97
SUBI4
CNSTI4 10
ADDI4
RETI4
ADDRGP4 $24
JUMPV
LABELV $27
line 86
;85:	}
;86:	else if ( ccode >= 'A' && ccode <= 'Z' ) {
ADDRLP4 8
ADDRFP4 0
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 65
LTI4 $29
ADDRLP4 8
INDIRI4
CNSTI4 90
GTI4 $29
line 87
;87:		return ( ccode - 'A' + 10 );
ADDRFP4 0
INDIRI1
CVII4 1
CNSTI4 65
SUBI4
CNSTI4 10
ADDI4
RETI4
ADDRGP4 $24
JUMPV
LABELV $29
line 89
;88:	}
;89:	else {
line 90
;90:		return  ColorIndex( S_COLOR_WHITE );
CNSTI4 7
RETI4
LABELV $24
endproc ColorIndexFromChar 12 0
data
export bytedirs
align 4
LABELV bytedirs
byte 4 3204879951
byte 4 0
byte 4 1062847556
byte 4 3202531056
byte 4 1047828139
byte 4 1063074669
byte 4 3197577718
byte 4 0
byte 4 1064605338
byte 4 3198039930
byte 4 1056964608
byte 4 1062149053
byte 4 3190184938
byte 4 1049007711
byte 4 1064532072
byte 4 0
byte 4 0
byte 4 1065353216
byte 4 0
byte 4 1062847556
byte 4 1057396303
byte 4 3189189110
byte 4 1060597999
byte 4 1060013330
byte 4 1041705462
byte 4 1060597999
byte 4 1060013330
byte 4 0
byte 4 1057396303
byte 4 1062847556
byte 4 1050556282
byte 4 1056964608
byte 4 1062149053
byte 4 1057396303
byte 4 0
byte 4 1062847556
byte 4 1050094070
byte 4 0
byte 4 1064605338
byte 4 1055047408
byte 4 1047828139
byte 4 1063074669
byte 4 1042701290
byte 4 1049007711
byte 4 1064532072
byte 4 3207496978
byte 4 1041705462
byte 4 1060597999
byte 4 3209632701
byte 4 1050556282
byte 4 1056964608
byte 4 3205921044
byte 4 1054458931
byte 4 1060121929
byte 4 3210331204
byte 4 1057396303
byte 4 0
byte 4 3210558317
byte 4 1055047408
byte 4 1047828139
byte 4 3208081647
byte 4 1060013330
byte 4 1041705462
byte 4 3207605577
byte 4 1058437396
byte 4 1054458931
byte 4 3204448256
byte 4 1062149053
byte 4 1050556282
byte 4 3195311787
byte 4 1063074669
byte 4 1055047408
byte 4 3201942579
byte 4 1060121929
byte 4 1058437396
byte 4 3208081647
byte 4 1060013330
byte 4 3189189110
byte 4 3204448256
byte 4 1062149053
byte 4 3198039930
byte 4 3204879951
byte 4 1062847556
byte 4 0
byte 4 0
byte 4 1062847556
byte 4 3204879951
byte 4 3195311787
byte 4 1063074669
byte 4 3202531056
byte 4 0
byte 4 1064605338
byte 4 3197577718
byte 4 3196491359
byte 4 1064532072
byte 4 3190184938
byte 4 0
byte 4 1065353216
byte 4 0
byte 4 0
byte 4 1064605338
byte 4 1050094070
byte 4 3196491359
byte 4 1064532072
byte 4 1042701290
byte 4 1047828139
byte 4 1063074669
byte 4 1055047408
byte 4 1049007711
byte 4 1064532072
byte 4 1042701290
byte 4 1056964608
byte 4 1062149053
byte 4 1050556282
byte 4 1047828139
byte 4 1063074669
byte 4 3202531056
byte 4 1049007711
byte 4 1064532072
byte 4 3190184938
byte 4 1056964608
byte 4 1062149053
byte 4 3198039930
byte 4 1062847556
byte 4 1057396303
byte 4 0
byte 4 1060597999
byte 4 1060013330
byte 4 1041705462
byte 4 1060597999
byte 4 1060013330
byte 4 3189189110
byte 4 1057396303
byte 4 1062847556
byte 4 0
byte 4 1054458931
byte 4 1060121929
byte 4 1058437396
byte 4 1063074669
byte 4 1055047408
byte 4 1047828139
byte 4 1060121929
byte 4 1058437396
byte 4 1054458931
byte 4 1062149053
byte 4 1050556282
byte 4 1056964608
byte 4 1060013330
byte 4 1041705462
byte 4 1060597999
byte 4 1058437396
byte 4 1054458931
byte 4 1060121929
byte 4 1064605338
byte 4 1050094070
byte 4 0
byte 4 1065353216
byte 4 0
byte 4 0
byte 4 1064532072
byte 4 1042701290
byte 4 1049007711
byte 4 1062847556
byte 4 3204879951
byte 4 0
byte 4 1064605338
byte 4 3197577718
byte 4 0
byte 4 1063074669
byte 4 3202531056
byte 4 1047828139
byte 4 1064532072
byte 4 3190184938
byte 4 1049007711
byte 4 1062149053
byte 4 3198039930
byte 4 1056964608
byte 4 1060013330
byte 4 3189189110
byte 4 1060597999
byte 4 1062847556
byte 4 0
byte 4 1057396303
byte 4 1063074669
byte 4 1055047408
byte 4 3195311787
byte 4 1062149053
byte 4 1050556282
byte 4 3204448256
byte 4 1064532072
byte 4 1042701290
byte 4 3196491359
byte 4 1057396303
byte 4 0
byte 4 3210331204
byte 4 1060013330
byte 4 1041705462
byte 4 3208081647
byte 4 1060013330
byte 4 3189189110
byte 4 3208081647
byte 4 1062847556
byte 4 0
byte 4 3204879951
byte 4 1062149053
byte 4 3198039930
byte 4 3204448256
byte 4 1063074669
byte 4 3202531056
byte 4 3195311787
byte 4 1064532072
byte 4 3190184938
byte 4 3196491359
byte 4 1041705462
byte 4 1060597999
byte 4 3207496978
byte 4 1050556282
byte 4 1056964608
byte 4 3209632701
byte 4 1054458931
byte 4 1060121929
byte 4 3205921044
byte 4 1055047408
byte 4 1047828139
byte 4 3210558317
byte 4 1058437396
byte 4 1054458931
byte 4 3207605577
byte 4 1060121929
byte 4 1058437396
byte 4 3201942579
byte 4 3189189110
byte 4 1060597999
byte 4 3207496978
byte 4 3198039930
byte 4 1056964608
byte 4 3209632701
byte 4 0
byte 4 1057396303
byte 4 3210331204
byte 4 3204879951
byte 4 0
byte 4 3210331204
byte 4 3202531056
byte 4 1047828139
byte 4 3210558317
byte 4 3197577718
byte 4 0
byte 4 3212088986
byte 4 3190184938
byte 4 1049007711
byte 4 3212015720
byte 4 0
byte 4 0
byte 4 3212836864
byte 4 1050094070
byte 4 0
byte 4 3212088986
byte 4 1042701290
byte 4 1049007711
byte 4 3212015720
byte 4 3202531056
byte 4 3195311787
byte 4 3210558317
byte 4 3198039930
byte 4 3204448256
byte 4 3209632701
byte 4 3190184938
byte 4 3196491359
byte 4 3212015720
byte 4 0
byte 4 3210331204
byte 4 3204879951
byte 4 3189189110
byte 4 3208081647
byte 4 3207496978
byte 4 1041705462
byte 4 3208081647
byte 4 3207496978
byte 4 0
byte 4 3204879951
byte 4 3210331204
byte 4 1050556282
byte 4 3204448256
byte 4 3209632701
byte 4 1055047408
byte 4 3195311787
byte 4 3210558317
byte 4 1042701290
byte 4 3196491359
byte 4 3212015720
byte 4 1047828139
byte 4 3210558317
byte 4 3202531056
byte 4 1056964608
byte 4 3209632701
byte 4 3198039930
byte 4 1054458931
byte 4 3207605577
byte 4 3205921044
byte 4 1060597999
byte 4 3207496978
byte 4 3189189110
byte 4 1060121929
byte 4 3205921044
byte 4 3201942579
byte 4 1058437396
byte 4 3201942579
byte 4 3207605577
byte 4 0
byte 4 3212088986
byte 4 3197577718
byte 4 0
byte 4 3212836864
byte 4 0
byte 4 1049007711
byte 4 3212015720
byte 4 3190184938
byte 4 0
byte 4 3210331204
byte 4 1057396303
byte 4 0
byte 4 3212088986
byte 4 1050094070
byte 4 1047828139
byte 4 3210558317
byte 4 1055047408
byte 4 1049007711
byte 4 3212015720
byte 4 1042701290
byte 4 1056964608
byte 4 3209632701
byte 4 1050556282
byte 4 1060597999
byte 4 3207496978
byte 4 1041705462
byte 4 1057396303
byte 4 3210331204
byte 4 0
byte 4 3195311787
byte 4 3210558317
byte 4 3202531056
byte 4 3204448256
byte 4 3209632701
byte 4 3198039930
byte 4 3196491359
byte 4 3212015720
byte 4 3190184938
byte 4 3210331204
byte 4 3204879951
byte 4 0
byte 4 3208081647
byte 4 3207496978
byte 4 3189189110
byte 4 3208081647
byte 4 3207496978
byte 4 1041705462
byte 4 3204879951
byte 4 3210331204
byte 4 0
byte 4 3204448256
byte 4 3209632701
byte 4 1050556282
byte 4 3195311787
byte 4 3210558317
byte 4 1055047408
byte 4 3196491359
byte 4 3212015720
byte 4 1042701290
byte 4 3210558317
byte 4 3202531056
byte 4 1047828139
byte 4 3209632701
byte 4 3198039930
byte 4 1056964608
byte 4 3207605577
byte 4 3205921044
byte 4 1054458931
byte 4 3207496978
byte 4 3189189110
byte 4 1060597999
byte 4 3202531056
byte 4 3195311787
byte 4 1063074669
byte 4 3205921044
byte 4 3201942579
byte 4 1060121929
byte 4 3198039930
byte 4 3204448256
byte 4 1062149053
byte 4 3189189110
byte 4 3208081647
byte 4 1060013330
byte 4 3201942579
byte 4 3207605577
byte 4 1058437396
byte 4 3190184938
byte 4 3196491359
byte 4 1064532072
byte 4 1055047408
byte 4 3195311787
byte 4 1063074669
byte 4 1042701290
byte 4 3196491359
byte 4 1064532072
byte 4 1050556282
byte 4 3204448256
byte 4 1062149053
byte 4 1041705462
byte 4 3208081647
byte 4 1060013330
byte 4 0
byte 4 3204879951
byte 4 1062847556
byte 4 1054458931
byte 4 3207605577
byte 4 1058437396
byte 4 1058437396
byte 4 3201942579
byte 4 1060121929
byte 4 1060121929
byte 4 3205921044
byte 4 1054458931
byte 4 3212088986
byte 4 1050094070
byte 4 0
byte 4 3212015720
byte 4 1042701290
byte 4 1049007711
byte 4 3212836864
byte 4 0
byte 4 0
byte 4 3210331204
byte 4 0
byte 4 1057396303
byte 4 3212088986
byte 4 3197577718
byte 4 0
byte 4 3212015720
byte 4 3190184938
byte 4 1049007711
byte 4 3210558317
byte 4 1055047408
byte 4 3195311787
byte 4 3212015720
byte 4 1042701290
byte 4 3196491359
byte 4 3209632701
byte 4 1050556282
byte 4 3204448256
byte 4 3210558317
byte 4 3202531056
byte 4 3195311787
byte 4 3212015720
byte 4 3190184938
byte 4 3196491359
byte 4 3209632701
byte 4 3198039930
byte 4 3204448256
byte 4 3207496978
byte 4 1041705462
byte 4 3208081647
byte 4 3207496978
byte 4 3189189110
byte 4 3208081647
byte 4 3210331204
byte 4 0
byte 4 3204879951
byte 4 3207605577
byte 4 1058437396
byte 4 3201942579
byte 4 3205921044
byte 4 1054458931
byte 4 3207605577
byte 4 3201942579
byte 4 1060121929
byte 4 3205921044
byte 4 3201942579
byte 4 3207605577
byte 4 3205921044
byte 4 3205921044
byte 4 3201942579
byte 4 3207605577
byte 4 3207605577
byte 4 3205921044
byte 4 3201942579
export Q_rand
code
proc Q_rand 4 0
line 181
;91:	}
;92:}
;93:
;94:vec3_t	bytedirs[NUMVERTEXNORMALS] =
;95:{
;96:{-0.525731f, 0.000000f, 0.850651f}, {-0.442863f, 0.238856f, 0.864188f}, 
;97:{-0.295242f, 0.000000f, 0.955423f}, {-0.309017f, 0.500000f, 0.809017f}, 
;98:{-0.162460f, 0.262866f, 0.951056f}, {0.000000f, 0.000000f, 1.000000f}, 
;99:{0.000000f, 0.850651f, 0.525731f}, {-0.147621f, 0.716567f, 0.681718f}, 
;100:{0.147621f, 0.716567f, 0.681718f}, {0.000000f, 0.525731f, 0.850651f}, 
;101:{0.309017f, 0.500000f, 0.809017f}, {0.525731f, 0.000000f, 0.850651f}, 
;102:{0.295242f, 0.000000f, 0.955423f}, {0.442863f, 0.238856f, 0.864188f}, 
;103:{0.162460f, 0.262866f, 0.951056f}, {-0.681718f, 0.147621f, 0.716567f}, 
;104:{-0.809017f, 0.309017f, 0.500000f},{-0.587785f, 0.425325f, 0.688191f}, 
;105:{-0.850651f, 0.525731f, 0.000000f},{-0.864188f, 0.442863f, 0.238856f}, 
;106:{-0.716567f, 0.681718f, 0.147621f},{-0.688191f, 0.587785f, 0.425325f}, 
;107:{-0.500000f, 0.809017f, 0.309017f}, {-0.238856f, 0.864188f, 0.442863f}, 
;108:{-0.425325f, 0.688191f, 0.587785f}, {-0.716567f, 0.681718f, -0.147621f}, 
;109:{-0.500000f, 0.809017f, -0.309017f}, {-0.525731f, 0.850651f, 0.000000f}, 
;110:{0.000000f, 0.850651f, -0.525731f}, {-0.238856f, 0.864188f, -0.442863f}, 
;111:{0.000000f, 0.955423f, -0.295242f}, {-0.262866f, 0.951056f, -0.162460f}, 
;112:{0.000000f, 1.000000f, 0.000000f}, {0.000000f, 0.955423f, 0.295242f}, 
;113:{-0.262866f, 0.951056f, 0.162460f}, {0.238856f, 0.864188f, 0.442863f}, 
;114:{0.262866f, 0.951056f, 0.162460f}, {0.500000f, 0.809017f, 0.309017f}, 
;115:{0.238856f, 0.864188f, -0.442863f},{0.262866f, 0.951056f, -0.162460f}, 
;116:{0.500000f, 0.809017f, -0.309017f},{0.850651f, 0.525731f, 0.000000f}, 
;117:{0.716567f, 0.681718f, 0.147621f}, {0.716567f, 0.681718f, -0.147621f}, 
;118:{0.525731f, 0.850651f, 0.000000f}, {0.425325f, 0.688191f, 0.587785f}, 
;119:{0.864188f, 0.442863f, 0.238856f}, {0.688191f, 0.587785f, 0.425325f}, 
;120:{0.809017f, 0.309017f, 0.500000f}, {0.681718f, 0.147621f, 0.716567f}, 
;121:{0.587785f, 0.425325f, 0.688191f}, {0.955423f, 0.295242f, 0.000000f}, 
;122:{1.000000f, 0.000000f, 0.000000f}, {0.951056f, 0.162460f, 0.262866f}, 
;123:{0.850651f, -0.525731f, 0.000000f},{0.955423f, -0.295242f, 0.000000f}, 
;124:{0.864188f, -0.442863f, 0.238856f}, {0.951056f, -0.162460f, 0.262866f}, 
;125:{0.809017f, -0.309017f, 0.500000f}, {0.681718f, -0.147621f, 0.716567f}, 
;126:{0.850651f, 0.000000f, 0.525731f}, {0.864188f, 0.442863f, -0.238856f}, 
;127:{0.809017f, 0.309017f, -0.500000f}, {0.951056f, 0.162460f, -0.262866f}, 
;128:{0.525731f, 0.000000f, -0.850651f}, {0.681718f, 0.147621f, -0.716567f}, 
;129:{0.681718f, -0.147621f, -0.716567f},{0.850651f, 0.000000f, -0.525731f}, 
;130:{0.809017f, -0.309017f, -0.500000f}, {0.864188f, -0.442863f, -0.238856f}, 
;131:{0.951056f, -0.162460f, -0.262866f}, {0.147621f, 0.716567f, -0.681718f}, 
;132:{0.309017f, 0.500000f, -0.809017f}, {0.425325f, 0.688191f, -0.587785f}, 
;133:{0.442863f, 0.238856f, -0.864188f}, {0.587785f, 0.425325f, -0.688191f}, 
;134:{0.688191f, 0.587785f, -0.425325f}, {-0.147621f, 0.716567f, -0.681718f}, 
;135:{-0.309017f, 0.500000f, -0.809017f}, {0.000000f, 0.525731f, -0.850651f}, 
;136:{-0.525731f, 0.000000f, -0.850651f}, {-0.442863f, 0.238856f, -0.864188f}, 
;137:{-0.295242f, 0.000000f, -0.955423f}, {-0.162460f, 0.262866f, -0.951056f}, 
;138:{0.000000f, 0.000000f, -1.000000f}, {0.295242f, 0.000000f, -0.955423f}, 
;139:{0.162460f, 0.262866f, -0.951056f}, {-0.442863f, -0.238856f, -0.864188f}, 
;140:{-0.309017f, -0.500000f, -0.809017f}, {-0.162460f, -0.262866f, -0.951056f}, 
;141:{0.000000f, -0.850651f, -0.525731f}, {-0.147621f, -0.716567f, -0.681718f}, 
;142:{0.147621f, -0.716567f, -0.681718f}, {0.000000f, -0.525731f, -0.850651f}, 
;143:{0.309017f, -0.500000f, -0.809017f}, {0.442863f, -0.238856f, -0.864188f}, 
;144:{0.162460f, -0.262866f, -0.951056f}, {0.238856f, -0.864188f, -0.442863f}, 
;145:{0.500000f, -0.809017f, -0.309017f}, {0.425325f, -0.688191f, -0.587785f}, 
;146:{0.716567f, -0.681718f, -0.147621f}, {0.688191f, -0.587785f, -0.425325f}, 
;147:{0.587785f, -0.425325f, -0.688191f}, {0.000000f, -0.955423f, -0.295242f}, 
;148:{0.000000f, -1.000000f, 0.000000f}, {0.262866f, -0.951056f, -0.162460f}, 
;149:{0.000000f, -0.850651f, 0.525731f}, {0.000000f, -0.955423f, 0.295242f}, 
;150:{0.238856f, -0.864188f, 0.442863f}, {0.262866f, -0.951056f, 0.162460f}, 
;151:{0.500000f, -0.809017f, 0.309017f}, {0.716567f, -0.681718f, 0.147621f}, 
;152:{0.525731f, -0.850651f, 0.000000f}, {-0.238856f, -0.864188f, -0.442863f}, 
;153:{-0.500000f, -0.809017f, -0.309017f}, {-0.262866f, -0.951056f, -0.162460f}, 
;154:{-0.850651f, -0.525731f, 0.000000f}, {-0.716567f, -0.681718f, -0.147621f}, 
;155:{-0.716567f, -0.681718f, 0.147621f}, {-0.525731f, -0.850651f, 0.000000f}, 
;156:{-0.500000f, -0.809017f, 0.309017f}, {-0.238856f, -0.864188f, 0.442863f}, 
;157:{-0.262866f, -0.951056f, 0.162460f}, {-0.864188f, -0.442863f, 0.238856f}, 
;158:{-0.809017f, -0.309017f, 0.500000f}, {-0.688191f, -0.587785f, 0.425325f}, 
;159:{-0.681718f, -0.147621f, 0.716567f}, {-0.442863f, -0.238856f, 0.864188f}, 
;160:{-0.587785f, -0.425325f, 0.688191f}, {-0.309017f, -0.500000f, 0.809017f}, 
;161:{-0.147621f, -0.716567f, 0.681718f}, {-0.425325f, -0.688191f, 0.587785f}, 
;162:{-0.162460f, -0.262866f, 0.951056f}, {0.442863f, -0.238856f, 0.864188f}, 
;163:{0.162460f, -0.262866f, 0.951056f}, {0.309017f, -0.500000f, 0.809017f}, 
;164:{0.147621f, -0.716567f, 0.681718f}, {0.000000f, -0.525731f, 0.850651f}, 
;165:{0.425325f, -0.688191f, 0.587785f}, {0.587785f, -0.425325f, 0.688191f}, 
;166:{0.688191f, -0.587785f, 0.425325f}, {-0.955423f, 0.295242f, 0.000000f}, 
;167:{-0.951056f, 0.162460f, 0.262866f}, {-1.000000f, 0.000000f, 0.000000f}, 
;168:{-0.850651f, 0.000000f, 0.525731f}, {-0.955423f, -0.295242f, 0.000000f}, 
;169:{-0.951056f, -0.162460f, 0.262866f}, {-0.864188f, 0.442863f, -0.238856f}, 
;170:{-0.951056f, 0.162460f, -0.262866f}, {-0.809017f, 0.309017f, -0.500000f}, 
;171:{-0.864188f, -0.442863f, -0.238856f}, {-0.951056f, -0.162460f, -0.262866f}, 
;172:{-0.809017f, -0.309017f, -0.500000f}, {-0.681718f, 0.147621f, -0.716567f}, 
;173:{-0.681718f, -0.147621f, -0.716567f}, {-0.850651f, 0.000000f, -0.525731f}, 
;174:{-0.688191f, 0.587785f, -0.425325f}, {-0.587785f, 0.425325f, -0.688191f}, 
;175:{-0.425325f, 0.688191f, -0.587785f}, {-0.425325f, -0.688191f, -0.587785f}, 
;176:{-0.587785f, -0.425325f, -0.688191f}, {-0.688191f, -0.587785f, -0.425325f}
;177:};
;178:
;179://==============================================================
;180:
;181:int		Q_rand( int *seed ) {
line 182
;182:	*seed = (69069 * *seed + 1);
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 0
INDIRP4
ADDRLP4 0
INDIRP4
INDIRI4
CNSTI4 69069
MULI4
CNSTI4 1
ADDI4
ASGNI4
line 183
;183:	return *seed;
ADDRFP4 0
INDIRP4
INDIRI4
RETI4
LABELV $31
endproc Q_rand 4 0
export Q_random
proc Q_random 4 4
line 186
;184:}
;185:
;186:float	Q_random( int *seed ) {
line 187
;187:	return ( Q_rand( seed ) & 0xffff ) / (float)0x10000;
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 0
ADDRGP4 Q_rand
CALLI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 65535
BANDI4
CVIF4 4
CNSTF4 931135488
MULF4
RETF4
LABELV $32
endproc Q_random 4 4
export Q_crandom
proc Q_crandom 4 4
line 190
;188:}
;189:
;190:float	Q_crandom( int *seed ) {
line 191
;191:	return 2.0 * ( Q_random( seed ) - 0.5 );
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 0
ADDRGP4 Q_random
CALLF4
ASGNF4
ADDRLP4 0
INDIRF4
CNSTF4 1056964608
SUBF4
CNSTF4 1073741824
MULF4
RETF4
LABELV $33
endproc Q_crandom 4 4
export ClampChar
proc ClampChar 0 0
line 196
;192:}
;193:
;194://=======================================================
;195:
;196:signed char ClampChar( int i ) {
line 197
;197:	if ( i < -128 ) {
ADDRFP4 0
INDIRI4
CNSTI4 -128
GEI4 $35
line 198
;198:		return -128;
CNSTI4 -128
RETI4
ADDRGP4 $34
JUMPV
LABELV $35
line 200
;199:	}
;200:	if ( i > 127 ) {
ADDRFP4 0
INDIRI4
CNSTI4 127
LEI4 $37
line 201
;201:		return 127;
CNSTI4 127
RETI4
ADDRGP4 $34
JUMPV
LABELV $37
line 203
;202:	}
;203:	return i;
ADDRFP4 0
INDIRI4
CVII1 4
CVII4 1
RETI4
LABELV $34
endproc ClampChar 0 0
export ClampCharMove
proc ClampCharMove 0 0
line 206
;204:}
;205:
;206:signed char ClampCharMove( int i ) {
line 207
;207:	if ( i < -127 ) {
ADDRFP4 0
INDIRI4
CNSTI4 -127
GEI4 $40
line 208
;208:		return -127;
CNSTI4 -127
RETI4
ADDRGP4 $39
JUMPV
LABELV $40
line 210
;209:	}
;210:	if ( i > 127 ) {
ADDRFP4 0
INDIRI4
CNSTI4 127
LEI4 $42
line 211
;211:		return 127;
CNSTI4 127
RETI4
ADDRGP4 $39
JUMPV
LABELV $42
line 213
;212:	}
;213:	return i;
ADDRFP4 0
INDIRI4
CVII1 4
CVII4 1
RETI4
LABELV $39
endproc ClampCharMove 0 0
export ClampShort
proc ClampShort 0 0
line 216
;214:}
;215:
;216:signed short ClampShort( int i ) {
line 217
;217:	if ( i < -32768 ) {
ADDRFP4 0
INDIRI4
CNSTI4 -32768
GEI4 $45
line 218
;218:		return -32768;
CNSTI4 -32768
RETI4
ADDRGP4 $44
JUMPV
LABELV $45
line 220
;219:	}
;220:	if ( i > 0x7fff ) {
ADDRFP4 0
INDIRI4
CNSTI4 32767
LEI4 $47
line 221
;221:		return 0x7fff;
CNSTI4 32767
RETI4
ADDRGP4 $44
JUMPV
LABELV $47
line 223
;222:	}
;223:	return i;
ADDRFP4 0
INDIRI4
CVII2 4
CVII4 2
RETI4
LABELV $44
endproc ClampShort 0 0
export DirToByte
proc DirToByte 24 0
line 228
;224:}
;225:
;226:
;227:// this isn't a real cheap function to call!
;228:int DirToByte( vec3_t dir ) {
line 232
;229:	int		i, best;
;230:	float	d, bestd;
;231:
;232:	if ( !dir ) {
ADDRFP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $50
line 233
;233:		return 0;
CNSTI4 0
RETI4
ADDRGP4 $49
JUMPV
LABELV $50
line 236
;234:	}
;235:
;236:	bestd = 0;
ADDRLP4 8
CNSTF4 0
ASGNF4
line 237
;237:	best = 0;
ADDRLP4 12
CNSTI4 0
ASGNI4
line 238
;238:	for (i=0 ; i<NUMVERTEXNORMALS ; i++)
ADDRLP4 0
CNSTI4 0
ASGNI4
LABELV $52
line 239
;239:	{
line 240
;240:		d = DotProduct (dir, bytedirs[i]);
ADDRLP4 16
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 4
ADDRLP4 16
INDIRP4
INDIRF4
ADDRLP4 0
INDIRI4
CNSTI4 12
MULI4
ADDRGP4 bytedirs
ADDP4
INDIRF4
MULF4
ADDRLP4 16
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ADDRLP4 0
INDIRI4
CNSTI4 12
MULI4
ADDRGP4 bytedirs+4
ADDP4
INDIRF4
MULF4
ADDF4
ADDRLP4 16
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ADDRLP4 0
INDIRI4
CNSTI4 12
MULI4
ADDRGP4 bytedirs+8
ADDP4
INDIRF4
MULF4
ADDF4
ASGNF4
line 241
;241:		if (d > bestd)
ADDRLP4 4
INDIRF4
ADDRLP4 8
INDIRF4
LEF4 $58
line 242
;242:		{
line 243
;243:			bestd = d;
ADDRLP4 8
ADDRLP4 4
INDIRF4
ASGNF4
line 244
;244:			best = i;
ADDRLP4 12
ADDRLP4 0
INDIRI4
ASGNI4
line 245
;245:		}
LABELV $58
line 246
;246:	}
LABELV $53
line 238
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 162
LTI4 $52
line 248
;247:
;248:	return best;
ADDRLP4 12
INDIRI4
RETI4
LABELV $49
endproc DirToByte 24 0
export ByteToDir
proc ByteToDir 4 0
line 251
;249:}
;250:
;251:void ByteToDir( int b, vec3_t dir ) {
line 252
;252:	if ( b < 0 || b >= NUMVERTEXNORMALS ) {
ADDRLP4 0
ADDRFP4 0
INDIRI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 0
LTI4 $63
ADDRLP4 0
INDIRI4
CNSTI4 162
LTI4 $61
LABELV $63
line 253
;253:		VectorCopy( dir, vec3_origin );
ADDRGP4 vec3_origin
ADDRFP4 4
INDIRP4
INDIRB
ASGNB 12
line 254
;254:		return;
ADDRGP4 $60
JUMPV
LABELV $61
line 256
;255:	}
;256:	VectorCopy (dir,bytedirs[b]);
ADDRFP4 0
INDIRI4
CNSTI4 12
MULI4
ADDRGP4 bytedirs
ADDP4
ADDRFP4 4
INDIRP4
INDIRB
ASGNB 12
line 257
;257:}
LABELV $60
endproc ByteToDir 4 0
export ColorBytes3
proc ColorBytes3 40 0
line 260
;258:
;259:
;260:unsigned ColorBytes3 (float r, float g, float b) {
line 263
;261:	unsigned	i;
;262:
;263:	( (byte *)&i )[0] = r * 255;
ADDRLP4 8
ADDRFP4 0
INDIRF4
CNSTF4 1132396544
MULF4
ASGNF4
ADDRLP4 12
CNSTF4 1325400064
ASGNF4
ADDRLP4 8
INDIRF4
ADDRLP4 12
INDIRF4
LTF4 $66
ADDRLP4 4
ADDRLP4 8
INDIRF4
ADDRLP4 12
INDIRF4
SUBF4
CVFI4 4
CVIU4 4
CNSTU4 2147483648
ADDU4
ASGNU4
ADDRGP4 $67
JUMPV
LABELV $66
ADDRLP4 4
ADDRLP4 8
INDIRF4
CVFI4 4
CVIU4 4
ASGNU4
LABELV $67
ADDRLP4 0
ADDRLP4 4
INDIRU4
CVUU1 4
ASGNU1
line 264
;264:	( (byte *)&i )[1] = g * 255;
ADDRLP4 20
ADDRFP4 4
INDIRF4
CNSTF4 1132396544
MULF4
ASGNF4
ADDRLP4 24
CNSTF4 1325400064
ASGNF4
ADDRLP4 20
INDIRF4
ADDRLP4 24
INDIRF4
LTF4 $70
ADDRLP4 16
ADDRLP4 20
INDIRF4
ADDRLP4 24
INDIRF4
SUBF4
CVFI4 4
CVIU4 4
CNSTU4 2147483648
ADDU4
ASGNU4
ADDRGP4 $71
JUMPV
LABELV $70
ADDRLP4 16
ADDRLP4 20
INDIRF4
CVFI4 4
CVIU4 4
ASGNU4
LABELV $71
ADDRLP4 0+1
ADDRLP4 16
INDIRU4
CVUU1 4
ASGNU1
line 265
;265:	( (byte *)&i )[2] = b * 255;
ADDRLP4 32
ADDRFP4 8
INDIRF4
CNSTF4 1132396544
MULF4
ASGNF4
ADDRLP4 36
CNSTF4 1325400064
ASGNF4
ADDRLP4 32
INDIRF4
ADDRLP4 36
INDIRF4
LTF4 $74
ADDRLP4 28
ADDRLP4 32
INDIRF4
ADDRLP4 36
INDIRF4
SUBF4
CVFI4 4
CVIU4 4
CNSTU4 2147483648
ADDU4
ASGNU4
ADDRGP4 $75
JUMPV
LABELV $74
ADDRLP4 28
ADDRLP4 32
INDIRF4
CVFI4 4
CVIU4 4
ASGNU4
LABELV $75
ADDRLP4 0+2
ADDRLP4 28
INDIRU4
CVUU1 4
ASGNU1
line 267
;266:
;267:	return i;
ADDRLP4 0
INDIRU4
RETU4
LABELV $64
endproc ColorBytes3 40 0
export ColorBytes4
proc ColorBytes4 52 0
line 270
;268:}
;269:
;270:unsigned ColorBytes4 (float r, float g, float b, float a) {
line 273
;271:	unsigned	i;
;272:
;273:	( (byte *)&i )[0] = r * 255;
ADDRLP4 8
ADDRFP4 0
INDIRF4
CNSTF4 1132396544
MULF4
ASGNF4
ADDRLP4 12
CNSTF4 1325400064
ASGNF4
ADDRLP4 8
INDIRF4
ADDRLP4 12
INDIRF4
LTF4 $78
ADDRLP4 4
ADDRLP4 8
INDIRF4
ADDRLP4 12
INDIRF4
SUBF4
CVFI4 4
CVIU4 4
CNSTU4 2147483648
ADDU4
ASGNU4
ADDRGP4 $79
JUMPV
LABELV $78
ADDRLP4 4
ADDRLP4 8
INDIRF4
CVFI4 4
CVIU4 4
ASGNU4
LABELV $79
ADDRLP4 0
ADDRLP4 4
INDIRU4
CVUU1 4
ASGNU1
line 274
;274:	( (byte *)&i )[1] = g * 255;
ADDRLP4 20
ADDRFP4 4
INDIRF4
CNSTF4 1132396544
MULF4
ASGNF4
ADDRLP4 24
CNSTF4 1325400064
ASGNF4
ADDRLP4 20
INDIRF4
ADDRLP4 24
INDIRF4
LTF4 $82
ADDRLP4 16
ADDRLP4 20
INDIRF4
ADDRLP4 24
INDIRF4
SUBF4
CVFI4 4
CVIU4 4
CNSTU4 2147483648
ADDU4
ASGNU4
ADDRGP4 $83
JUMPV
LABELV $82
ADDRLP4 16
ADDRLP4 20
INDIRF4
CVFI4 4
CVIU4 4
ASGNU4
LABELV $83
ADDRLP4 0+1
ADDRLP4 16
INDIRU4
CVUU1 4
ASGNU1
line 275
;275:	( (byte *)&i )[2] = b * 255;
ADDRLP4 32
ADDRFP4 8
INDIRF4
CNSTF4 1132396544
MULF4
ASGNF4
ADDRLP4 36
CNSTF4 1325400064
ASGNF4
ADDRLP4 32
INDIRF4
ADDRLP4 36
INDIRF4
LTF4 $86
ADDRLP4 28
ADDRLP4 32
INDIRF4
ADDRLP4 36
INDIRF4
SUBF4
CVFI4 4
CVIU4 4
CNSTU4 2147483648
ADDU4
ASGNU4
ADDRGP4 $87
JUMPV
LABELV $86
ADDRLP4 28
ADDRLP4 32
INDIRF4
CVFI4 4
CVIU4 4
ASGNU4
LABELV $87
ADDRLP4 0+2
ADDRLP4 28
INDIRU4
CVUU1 4
ASGNU1
line 276
;276:	( (byte *)&i )[3] = a * 255;
ADDRLP4 44
ADDRFP4 12
INDIRF4
CNSTF4 1132396544
MULF4
ASGNF4
ADDRLP4 48
CNSTF4 1325400064
ASGNF4
ADDRLP4 44
INDIRF4
ADDRLP4 48
INDIRF4
LTF4 $90
ADDRLP4 40
ADDRLP4 44
INDIRF4
ADDRLP4 48
INDIRF4
SUBF4
CVFI4 4
CVIU4 4
CNSTU4 2147483648
ADDU4
ASGNU4
ADDRGP4 $91
JUMPV
LABELV $90
ADDRLP4 40
ADDRLP4 44
INDIRF4
CVFI4 4
CVIU4 4
ASGNU4
LABELV $91
ADDRLP4 0+3
ADDRLP4 40
INDIRU4
CVUU1 4
ASGNU1
line 278
;277:
;278:	return i;
ADDRLP4 0
INDIRU4
RETU4
LABELV $76
endproc ColorBytes4 52 0
export NormalizeColor
proc NormalizeColor 12 0
line 281
;279:}
;280:
;281:float NormalizeColor( const vec3_t in, vec3_t out ) {
line 284
;282:	float	max;
;283:	
;284:	max = in[0];
ADDRLP4 0
ADDRFP4 0
INDIRP4
INDIRF4
ASGNF4
line 285
;285:	if ( in[1] > max ) {
ADDRFP4 0
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ADDRLP4 0
INDIRF4
LEF4 $93
line 286
;286:		max = in[1];
ADDRLP4 0
ADDRFP4 0
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ASGNF4
line 287
;287:	}
LABELV $93
line 288
;288:	if ( in[2] > max ) {
ADDRFP4 0
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ADDRLP4 0
INDIRF4
LEF4 $95
line 289
;289:		max = in[2];
ADDRLP4 0
ADDRFP4 0
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ASGNF4
line 290
;290:	}
LABELV $95
line 292
;291:
;292:	if ( !max ) {
ADDRLP4 0
INDIRF4
CNSTF4 0
NEF4 $97
line 293
;293:		VectorClear( out );
ADDRLP4 4
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 8
CNSTF4 0
ASGNF4
ADDRLP4 4
INDIRP4
CNSTI4 8
ADDP4
ADDRLP4 8
INDIRF4
ASGNF4
ADDRLP4 4
INDIRP4
CNSTI4 4
ADDP4
ADDRLP4 8
INDIRF4
ASGNF4
ADDRLP4 4
INDIRP4
ADDRLP4 8
INDIRF4
ASGNF4
line 294
;294:	} else {
ADDRGP4 $98
JUMPV
LABELV $97
line 295
;295:		out[0] = in[0] / max;
ADDRFP4 4
INDIRP4
ADDRFP4 0
INDIRP4
INDIRF4
ADDRLP4 0
INDIRF4
DIVF4
ASGNF4
line 296
;296:		out[1] = in[1] / max;
ADDRFP4 4
INDIRP4
CNSTI4 4
ADDP4
ADDRFP4 0
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ADDRLP4 0
INDIRF4
DIVF4
ASGNF4
line 297
;297:		out[2] = in[2] / max;
ADDRFP4 4
INDIRP4
CNSTI4 8
ADDP4
ADDRFP4 0
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ADDRLP4 0
INDIRF4
DIVF4
ASGNF4
line 298
;298:	}
LABELV $98
line 299
;299:	return max;
ADDRLP4 0
INDIRF4
RETF4
LABELV $92
endproc NormalizeColor 12 0
export PlaneFromPoints
proc PlaneFromPoints 52 12
line 311
;300:}
;301:
;302:
;303:/*
;304:=====================
;305:PlaneFromPoints
;306:
;307:Returns false if the triangle is degenerate.
;308:The normal will point out of the clock for clockwise ordered points
;309:=====================
;310:*/
;311:qboolean PlaneFromPoints( vec4_t plane, const vec3_t a, const vec3_t b, const vec3_t c ) {
line 314
;312:	vec3_t	d1, d2;
;313:
;314:	VectorSubtract( b, a, d1 );
ADDRLP4 24
ADDRFP4 8
INDIRP4
ASGNP4
ADDRLP4 28
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 24
INDIRP4
INDIRF4
ADDRLP4 28
INDIRP4
INDIRF4
SUBF4
ASGNF4
ADDRLP4 0+4
ADDRLP4 24
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ADDRLP4 28
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
SUBF4
ASGNF4
ADDRLP4 0+8
ADDRFP4 8
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ADDRFP4 4
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
SUBF4
ASGNF4
line 315
;315:	VectorSubtract( c, a, d2 );
ADDRLP4 32
ADDRFP4 12
INDIRP4
ASGNP4
ADDRLP4 36
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 12
ADDRLP4 32
INDIRP4
INDIRF4
ADDRLP4 36
INDIRP4
INDIRF4
SUBF4
ASGNF4
ADDRLP4 12+4
ADDRLP4 32
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ADDRLP4 36
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
SUBF4
ASGNF4
ADDRLP4 12+8
ADDRFP4 12
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ADDRFP4 4
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
SUBF4
ASGNF4
line 316
;316:	CrossProduct( d2, d1, plane );
ADDRLP4 12
ARGP4
ADDRLP4 0
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRGP4 CrossProduct
CALLV
pop
line 317
;317:	if ( VectorNormalize( plane ) == 0 ) {
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 40
ADDRGP4 VectorNormalize
CALLF4
ASGNF4
ADDRLP4 40
INDIRF4
CNSTF4 0
NEF4 $104
line 318
;318:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $99
JUMPV
LABELV $104
line 321
;319:	}
;320:
;321:	plane[3] = DotProduct( a, plane );
ADDRLP4 44
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 48
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 44
INDIRP4
CNSTI4 12
ADDP4
ADDRLP4 48
INDIRP4
INDIRF4
ADDRLP4 44
INDIRP4
INDIRF4
MULF4
ADDRLP4 48
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ADDRLP4 44
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
MULF4
ADDF4
ADDRLP4 48
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ADDRLP4 44
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
MULF4
ADDF4
ASGNF4
line 322
;322:	return qtrue;
CNSTI4 1
RETI4
LABELV $99
endproc PlaneFromPoints 52 12
export RotatePointAroundVector
proc RotatePointAroundVector 252 12
line 333
;323:}
;324:
;325:/*
;326:===============
;327:RotatePointAroundVector
;328:
;329:This is not implemented very well...
;330:===============
;331:*/
;332:void RotatePointAroundVector( vec3_t dst, const vec3_t dir, const vec3_t point,
;333:							 float degrees ) {
line 343
;334:	float	m[3][3];
;335:	float	im[3][3];
;336:	float	zrot[3][3];
;337:	float	tmpmat[3][3];
;338:	float	rot[3][3];
;339:	int	i;
;340:	vec3_t vr, vup, vf;
;341:	float	rad;
;342:
;343:	vf[0] = dir[0];
ADDRLP4 148
ADDRFP4 4
INDIRP4
INDIRF4
ASGNF4
line 344
;344:	vf[1] = dir[1];
ADDRLP4 148+4
ADDRFP4 4
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ASGNF4
line 345
;345:	vf[2] = dir[2];
ADDRLP4 148+8
ADDRFP4 4
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ASGNF4
line 347
;346:
;347:	PerpendicularVector( vr, dir );
ADDRLP4 160
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRGP4 PerpendicularVector
CALLV
pop
line 348
;348:	CrossProduct( vr, vf, vup );
ADDRLP4 160
ARGP4
ADDRLP4 148
ARGP4
ADDRLP4 176
ARGP4
ADDRGP4 CrossProduct
CALLV
pop
line 350
;349:
;350:	m[0][0] = vr[0];
ADDRLP4 40
ADDRLP4 160
INDIRF4
ASGNF4
line 351
;351:	m[1][0] = vr[1];
ADDRLP4 40+12
ADDRLP4 160+4
INDIRF4
ASGNF4
line 352
;352:	m[2][0] = vr[2];
ADDRLP4 40+24
ADDRLP4 160+8
INDIRF4
ASGNF4
line 354
;353:
;354:	m[0][1] = vup[0];
ADDRLP4 40+4
ADDRLP4 176
INDIRF4
ASGNF4
line 355
;355:	m[1][1] = vup[1];
ADDRLP4 40+12+4
ADDRLP4 176+4
INDIRF4
ASGNF4
line 356
;356:	m[2][1] = vup[2];
ADDRLP4 40+24+4
ADDRLP4 176+8
INDIRF4
ASGNF4
line 358
;357:
;358:	m[0][2] = vf[0];
ADDRLP4 40+8
ADDRLP4 148
INDIRF4
ASGNF4
line 359
;359:	m[1][2] = vf[1];
ADDRLP4 40+12+8
ADDRLP4 148+4
INDIRF4
ASGNF4
line 360
;360:	m[2][2] = vf[2];
ADDRLP4 40+24+8
ADDRLP4 148+8
INDIRF4
ASGNF4
line 362
;361:
;362:	memcpy( im, m, sizeof( im ) );
ADDRLP4 112
ARGP4
ADDRLP4 40
ARGP4
CNSTU4 36
ARGU4
ADDRGP4 memcpy
CALLP4
pop
line 364
;363:
;364:	im[0][1] = m[1][0];
ADDRLP4 112+4
ADDRLP4 40+12
INDIRF4
ASGNF4
line 365
;365:	im[0][2] = m[2][0];
ADDRLP4 112+8
ADDRLP4 40+24
INDIRF4
ASGNF4
line 366
;366:	im[1][0] = m[0][1];
ADDRLP4 112+12
ADDRLP4 40+4
INDIRF4
ASGNF4
line 367
;367:	im[1][2] = m[2][1];
ADDRLP4 112+12+8
ADDRLP4 40+24+4
INDIRF4
ASGNF4
line 368
;368:	im[2][0] = m[0][2];
ADDRLP4 112+24
ADDRLP4 40+8
INDIRF4
ASGNF4
line 369
;369:	im[2][1] = m[1][2];
ADDRLP4 112+24+4
ADDRLP4 40+12+8
INDIRF4
ASGNF4
line 371
;370:
;371:	memset( zrot, 0, sizeof( zrot ) );
ADDRLP4 76
ARGP4
CNSTI4 0
ARGI4
CNSTU4 36
ARGU4
ADDRGP4 memset
CALLP4
pop
line 372
;372:	zrot[0][0] = zrot[1][1] = zrot[2][2] = 1.0F;
ADDRLP4 224
CNSTF4 1065353216
ASGNF4
ADDRLP4 76+24+8
ADDRLP4 224
INDIRF4
ASGNF4
ADDRLP4 76+12+4
ADDRLP4 224
INDIRF4
ASGNF4
ADDRLP4 76
ADDRLP4 224
INDIRF4
ASGNF4
line 374
;373:
;374:	rad = DEG2RAD( degrees );
ADDRLP4 172
ADDRFP4 12
INDIRF4
CNSTF4 1016003125
MULF4
ASGNF4
line 375
;375:	zrot[0][0] = cos( rad );
ADDRLP4 172
INDIRF4
ARGF4
ADDRLP4 228
ADDRGP4 cos
CALLF4
ASGNF4
ADDRLP4 76
ADDRLP4 228
INDIRF4
ASGNF4
line 376
;376:	zrot[0][1] = sin( rad );
ADDRLP4 172
INDIRF4
ARGF4
ADDRLP4 232
ADDRGP4 sin
CALLF4
ASGNF4
ADDRLP4 76+4
ADDRLP4 232
INDIRF4
ASGNF4
line 377
;377:	zrot[1][0] = -sin( rad );
ADDRLP4 172
INDIRF4
ARGF4
ADDRLP4 236
ADDRGP4 sin
CALLF4
ASGNF4
ADDRLP4 76+12
ADDRLP4 236
INDIRF4
NEGF4
ASGNF4
line 378
;378:	zrot[1][1] = cos( rad );
ADDRLP4 172
INDIRF4
ARGF4
ADDRLP4 240
ADDRGP4 cos
CALLF4
ASGNF4
ADDRLP4 76+12+4
ADDRLP4 240
INDIRF4
ASGNF4
line 380
;379:
;380:	MatrixMultiply( m, zrot, tmpmat );
ADDRLP4 40
ARGP4
ADDRLP4 76
ARGP4
ADDRLP4 188
ARGP4
ADDRGP4 MatrixMultiply
CALLV
pop
line 381
;381:	MatrixMultiply( tmpmat, im, rot );
ADDRLP4 188
ARGP4
ADDRLP4 112
ARGP4
ADDRLP4 4
ARGP4
ADDRGP4 MatrixMultiply
CALLV
pop
line 383
;382:
;383:	for ( i = 0; i < 3; i++ ) {
ADDRLP4 0
CNSTI4 0
ASGNI4
LABELV $151
line 384
;384:		dst[i] = rot[i][0] * point[0] + rot[i][1] * point[1] + rot[i][2] * point[2];
ADDRLP4 248
ADDRFP4 8
INDIRP4
ASGNP4
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
ADDP4
ADDRLP4 0
INDIRI4
CNSTI4 12
MULI4
ADDRLP4 4
ADDP4
INDIRF4
ADDRLP4 248
INDIRP4
INDIRF4
MULF4
ADDRLP4 0
INDIRI4
CNSTI4 12
MULI4
ADDRLP4 4+4
ADDP4
INDIRF4
ADDRLP4 248
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
MULF4
ADDF4
ADDRLP4 0
INDIRI4
CNSTI4 12
MULI4
ADDRLP4 4+8
ADDP4
INDIRF4
ADDRLP4 248
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
MULF4
ADDF4
ASGNF4
line 385
;385:	}
LABELV $152
line 383
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 3
LTI4 $151
line 386
;386:}
LABELV $106
endproc RotatePointAroundVector 252 12
export RotateAroundDirection
proc RotateAroundDirection 20 16
line 393
;387:
;388:/*
;389:===============
;390:RotateAroundDirection
;391:===============
;392:*/
;393:void RotateAroundDirection( vec3_t axis[3], float yaw ) {
line 396
;394:
;395:	// create an arbitrary axis[1] 
;396:	PerpendicularVector( axis[1], axis[0] );
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 0
INDIRP4
CNSTI4 12
ADDP4
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 PerpendicularVector
CALLV
pop
line 399
;397:
;398:	// rotate it around axis[0] by yaw
;399:	if ( yaw ) {
ADDRFP4 4
INDIRF4
CNSTF4 0
EQF4 $158
line 402
;400:		vec3_t	temp;
;401:
;402:		VectorCopy( temp, axis[1] );
ADDRFP4 0
INDIRP4
CNSTI4 12
ADDP4
ADDRLP4 4
INDIRB
ASGNB 12
line 403
;403:		RotatePointAroundVector( axis[1], axis[0], temp, yaw );
ADDRLP4 16
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 16
INDIRP4
CNSTI4 12
ADDP4
ARGP4
ADDRLP4 16
INDIRP4
ARGP4
ADDRLP4 4
ARGP4
ADDRFP4 4
INDIRF4
ARGF4
ADDRGP4 RotatePointAroundVector
CALLV
pop
line 404
;404:	}
LABELV $158
line 407
;405:
;406:	// cross to get axis[2]
;407:	CrossProduct( axis[0], axis[1], axis[2] );
ADDRLP4 4
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 4
INDIRP4
ARGP4
ADDRLP4 4
INDIRP4
CNSTI4 12
ADDP4
ARGP4
ADDRLP4 4
INDIRP4
CNSTI4 24
ADDP4
ARGP4
ADDRGP4 CrossProduct
CALLV
pop
line 408
;408:}
LABELV $157
endproc RotateAroundDirection 20 16
export vectoangles
proc vectoangles 32 8
line 412
;409:
;410:
;411:
;412:void vectoangles( const vec3_t value1, vec3_t angles ) {
line 416
;413:	float	forward;
;414:	float	yaw, pitch;
;415:	
;416:	if ( value1[1] == 0 && value1[0] == 0 ) {
ADDRLP4 12
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 12
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
CNSTF4 0
NEF4 $161
ADDRLP4 12
INDIRP4
INDIRF4
CNSTF4 0
NEF4 $161
line 417
;417:		yaw = 0;
ADDRLP4 0
CNSTF4 0
ASGNF4
line 418
;418:		if ( value1[2] > 0 ) {
ADDRFP4 0
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
CNSTF4 0
LEF4 $163
line 419
;419:			pitch = 90;
ADDRLP4 4
CNSTF4 1119092736
ASGNF4
line 420
;420:		}
ADDRGP4 $162
JUMPV
LABELV $163
line 421
;421:		else {
line 422
;422:			pitch = 270;
ADDRLP4 4
CNSTF4 1132920832
ASGNF4
line 423
;423:		}
line 424
;424:	}
ADDRGP4 $162
JUMPV
LABELV $161
line 425
;425:	else {
line 426
;426:		if ( value1[0] ) {
ADDRFP4 0
INDIRP4
INDIRF4
CNSTF4 0
EQF4 $165
line 427
;427:			yaw = ( atan2 ( value1[1], value1[0] ) * 180 / M_PI );
ADDRLP4 16
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 16
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ARGF4
ADDRLP4 16
INDIRP4
INDIRF4
ARGF4
ADDRLP4 20
ADDRGP4 atan2
CALLF4
ASGNF4
ADDRLP4 0
ADDRLP4 20
INDIRF4
CNSTF4 1113927393
MULF4
ASGNF4
line 428
;428:		}
ADDRGP4 $166
JUMPV
LABELV $165
line 429
;429:		else if ( value1[1] > 0 ) {
ADDRFP4 0
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
CNSTF4 0
LEF4 $167
line 430
;430:			yaw = 90;
ADDRLP4 0
CNSTF4 1119092736
ASGNF4
line 431
;431:		}
ADDRGP4 $168
JUMPV
LABELV $167
line 432
;432:		else {
line 433
;433:			yaw = 270;
ADDRLP4 0
CNSTF4 1132920832
ASGNF4
line 434
;434:		}
LABELV $168
LABELV $166
line 435
;435:		if ( yaw < 0 ) {
ADDRLP4 0
INDIRF4
CNSTF4 0
GEF4 $169
line 436
;436:			yaw += 360;
ADDRLP4 0
ADDRLP4 0
INDIRF4
CNSTF4 1135869952
ADDF4
ASGNF4
line 437
;437:		}
LABELV $169
line 439
;438:
;439:		forward = sqrt ( value1[0]*value1[0] + value1[1]*value1[1] );
ADDRLP4 16
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 20
ADDRLP4 16
INDIRP4
INDIRF4
ASGNF4
ADDRLP4 20
INDIRF4
ADDRLP4 20
INDIRF4
MULF4
ADDRLP4 16
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ADDRLP4 16
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
MULF4
ADDF4
ARGF4
ADDRLP4 24
ADDRGP4 sqrt
CALLF4
ASGNF4
ADDRLP4 8
ADDRLP4 24
INDIRF4
ASGNF4
line 440
;440:		pitch = ( atan2(value1[2], forward) * 180 / M_PI );
ADDRFP4 0
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ARGF4
ADDRLP4 8
INDIRF4
ARGF4
ADDRLP4 28
ADDRGP4 atan2
CALLF4
ASGNF4
ADDRLP4 4
ADDRLP4 28
INDIRF4
CNSTF4 1113927393
MULF4
ASGNF4
line 441
;441:		if ( pitch < 0 ) {
ADDRLP4 4
INDIRF4
CNSTF4 0
GEF4 $171
line 442
;442:			pitch += 360;
ADDRLP4 4
ADDRLP4 4
INDIRF4
CNSTF4 1135869952
ADDF4
ASGNF4
line 443
;443:		}
LABELV $171
line 444
;444:	}
LABELV $162
line 446
;445:
;446:	angles[PITCH] = -pitch;
ADDRFP4 4
INDIRP4
ADDRLP4 4
INDIRF4
NEGF4
ASGNF4
line 447
;447:	angles[YAW] = yaw;
ADDRFP4 4
INDIRP4
CNSTI4 4
ADDP4
ADDRLP4 0
INDIRF4
ASGNF4
line 448
;448:	angles[ROLL] = 0;
ADDRFP4 4
INDIRP4
CNSTI4 8
ADDP4
CNSTF4 0
ASGNF4
line 449
;449:}
LABELV $160
endproc vectoangles 32 8
export AnglesToAxis
proc AnglesToAxis 16 16
line 457
;450:
;451:
;452:/*
;453:=================
;454:AnglesToAxis
;455:=================
;456:*/
;457:void AnglesToAxis( const vec3_t angles, vec3_t axis[3] ) {
line 461
;458:	vec3_t	right;
;459:
;460:	// angle vectors returns "right" instead of "y axis"
;461:	AngleVectors( angles, axis[0], right, axis[2] );
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 12
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 12
INDIRP4
ARGP4
ADDRLP4 0
ARGP4
ADDRLP4 12
INDIRP4
CNSTI4 24
ADDP4
ARGP4
ADDRGP4 AngleVectors
CALLV
pop
line 462
;462:	VectorSubtract( vec3_origin, right, axis[1] );
ADDRFP4 4
INDIRP4
CNSTI4 12
ADDP4
ADDRGP4 vec3_origin
INDIRF4
ADDRLP4 0
INDIRF4
SUBF4
ASGNF4
ADDRFP4 4
INDIRP4
CNSTI4 16
ADDP4
ADDRGP4 vec3_origin+4
INDIRF4
ADDRLP4 0+4
INDIRF4
SUBF4
ASGNF4
ADDRFP4 4
INDIRP4
CNSTI4 20
ADDP4
ADDRGP4 vec3_origin+8
INDIRF4
ADDRLP4 0+8
INDIRF4
SUBF4
ASGNF4
line 463
;463:}
LABELV $173
endproc AnglesToAxis 16 16
export AxisClear
proc AxisClear 0 0
line 465
;464:
;465:void AxisClear( vec3_t axis[3] ) {
line 466
;466:	axis[0][0] = 1;
ADDRFP4 0
INDIRP4
CNSTF4 1065353216
ASGNF4
line 467
;467:	axis[0][1] = 0;
ADDRFP4 0
INDIRP4
CNSTI4 4
ADDP4
CNSTF4 0
ASGNF4
line 468
;468:	axis[0][2] = 0;
ADDRFP4 0
INDIRP4
CNSTI4 8
ADDP4
CNSTF4 0
ASGNF4
line 469
;469:	axis[1][0] = 0;
ADDRFP4 0
INDIRP4
CNSTI4 12
ADDP4
CNSTF4 0
ASGNF4
line 470
;470:	axis[1][1] = 1;
ADDRFP4 0
INDIRP4
CNSTI4 16
ADDP4
CNSTF4 1065353216
ASGNF4
line 471
;471:	axis[1][2] = 0;
ADDRFP4 0
INDIRP4
CNSTI4 20
ADDP4
CNSTF4 0
ASGNF4
line 472
;472:	axis[2][0] = 0;
ADDRFP4 0
INDIRP4
CNSTI4 24
ADDP4
CNSTF4 0
ASGNF4
line 473
;473:	axis[2][1] = 0;
ADDRFP4 0
INDIRP4
CNSTI4 28
ADDP4
CNSTF4 0
ASGNF4
line 474
;474:	axis[2][2] = 1;
ADDRFP4 0
INDIRP4
CNSTI4 32
ADDP4
CNSTF4 1065353216
ASGNF4
line 475
;475:}
LABELV $178
endproc AxisClear 0 0
export AxisCopy
proc AxisCopy 0 0
line 477
;476:
;477:void AxisCopy( vec3_t in[3], vec3_t out[3] ) {
line 478
;478:	VectorCopy( out[0], in[0] );
ADDRFP4 0
INDIRP4
ADDRFP4 4
INDIRP4
INDIRB
ASGNB 12
line 479
;479:	VectorCopy( out[1], in[1] );
ADDRFP4 0
INDIRP4
CNSTI4 12
ADDP4
ADDRFP4 4
INDIRP4
CNSTI4 12
ADDP4
INDIRB
ASGNB 12
line 480
;480:	VectorCopy( out[2], in[2] );
ADDRFP4 0
INDIRP4
CNSTI4 24
ADDP4
ADDRFP4 4
INDIRP4
CNSTI4 24
ADDP4
INDIRB
ASGNB 12
line 481
;481:}
LABELV $179
endproc AxisCopy 0 0
export ProjectPointOnPlane
proc ProjectPointOnPlane 36 0
line 484
;482:
;483:void ProjectPointOnPlane( vec3_t dst, const vec3_t p, const vec3_t normal )
;484:{
line 489
;485:	float d;
;486:	vec3_t n;
;487:	float inv_denom;
;488:
;489:	inv_denom =  DotProduct( normal, normal );
ADDRLP4 20
ADDRFP4 8
INDIRP4
ASGNP4
ADDRLP4 24
ADDRLP4 20
INDIRP4
INDIRF4
ASGNF4
ADDRLP4 0
ADDRLP4 24
INDIRF4
ADDRLP4 24
INDIRF4
MULF4
ADDRLP4 20
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ADDRLP4 20
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
MULF4
ADDF4
ADDRLP4 20
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ADDRLP4 20
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
MULF4
ADDF4
ASGNF4
line 493
;490:#ifndef Q3_VM
;491:	assert( N_fabs(inv_denom) != 0.0f ); // zero vectors get here
;492:#endif
;493:	inv_denom = 1.0f / inv_denom;
ADDRLP4 0
CNSTF4 1065353216
ADDRLP4 0
INDIRF4
DIVF4
ASGNF4
line 495
;494:
;495:	d = DotProduct( normal, p ) * inv_denom;
ADDRLP4 28
ADDRFP4 8
INDIRP4
ASGNP4
ADDRLP4 32
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 16
ADDRLP4 28
INDIRP4
INDIRF4
ADDRLP4 32
INDIRP4
INDIRF4
MULF4
ADDRLP4 28
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ADDRLP4 32
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
MULF4
ADDF4
ADDRLP4 28
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ADDRLP4 32
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
MULF4
ADDF4
ADDRLP4 0
INDIRF4
MULF4
ASGNF4
line 497
;496:
;497:	n[0] = normal[0] * inv_denom;
ADDRLP4 4
ADDRFP4 8
INDIRP4
INDIRF4
ADDRLP4 0
INDIRF4
MULF4
ASGNF4
line 498
;498:	n[1] = normal[1] * inv_denom;
ADDRLP4 4+4
ADDRFP4 8
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ADDRLP4 0
INDIRF4
MULF4
ASGNF4
line 499
;499:	n[2] = normal[2] * inv_denom;
ADDRLP4 4+8
ADDRFP4 8
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ADDRLP4 0
INDIRF4
MULF4
ASGNF4
line 501
;500:
;501:	dst[0] = p[0] - d * n[0];
ADDRFP4 0
INDIRP4
ADDRFP4 4
INDIRP4
INDIRF4
ADDRLP4 16
INDIRF4
ADDRLP4 4
INDIRF4
MULF4
SUBF4
ASGNF4
line 502
;502:	dst[1] = p[1] - d * n[1];
ADDRFP4 0
INDIRP4
CNSTI4 4
ADDP4
ADDRFP4 4
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ADDRLP4 16
INDIRF4
ADDRLP4 4+4
INDIRF4
MULF4
SUBF4
ASGNF4
line 503
;503:	dst[2] = p[2] - d * n[2];
ADDRFP4 0
INDIRP4
CNSTI4 8
ADDP4
ADDRFP4 4
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ADDRLP4 16
INDIRF4
ADDRLP4 4+8
INDIRF4
MULF4
SUBF4
ASGNF4
line 504
;504:}
LABELV $180
endproc ProjectPointOnPlane 36 0
export MakeNormalVectors
proc MakeNormalVectors 24 12
line 514
;505:
;506:/*
;507:================
;508:MakeNormalVectors
;509:
;510:Given a normalized forward vector, create two
;511:other perpendicular vectors
;512:================
;513:*/
;514:void MakeNormalVectors( const vec3_t forward, vec3_t right, vec3_t up) {
line 519
;515:	float		d;
;516:
;517:	// this rotate and negate guarantees a vector
;518:	// not colinear with the original
;519:	right[1] = -forward[0];
ADDRFP4 4
INDIRP4
CNSTI4 4
ADDP4
ADDRFP4 0
INDIRP4
INDIRF4
NEGF4
ASGNF4
line 520
;520:	right[2] = forward[1];
ADDRFP4 4
INDIRP4
CNSTI4 8
ADDP4
ADDRFP4 0
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ASGNF4
line 521
;521:	right[0] = forward[2];
ADDRFP4 4
INDIRP4
ADDRFP4 0
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ASGNF4
line 523
;522:
;523:	d = DotProduct (right, forward);
ADDRLP4 4
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 8
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 4
INDIRP4
INDIRF4
ADDRLP4 8
INDIRP4
INDIRF4
MULF4
ADDRLP4 4
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ADDRLP4 8
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
MULF4
ADDF4
ADDRLP4 4
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ADDRLP4 8
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
MULF4
ADDF4
ASGNF4
line 524
;524:	VectorMA (right, -d, forward, right);
ADDRLP4 12
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 12
INDIRP4
ADDRLP4 12
INDIRP4
INDIRF4
ADDRFP4 0
INDIRP4
INDIRF4
ADDRLP4 0
INDIRF4
NEGF4
MULF4
ADDF4
ASGNF4
ADDRLP4 16
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 16
INDIRP4
CNSTI4 4
ADDP4
ADDRLP4 16
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ADDRFP4 0
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ADDRLP4 0
INDIRF4
NEGF4
MULF4
ADDF4
ASGNF4
ADDRLP4 20
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 20
INDIRP4
CNSTI4 8
ADDP4
ADDRLP4 20
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ADDRFP4 0
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ADDRLP4 0
INDIRF4
NEGF4
MULF4
ADDF4
ASGNF4
line 525
;525:	VectorNormalize (right);
ADDRFP4 4
INDIRP4
ARGP4
ADDRGP4 VectorNormalize
CALLF4
pop
line 526
;526:	CrossProduct (right, forward, up);
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 8
INDIRP4
ARGP4
ADDRGP4 CrossProduct
CALLV
pop
line 527
;527:}
LABELV $185
endproc MakeNormalVectors 24 12
export VectorRotate
proc VectorRotate 24 0
line 531
;528:
;529:
;530:void VectorRotate( const vec3_t in, const vec3_t matrix[3], vec3_t out )
;531:{
line 532
;532:	out[0] = DotProduct( in, matrix[0] );
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 4
ADDRFP4 4
INDIRP4
ASGNP4
ADDRFP4 8
INDIRP4
ADDRLP4 0
INDIRP4
INDIRF4
ADDRLP4 4
INDIRP4
INDIRF4
MULF4
ADDRLP4 0
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ADDRLP4 4
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
MULF4
ADDF4
ADDRLP4 0
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ADDRLP4 4
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
MULF4
ADDF4
ASGNF4
line 533
;533:	out[1] = DotProduct( in, matrix[1] );
ADDRLP4 8
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 12
ADDRFP4 4
INDIRP4
ASGNP4
ADDRFP4 8
INDIRP4
CNSTI4 4
ADDP4
ADDRLP4 8
INDIRP4
INDIRF4
ADDRLP4 12
INDIRP4
CNSTI4 12
ADDP4
INDIRF4
MULF4
ADDRLP4 8
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ADDRLP4 12
INDIRP4
CNSTI4 16
ADDP4
INDIRF4
MULF4
ADDF4
ADDRLP4 8
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ADDRLP4 12
INDIRP4
CNSTI4 20
ADDP4
INDIRF4
MULF4
ADDF4
ASGNF4
line 534
;534:	out[2] = DotProduct( in, matrix[2] );
ADDRLP4 16
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 20
ADDRFP4 4
INDIRP4
ASGNP4
ADDRFP4 8
INDIRP4
CNSTI4 8
ADDP4
ADDRLP4 16
INDIRP4
INDIRF4
ADDRLP4 20
INDIRP4
CNSTI4 24
ADDP4
INDIRF4
MULF4
ADDRLP4 16
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ADDRLP4 20
INDIRP4
CNSTI4 28
ADDP4
INDIRF4
MULF4
ADDF4
ADDRLP4 16
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ADDRLP4 20
INDIRP4
CNSTI4 32
ADDP4
INDIRF4
MULF4
ADDF4
ASGNF4
line 535
;535:}
LABELV $186
endproc VectorRotate 24 0
export Q_root
proc Q_root 24 0
line 539
;536:
;537:
;538:float Q_root(float x)
;539:{
line 541
;540:	long        i;								// The integer interpretation of x
;541:	float       x_half = x * 0.5f;
ADDRLP4 8
ADDRFP4 0
INDIRF4
CNSTF4 1056964608
MULF4
ASGNF4
line 542
;542:	float       r_sqrt = x;
ADDRLP4 0
ADDRFP4 0
INDIRF4
ASGNF4
line 543
;543:	const float threehalfs = 1.5F;
ADDRLP4 12
CNSTF4 1069547520
ASGNF4
line 546
;544:
;545:	// trick c/c++, bit hack
;546:	i = *(long *)&r_sqrt;					    // oh yes, undefined behaviour, who gives a fuck?
ADDRLP4 4
ADDRLP4 0
INDIRI4
ASGNI4
line 547
;547:	i = 0x5f375a86 - (i >> 1);				    // weird magic base-16 nums
ADDRLP4 4
CNSTI4 1597463174
ADDRLP4 4
INDIRI4
CNSTI4 1
RSHI4
SUBI4
ASGNI4
line 548
;548:	r_sqrt = *(float *) &i;
ADDRLP4 0
ADDRLP4 4
INDIRF4
ASGNF4
line 550
;549:
;550:	r_sqrt = r_sqrt * (threehalfs - (x_half * r_sqrt * r_sqrt)); // 1st Newton iteration
ADDRLP4 16
ADDRLP4 0
INDIRF4
ASGNF4
ADDRLP4 0
ADDRLP4 16
INDIRF4
ADDRLP4 12
INDIRF4
ADDRLP4 8
INDIRF4
ADDRLP4 16
INDIRF4
MULF4
ADDRLP4 16
INDIRF4
MULF4
SUBF4
MULF4
ASGNF4
line 551
;551:	r_sqrt = r_sqrt * (threehalfs - (x_half * r_sqrt * r_sqrt)); // 2nd Newton iteration
ADDRLP4 20
ADDRLP4 0
INDIRF4
ASGNF4
ADDRLP4 0
ADDRLP4 20
INDIRF4
ADDRLP4 12
INDIRF4
ADDRLP4 8
INDIRF4
ADDRLP4 20
INDIRF4
MULF4
ADDRLP4 20
INDIRF4
MULF4
SUBF4
MULF4
ASGNF4
line 553
;552:
;553:	return x * r_sqrt; // x * (1/sqrt(x)) := sqrt(x)
ADDRFP4 0
INDIRF4
ADDRLP4 0
INDIRF4
MULF4
RETF4
LABELV $187
endproc Q_root 24 0
export Q_rsqrt
proc Q_rsqrt 20 0
line 557
;554:}
;555:
;556:float Q_rsqrt(float number)
;557:{
line 581
;558:#ifdef USING_SSE2
;559:	// does this cpu actually support sse2?
;560:	if (!(CPU_flags & CPU_SSE2)) {
;561:		long x;
;562:    	float x2, y;
;563:		const float threehalfs = 1.5F;
;564:
;565:    	x2 = number * 0.5F;
;566:    	x = *(long *)&number;                    // evil floating point bit level hacking
;567:    	x = 0x5f3759df - (x >> 1);               // what the fuck?
;568:    	y = *(float *)&x;
;569:    	y = y * ( threehalfs - ( x2 * y * y ) ); // 1st iteration
;570:  	//	y = y * ( threehalfs - ( x2 * y * y ) ); // 2nd iteration, this can be removed
;571:
;572:    	return y;
;573:	}
;574:
;575:	float ret;
;576:	_mm_store_ss( &ret, _mm_rsqrt_ss( _mm_load_ss( &number ) ) );
;577:	return ret;
;578:#else
;579:    long x;
;580:    float x2, y;
;581:	const float threehalfs = 1.5F;
ADDRLP4 12
CNSTF4 1069547520
ASGNF4
line 583
;582:
;583:    x2 = number * 0.5F;
ADDRLP4 8
ADDRFP4 0
INDIRF4
CNSTF4 1056964608
MULF4
ASGNF4
line 584
;584:    x = *(long *)&number;                    // evil floating point bit level hacking
ADDRLP4 4
ADDRFP4 0
INDIRI4
ASGNI4
line 585
;585:    x = 0x5f3759df - (x >> 1);               // what the fuck?
ADDRLP4 4
CNSTI4 1597463007
ADDRLP4 4
INDIRI4
CNSTI4 1
RSHI4
SUBI4
ASGNI4
line 586
;586:    y = *(float *)&x;
ADDRLP4 0
ADDRLP4 4
INDIRF4
ASGNF4
line 587
;587:    y = y * ( threehalfs - ( x2 * y * y ) ); // 1st iteration
ADDRLP4 0
ADDRLP4 0
INDIRF4
ADDRLP4 12
INDIRF4
ADDRLP4 8
INDIRF4
ADDRLP4 0
INDIRF4
MULF4
ADDRLP4 0
INDIRF4
MULF4
SUBF4
MULF4
ASGNF4
line 590
;588://  y = y * ( threehalfs - ( x2 * y * y ) ); // 2nd iteration, this can be removed
;589:
;590:    return y;
ADDRLP4 0
INDIRF4
RETF4
LABELV $188
endproc Q_rsqrt 20 0
export disBetweenOBJ
proc disBetweenOBJ 20 8
line 594
;591:#endif
;592:}
;593:float disBetweenOBJ(const vec3_t src, const vec3_t tar)
;594:{
line 595
;595:	if (src[1] == tar[1]) // horizontal
ADDRFP4 0
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ADDRFP4 4
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
NEF4 $190
line 596
;596:		return src[0] > tar[0] ? (src[0] - tar[0]) : (tar[0] - src[0]);
ADDRFP4 0
INDIRP4
INDIRF4
ADDRFP4 4
INDIRP4
INDIRF4
LEF4 $193
ADDRLP4 0
ADDRFP4 0
INDIRP4
INDIRF4
ADDRFP4 4
INDIRP4
INDIRF4
SUBF4
ASGNF4
ADDRGP4 $194
JUMPV
LABELV $193
ADDRLP4 0
ADDRFP4 4
INDIRP4
INDIRF4
ADDRFP4 0
INDIRP4
INDIRF4
SUBF4
ASGNF4
LABELV $194
ADDRLP4 0
INDIRF4
RETF4
ADDRGP4 $189
JUMPV
LABELV $190
line 597
;597:	else if (src[0] == tar[0]) // vertical
ADDRFP4 0
INDIRP4
INDIRF4
ADDRFP4 4
INDIRP4
INDIRF4
NEF4 $195
line 598
;598:		return src[1] > tar[1] ? (src[1] - tar[1]) : (tar[1] - src[1]);
ADDRFP4 0
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ADDRFP4 4
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
LEF4 $198
ADDRLP4 4
ADDRFP4 0
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ADDRFP4 4
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
SUBF4
ASGNF4
ADDRGP4 $199
JUMPV
LABELV $198
ADDRLP4 4
ADDRFP4 4
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ADDRFP4 0
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
SUBF4
ASGNF4
LABELV $199
ADDRLP4 4
INDIRF4
RETF4
ADDRGP4 $189
JUMPV
LABELV $195
line 600
;599:	else // diagonal
;600:		return Q_root((pow((src[0] - tar[0]), 2) + pow((src[1] - tar[1]), 2)));
ADDRFP4 0
INDIRP4
INDIRF4
ADDRFP4 4
INDIRP4
INDIRF4
SUBF4
ARGF4
CNSTI4 2
ARGI4
ADDRLP4 8
ADDRGP4 pow
CALLI4
ASGNI4
ADDRFP4 0
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ADDRFP4 4
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
SUBF4
ARGF4
CNSTI4 2
ARGI4
ADDRLP4 12
ADDRGP4 pow
CALLI4
ASGNI4
ADDRLP4 8
INDIRI4
ADDRLP4 12
INDIRI4
ADDI4
CVIF4 4
ARGF4
ADDRLP4 16
ADDRGP4 Q_root
CALLF4
ASGNF4
ADDRLP4 16
INDIRF4
RETF4
LABELV $189
endproc disBetweenOBJ 20 8
export CrossProduct
proc CrossProduct 24 0
line 605
;601:}
;602:
;603:#if defined(Q3_VM) && !defined(__Q3_VM_MATH)
;604:void CrossProduct(const vec3_t v1, const vec3_t v2, vec3_t cross)
;605:{
line 606
;606:	cross[0] = v1[1]*v2[2] - v1[2]*v2[1];
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 4
ADDRFP4 4
INDIRP4
ASGNP4
ADDRFP4 8
INDIRP4
ADDRLP4 0
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ADDRLP4 4
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
MULF4
ADDRLP4 0
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ADDRLP4 4
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
MULF4
SUBF4
ASGNF4
line 607
;607:	cross[1] = v1[2]*v2[0] - v1[0]*v2[2];
ADDRLP4 8
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 12
ADDRFP4 4
INDIRP4
ASGNP4
ADDRFP4 8
INDIRP4
CNSTI4 4
ADDP4
ADDRLP4 8
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ADDRLP4 12
INDIRP4
INDIRF4
MULF4
ADDRLP4 8
INDIRP4
INDIRF4
ADDRLP4 12
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
MULF4
SUBF4
ASGNF4
line 608
;608:	cross[2] = v1[0]*v2[1] - v1[1]*v2[0];
ADDRLP4 16
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 20
ADDRFP4 4
INDIRP4
ASGNP4
ADDRFP4 8
INDIRP4
CNSTI4 8
ADDP4
ADDRLP4 16
INDIRP4
INDIRF4
ADDRLP4 20
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
MULF4
ADDRLP4 16
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ADDRLP4 20
INDIRP4
INDIRF4
MULF4
SUBF4
ASGNF4
line 609
;609:}
LABELV $200
endproc CrossProduct 24 0
export VectorLength
proc VectorLength 12 4
line 611
;610:
;611:vec_t VectorLength(const vec3_t v) {
line 612
;612:	return (vec_t)sqrtf (v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 4
ADDRLP4 0
INDIRP4
INDIRF4
ASGNF4
ADDRLP4 4
INDIRF4
ADDRLP4 4
INDIRF4
MULF4
ADDRLP4 0
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ADDRLP4 0
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
MULF4
ADDF4
ADDRLP4 0
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ADDRLP4 0
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
MULF4
ADDF4
ARGF4
ADDRLP4 8
ADDRGP4 sqrtf
CALLI4
ASGNI4
ADDRLP4 8
INDIRI4
CVIF4 4
RETF4
LABELV $201
endproc VectorLength 12 4
export RadiusFromBounds
proc RadiusFromBounds 36 4
line 621
;613:}
;614:#endif
;615:
;616:/*
;617:=================
;618:RadiusFromBounds
;619:=================
;620:*/
;621:float RadiusFromBounds( const vec3_t mins, const vec3_t maxs ) {
line 626
;622:	int		i;
;623:	vec3_t	corner;
;624:	float	a, b;
;625:
;626:	for (i=0 ; i<3 ; i++) {
ADDRLP4 0
CNSTI4 0
ASGNI4
LABELV $203
line 627
;627:		a = fabs( mins[i] );
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRF4
ARGF4
ADDRLP4 24
ADDRGP4 fabs
CALLF4
ASGNF4
ADDRLP4 4
ADDRLP4 24
INDIRF4
ASGNF4
line 628
;628:		b = fabs( maxs[i] );
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 4
INDIRP4
ADDP4
INDIRF4
ARGF4
ADDRLP4 28
ADDRGP4 fabs
CALLF4
ASGNF4
ADDRLP4 8
ADDRLP4 28
INDIRF4
ASGNF4
line 629
;629:		corner[i] = a > b ? a : b;
ADDRLP4 4
INDIRF4
ADDRLP4 8
INDIRF4
LEF4 $208
ADDRLP4 32
ADDRLP4 4
INDIRF4
ASGNF4
ADDRGP4 $209
JUMPV
LABELV $208
ADDRLP4 32
ADDRLP4 8
INDIRF4
ASGNF4
LABELV $209
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRLP4 12
ADDP4
ADDRLP4 32
INDIRF4
ASGNF4
line 630
;630:	}
LABELV $204
line 626
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 3
LTI4 $203
line 632
;631:
;632:	return VectorLength (corner);
ADDRLP4 12
ARGP4
ADDRLP4 24
ADDRGP4 VectorLength
CALLF4
ASGNF4
ADDRLP4 24
INDIRF4
RETF4
LABELV $202
endproc RadiusFromBounds 36 4
export VectorCompare
proc VectorCompare 8 0
line 636
;633:}
;634:
;635:#if defined( Q3_VM ) || defined( __Q3_VM_MATH )
;636:int VectorCompare( const vec3_t a, const vec3_t b ) {
line 637
;637:	if ( a[0] != b[0] || a[1] != b[1] || a[2] != b[2] ) {
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 4
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 0
INDIRP4
INDIRF4
ADDRLP4 4
INDIRP4
INDIRF4
NEF4 $214
ADDRLP4 0
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ADDRLP4 4
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
NEF4 $214
ADDRLP4 0
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ADDRLP4 4
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
EQF4 $211
LABELV $214
line 638
;638:		return 0;
CNSTI4 0
RETI4
ADDRGP4 $210
JUMPV
LABELV $211
line 640
;639:	}
;640:	return 1;
CNSTI4 1
RETI4
LABELV $210
endproc VectorCompare 8 0
export ClearBounds
proc ClearBounds 16 0
line 644
;641:}
;642:#endif
;643:
;644:void ClearBounds( vec3_t mins, vec3_t maxs ) {
line 645
;645:	mins[0] = mins[1] = mins[2] = 99999;
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 4
CNSTF4 1203982208
ASGNF4
ADDRLP4 0
INDIRP4
CNSTI4 8
ADDP4
ADDRLP4 4
INDIRF4
ASGNF4
ADDRLP4 0
INDIRP4
CNSTI4 4
ADDP4
ADDRLP4 4
INDIRF4
ASGNF4
ADDRLP4 0
INDIRP4
ADDRLP4 4
INDIRF4
ASGNF4
line 646
;646:	maxs[0] = maxs[1] = maxs[2] = -99999;
ADDRLP4 8
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 12
CNSTF4 3351465856
ASGNF4
ADDRLP4 8
INDIRP4
CNSTI4 8
ADDP4
ADDRLP4 12
INDIRF4
ASGNF4
ADDRLP4 8
INDIRP4
CNSTI4 4
ADDP4
ADDRLP4 12
INDIRF4
ASGNF4
ADDRLP4 8
INDIRP4
ADDRLP4 12
INDIRF4
ASGNF4
line 647
;647:}
LABELV $215
endproc ClearBounds 16 0
export AddPointToBounds
proc AddPointToBounds 0 0
line 649
;648:
;649:void AddPointToBounds( const vec3_t v, vec3_t mins, vec3_t maxs ) {
line 650
;650:	if ( v[0] < mins[0] ) {
ADDRFP4 0
INDIRP4
INDIRF4
ADDRFP4 4
INDIRP4
INDIRF4
GEF4 $217
line 651
;651:		mins[0] = v[0];
ADDRFP4 4
INDIRP4
ADDRFP4 0
INDIRP4
INDIRF4
ASGNF4
line 652
;652:	}
LABELV $217
line 653
;653:	if ( v[0] > maxs[0]) {
ADDRFP4 0
INDIRP4
INDIRF4
ADDRFP4 8
INDIRP4
INDIRF4
LEF4 $219
line 654
;654:		maxs[0] = v[0];
ADDRFP4 8
INDIRP4
ADDRFP4 0
INDIRP4
INDIRF4
ASGNF4
line 655
;655:	}
LABELV $219
line 657
;656:
;657:	if ( v[1] < mins[1] ) {
ADDRFP4 0
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ADDRFP4 4
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
GEF4 $221
line 658
;658:		mins[1] = v[1];
ADDRFP4 4
INDIRP4
CNSTI4 4
ADDP4
ADDRFP4 0
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ASGNF4
line 659
;659:	}
LABELV $221
line 660
;660:	if ( v[1] > maxs[1]) {
ADDRFP4 0
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ADDRFP4 8
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
LEF4 $223
line 661
;661:		maxs[1] = v[1];
ADDRFP4 8
INDIRP4
CNSTI4 4
ADDP4
ADDRFP4 0
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ASGNF4
line 662
;662:	}
LABELV $223
line 664
;663:
;664:	if ( v[2] < mins[2] ) {
ADDRFP4 0
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ADDRFP4 4
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
GEF4 $225
line 665
;665:		mins[2] = v[2];
ADDRFP4 4
INDIRP4
CNSTI4 8
ADDP4
ADDRFP4 0
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ASGNF4
line 666
;666:	}
LABELV $225
line 667
;667:	if ( v[2] > maxs[2]) {
ADDRFP4 0
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ADDRFP4 8
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
LEF4 $227
line 668
;668:		maxs[2] = v[2];
ADDRFP4 8
INDIRP4
CNSTI4 8
ADDP4
ADDRFP4 0
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ASGNF4
line 669
;669:	}
LABELV $227
line 670
;670:}
LABELV $216
endproc AddPointToBounds 0 0
export BoundsIntersect
proc BoundsIntersect 16 0
line 674
;671:
;672:qboolean BoundsIntersect(const vec3_t mins, const vec3_t maxs,
;673:		const vec3_t mins2, const vec3_t maxs2)
;674:{
line 675
;675:	if ( maxs[0] < mins2[0] ||
ADDRLP4 0
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 4
ADDRFP4 8
INDIRP4
ASGNP4
ADDRLP4 0
INDIRP4
INDIRF4
ADDRLP4 4
INDIRP4
INDIRF4
LTF4 $236
ADDRLP4 0
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ADDRLP4 4
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
LTF4 $236
ADDRLP4 0
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ADDRLP4 4
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
LTF4 $236
ADDRLP4 8
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 12
ADDRFP4 12
INDIRP4
ASGNP4
ADDRLP4 8
INDIRP4
INDIRF4
ADDRLP4 12
INDIRP4
INDIRF4
GTF4 $236
ADDRLP4 8
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ADDRLP4 12
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
GTF4 $236
ADDRLP4 8
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ADDRLP4 12
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
LEF4 $230
LABELV $236
line 681
;676:		maxs[1] < mins2[1] ||
;677:		maxs[2] < mins2[2] ||
;678:		mins[0] > maxs2[0] ||
;679:		mins[1] > maxs2[1] ||
;680:		mins[2] > maxs2[2])
;681:	{
line 682
;682:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $229
JUMPV
LABELV $230
line 685
;683:	}
;684:
;685:	return qtrue;
CNSTI4 1
RETI4
LABELV $229
endproc BoundsIntersect 16 0
export BoundsIntersectSphere
proc BoundsIntersectSphere 20 0
line 690
;686:}
;687:
;688:qboolean BoundsIntersectSphere(const vec3_t mins, const vec3_t maxs,
;689:		const vec3_t origin, vec_t radius)
;690:{
line 691
;691:	if ( origin[0] - radius > maxs[0] ||
ADDRLP4 0
ADDRFP4 8
INDIRP4
ASGNP4
ADDRLP4 4
ADDRLP4 0
INDIRP4
INDIRF4
ASGNF4
ADDRLP4 8
ADDRFP4 12
INDIRF4
ASGNF4
ADDRLP4 12
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 4
INDIRF4
ADDRLP4 8
INDIRF4
SUBF4
ADDRLP4 12
INDIRP4
INDIRF4
GTF4 $244
ADDRLP4 16
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 4
INDIRF4
ADDRLP4 8
INDIRF4
ADDF4
ADDRLP4 16
INDIRP4
INDIRF4
LTF4 $244
ADDRLP4 0
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ADDRLP4 8
INDIRF4
SUBF4
ADDRLP4 12
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
GTF4 $244
ADDRLP4 0
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ADDRLP4 8
INDIRF4
ADDF4
ADDRLP4 16
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
LTF4 $244
ADDRLP4 0
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ADDRLP4 8
INDIRF4
SUBF4
ADDRLP4 12
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
GTF4 $244
ADDRLP4 0
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ADDRLP4 8
INDIRF4
ADDF4
ADDRLP4 16
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
GEF4 $238
LABELV $244
line 697
;692:		origin[0] + radius < mins[0] ||
;693:		origin[1] - radius > maxs[1] ||
;694:		origin[1] + radius < mins[1] ||
;695:		origin[2] - radius > maxs[2] ||
;696:		origin[2] + radius < mins[2])
;697:	{
line 698
;698:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $237
JUMPV
LABELV $238
line 701
;699:	}
;700:
;701:	return qtrue;
CNSTI4 1
RETI4
LABELV $237
endproc BoundsIntersectSphere 20 0
export BoundsIntersectPoint
proc BoundsIntersectPoint 16 0
line 706
;702:}
;703:
;704:qboolean BoundsIntersectPoint(const vec3_t mins, const vec3_t maxs,
;705:		const vec3_t origin)
;706:{
line 707
;707:	if ( origin[0] > maxs[0] ||
ADDRLP4 0
ADDRFP4 8
INDIRP4
ASGNP4
ADDRLP4 4
ADDRLP4 0
INDIRP4
INDIRF4
ASGNF4
ADDRLP4 8
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 4
INDIRF4
ADDRLP4 8
INDIRP4
INDIRF4
GTF4 $252
ADDRLP4 12
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 4
INDIRF4
ADDRLP4 12
INDIRP4
INDIRF4
LTF4 $252
ADDRLP4 0
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ADDRLP4 8
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
GTF4 $252
ADDRLP4 0
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ADDRLP4 12
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
LTF4 $252
ADDRLP4 0
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ADDRLP4 8
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
GTF4 $252
ADDRLP4 0
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ADDRLP4 12
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
GEF4 $246
LABELV $252
line 713
;708:		origin[0] < mins[0] ||
;709:		origin[1] > maxs[1] ||
;710:		origin[1] < mins[1] ||
;711:		origin[2] > maxs[2] ||
;712:		origin[2] < mins[2])
;713:	{
line 714
;714:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $245
JUMPV
LABELV $246
line 717
;715:	}
;716:
;717:	return qtrue;
CNSTI4 1
RETI4
LABELV $245
endproc BoundsIntersectPoint 16 0
export VectorNormalize
proc VectorNormalize 32 4
line 720
;718:}
;719:
;720:vec_t VectorNormalize( vec3_t v ) {
line 724
;721:	// NOTE: TTimo - Apple G4 altivec source uses double?
;722:	float	length, ilength;
;723:
;724:	length = v[0]*v[0] + v[1]*v[1] + v[2]*v[2];
ADDRLP4 8
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 12
ADDRLP4 8
INDIRP4
INDIRF4
ASGNF4
ADDRLP4 0
ADDRLP4 12
INDIRF4
ADDRLP4 12
INDIRF4
MULF4
ADDRLP4 8
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ADDRLP4 8
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
MULF4
ADDF4
ADDRLP4 8
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ADDRLP4 8
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
MULF4
ADDF4
ASGNF4
line 726
;725:
;726:	if ( length ) {
ADDRLP4 0
INDIRF4
CNSTF4 0
EQF4 $254
line 728
;727:		/* writing it this way allows gcc to recognize that rsqrt can be used */
;728:		ilength = 1/(float)sqrt (length);
ADDRLP4 0
INDIRF4
ARGF4
ADDRLP4 16
ADDRGP4 sqrt
CALLF4
ASGNF4
ADDRLP4 4
CNSTF4 1065353216
ADDRLP4 16
INDIRF4
DIVF4
ASGNF4
line 730
;729:		/* sqrt(length) = length * (1 / sqrt(length)) */
;730:		length *= ilength;
ADDRLP4 0
ADDRLP4 0
INDIRF4
ADDRLP4 4
INDIRF4
MULF4
ASGNF4
line 731
;731:		v[0] *= ilength;
ADDRLP4 20
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 20
INDIRP4
ADDRLP4 20
INDIRP4
INDIRF4
ADDRLP4 4
INDIRF4
MULF4
ASGNF4
line 732
;732:		v[1] *= ilength;
ADDRLP4 24
ADDRFP4 0
INDIRP4
CNSTI4 4
ADDP4
ASGNP4
ADDRLP4 24
INDIRP4
ADDRLP4 24
INDIRP4
INDIRF4
ADDRLP4 4
INDIRF4
MULF4
ASGNF4
line 733
;733:		v[2] *= ilength;
ADDRLP4 28
ADDRFP4 0
INDIRP4
CNSTI4 8
ADDP4
ASGNP4
ADDRLP4 28
INDIRP4
ADDRLP4 28
INDIRP4
INDIRF4
ADDRLP4 4
INDIRF4
MULF4
ASGNF4
line 734
;734:	}
LABELV $254
line 736
;735:		
;736:	return length;
ADDRLP4 0
INDIRF4
RETF4
LABELV $253
endproc VectorNormalize 32 4
export VectorNormalize2
proc VectorNormalize2 24 4
line 739
;737:}
;738:
;739:vec_t VectorNormalize2( const vec3_t v, vec3_t out) {
line 742
;740:	float	length, ilength;
;741:
;742:	length = v[0]*v[0] + v[1]*v[1] + v[2]*v[2];
ADDRLP4 8
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 12
ADDRLP4 8
INDIRP4
INDIRF4
ASGNF4
ADDRLP4 0
ADDRLP4 12
INDIRF4
ADDRLP4 12
INDIRF4
MULF4
ADDRLP4 8
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ADDRLP4 8
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
MULF4
ADDF4
ADDRLP4 8
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ADDRLP4 8
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
MULF4
ADDF4
ASGNF4
line 744
;743:
;744:	if (length)
ADDRLP4 0
INDIRF4
CNSTF4 0
EQF4 $257
line 745
;745:	{
line 747
;746:		/* writing it this way allows gcc to recognize that rsqrt can be used */
;747:		ilength = 1/(float)sqrt (length);
ADDRLP4 0
INDIRF4
ARGF4
ADDRLP4 16
ADDRGP4 sqrt
CALLF4
ASGNF4
ADDRLP4 4
CNSTF4 1065353216
ADDRLP4 16
INDIRF4
DIVF4
ASGNF4
line 749
;748:		/* sqrt(length) = length * (1 / sqrt(length)) */
;749:		length *= ilength;
ADDRLP4 0
ADDRLP4 0
INDIRF4
ADDRLP4 4
INDIRF4
MULF4
ASGNF4
line 750
;750:		out[0] = v[0]*ilength;
ADDRFP4 4
INDIRP4
ADDRFP4 0
INDIRP4
INDIRF4
ADDRLP4 4
INDIRF4
MULF4
ASGNF4
line 751
;751:		out[1] = v[1]*ilength;
ADDRFP4 4
INDIRP4
CNSTI4 4
ADDP4
ADDRFP4 0
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ADDRLP4 4
INDIRF4
MULF4
ASGNF4
line 752
;752:		out[2] = v[2]*ilength;
ADDRFP4 4
INDIRP4
CNSTI4 8
ADDP4
ADDRFP4 0
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ADDRLP4 4
INDIRF4
MULF4
ASGNF4
line 753
;753:	} else {
ADDRGP4 $258
JUMPV
LABELV $257
line 754
;754:		VectorClear( out );
ADDRLP4 16
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 20
CNSTF4 0
ASGNF4
ADDRLP4 16
INDIRP4
CNSTI4 8
ADDP4
ADDRLP4 20
INDIRF4
ASGNF4
ADDRLP4 16
INDIRP4
CNSTI4 4
ADDP4
ADDRLP4 20
INDIRF4
ASGNF4
ADDRLP4 16
INDIRP4
ADDRLP4 20
INDIRF4
ASGNF4
line 755
;755:	}
LABELV $258
line 757
;756:		
;757:	return length;
ADDRLP4 0
INDIRF4
RETF4
LABELV $256
endproc VectorNormalize2 24 4
export _VectorMA
proc _VectorMA 0 0
line 761
;758:
;759:}
;760:
;761:void _VectorMA( const vec3_t veca, float scale, const vec3_t vecb, vec3_t vecc) {
line 762
;762:	vecc[0] = veca[0] + scale*vecb[0];
ADDRFP4 12
INDIRP4
ADDRFP4 0
INDIRP4
INDIRF4
ADDRFP4 4
INDIRF4
ADDRFP4 8
INDIRP4
INDIRF4
MULF4
ADDF4
ASGNF4
line 763
;763:	vecc[1] = veca[1] + scale*vecb[1];
ADDRFP4 12
INDIRP4
CNSTI4 4
ADDP4
ADDRFP4 0
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ADDRFP4 4
INDIRF4
ADDRFP4 8
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
MULF4
ADDF4
ASGNF4
line 764
;764:	vecc[2] = veca[2] + scale*vecb[2];
ADDRFP4 12
INDIRP4
CNSTI4 8
ADDP4
ADDRFP4 0
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ADDRFP4 4
INDIRF4
ADDRFP4 8
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
MULF4
ADDF4
ASGNF4
line 765
;765:}
LABELV $259
endproc _VectorMA 0 0
export _DotProduct
proc _DotProduct 8 0
line 768
;766:
;767:
;768:vec_t _DotProduct( const vec3_t v1, const vec3_t v2 ) {
line 769
;769:	return v1[0]*v2[0] + v1[1]*v2[1] + v1[2]*v2[2];
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 4
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 0
INDIRP4
INDIRF4
ADDRLP4 4
INDIRP4
INDIRF4
MULF4
ADDRLP4 0
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ADDRLP4 4
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
MULF4
ADDF4
ADDRLP4 0
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ADDRLP4 4
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
MULF4
ADDF4
RETF4
LABELV $260
endproc _DotProduct 8 0
export _VectorSubtract
proc _VectorSubtract 0 0
line 772
;770:}
;771:
;772:void _VectorSubtract( const vec3_t veca, const vec3_t vecb, vec3_t out ) {
line 773
;773:	out[0] = veca[0]-vecb[0];
ADDRFP4 8
INDIRP4
ADDRFP4 0
INDIRP4
INDIRF4
ADDRFP4 4
INDIRP4
INDIRF4
SUBF4
ASGNF4
line 774
;774:	out[1] = veca[1]-vecb[1];
ADDRFP4 8
INDIRP4
CNSTI4 4
ADDP4
ADDRFP4 0
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ADDRFP4 4
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
SUBF4
ASGNF4
line 775
;775:	out[2] = veca[2]-vecb[2];
ADDRFP4 8
INDIRP4
CNSTI4 8
ADDP4
ADDRFP4 0
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ADDRFP4 4
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
SUBF4
ASGNF4
line 776
;776:}
LABELV $261
endproc _VectorSubtract 0 0
export _VectorAdd
proc _VectorAdd 0 0
line 778
;777:
;778:void _VectorAdd( const vec3_t veca, const vec3_t vecb, vec3_t out ) {
line 779
;779:	out[0] = veca[0]+vecb[0];
ADDRFP4 8
INDIRP4
ADDRFP4 0
INDIRP4
INDIRF4
ADDRFP4 4
INDIRP4
INDIRF4
ADDF4
ASGNF4
line 780
;780:	out[1] = veca[1]+vecb[1];
ADDRFP4 8
INDIRP4
CNSTI4 4
ADDP4
ADDRFP4 0
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ADDRFP4 4
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ADDF4
ASGNF4
line 781
;781:	out[2] = veca[2]+vecb[2];
ADDRFP4 8
INDIRP4
CNSTI4 8
ADDP4
ADDRFP4 0
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ADDRFP4 4
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ADDF4
ASGNF4
line 782
;782:}
LABELV $262
endproc _VectorAdd 0 0
export _VectorCopy
proc _VectorCopy 0 0
line 784
;783:
;784:void _VectorCopy( const vec3_t in, vec3_t out ) {
line 785
;785:	out[0] = in[0];
ADDRFP4 4
INDIRP4
ADDRFP4 0
INDIRP4
INDIRF4
ASGNF4
line 786
;786:	out[1] = in[1];
ADDRFP4 4
INDIRP4
CNSTI4 4
ADDP4
ADDRFP4 0
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ASGNF4
line 787
;787:	out[2] = in[2];
ADDRFP4 4
INDIRP4
CNSTI4 8
ADDP4
ADDRFP4 0
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ASGNF4
line 788
;788:}
LABELV $263
endproc _VectorCopy 0 0
export _VectorScale
proc _VectorScale 0 0
line 790
;789:
;790:void _VectorScale( const vec3_t in, vec_t scale, vec3_t out ) {
line 791
;791:	out[0] = in[0]*scale;
ADDRFP4 8
INDIRP4
ADDRFP4 0
INDIRP4
INDIRF4
ADDRFP4 4
INDIRF4
MULF4
ASGNF4
line 792
;792:	out[1] = in[1]*scale;
ADDRFP4 8
INDIRP4
CNSTI4 4
ADDP4
ADDRFP4 0
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ADDRFP4 4
INDIRF4
MULF4
ASGNF4
line 793
;793:	out[2] = in[2]*scale;
ADDRFP4 8
INDIRP4
CNSTI4 8
ADDP4
ADDRFP4 0
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ADDRFP4 4
INDIRF4
MULF4
ASGNF4
line 794
;794:}
LABELV $264
endproc _VectorScale 0 0
export Vector4Scale
proc Vector4Scale 0 0
line 796
;795:
;796:void Vector4Scale( const vec4_t in, vec_t scale, vec4_t out ) {
line 797
;797:	out[0] = in[0]*scale;
ADDRFP4 8
INDIRP4
ADDRFP4 0
INDIRP4
INDIRF4
ADDRFP4 4
INDIRF4
MULF4
ASGNF4
line 798
;798:	out[1] = in[1]*scale;
ADDRFP4 8
INDIRP4
CNSTI4 4
ADDP4
ADDRFP4 0
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ADDRFP4 4
INDIRF4
MULF4
ASGNF4
line 799
;799:	out[2] = in[2]*scale;
ADDRFP4 8
INDIRP4
CNSTI4 8
ADDP4
ADDRFP4 0
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ADDRFP4 4
INDIRF4
MULF4
ASGNF4
line 800
;800:	out[3] = in[3]*scale;
ADDRFP4 8
INDIRP4
CNSTI4 12
ADDP4
ADDRFP4 0
INDIRP4
CNSTI4 12
ADDP4
INDIRF4
ADDRFP4 4
INDIRF4
MULF4
ASGNF4
line 801
;801:}
LABELV $265
endproc Vector4Scale 0 0
export Q_log2
proc Q_log2 8 0
line 804
;802:
;803:
;804:int Q_log2( int val ) {
line 807
;805:	int answer;
;806:
;807:	answer = 0;
ADDRLP4 0
CNSTI4 0
ASGNI4
ADDRGP4 $268
JUMPV
LABELV $267
line 808
;808:	while ( ( val>>=1 ) != 0 ) {
line 809
;809:		answer++;
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
line 810
;810:	}
LABELV $268
line 808
ADDRLP4 4
ADDRFP4 0
INDIRI4
CNSTI4 1
RSHI4
ASGNI4
ADDRFP4 0
ADDRLP4 4
INDIRI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $267
line 811
;811:	return answer;
ADDRLP4 0
INDIRI4
RETI4
LABELV $266
endproc Q_log2 8 0
export MatrixMultiply
proc MatrixMultiply 72 0
line 840
;812:}
;813:
;814:
;815:
;816:/*
;817:=================
;818:PlaneTypeForNormal
;819:=================
;820:*/
;821:/*
;822:int	PlaneTypeForNormal (vec3_t normal) {
;823:	if ( normal[0] == 1.0 )
;824:		return PLANE_X;
;825:	if ( normal[1] == 1.0 )
;826:		return PLANE_Y;
;827:	if ( normal[2] == 1.0 )
;828:		return PLANE_Z;
;829:	
;830:	return PLANE_NON_AXIAL;
;831:}
;832:*/
;833:
;834:
;835:/*
;836:================
;837:MatrixMultiply
;838:================
;839:*/
;840:void MatrixMultiply(float in1[3][3], float in2[3][3], float out[3][3]) {
line 841
;841:	out[0][0] = in1[0][0] * in2[0][0] + in1[0][1] * in2[1][0] +
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 4
ADDRFP4 4
INDIRP4
ASGNP4
ADDRFP4 8
INDIRP4
ADDRLP4 0
INDIRP4
INDIRF4
ADDRLP4 4
INDIRP4
INDIRF4
MULF4
ADDRLP4 0
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ADDRLP4 4
INDIRP4
CNSTI4 12
ADDP4
INDIRF4
MULF4
ADDF4
ADDRLP4 0
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ADDRLP4 4
INDIRP4
CNSTI4 24
ADDP4
INDIRF4
MULF4
ADDF4
ASGNF4
line 843
;842:				in1[0][2] * in2[2][0];
;843:	out[0][1] = in1[0][0] * in2[0][1] + in1[0][1] * in2[1][1] +
ADDRLP4 8
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 12
ADDRFP4 4
INDIRP4
ASGNP4
ADDRFP4 8
INDIRP4
CNSTI4 4
ADDP4
ADDRLP4 8
INDIRP4
INDIRF4
ADDRLP4 12
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
MULF4
ADDRLP4 8
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ADDRLP4 12
INDIRP4
CNSTI4 16
ADDP4
INDIRF4
MULF4
ADDF4
ADDRLP4 8
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ADDRLP4 12
INDIRP4
CNSTI4 28
ADDP4
INDIRF4
MULF4
ADDF4
ASGNF4
line 845
;844:				in1[0][2] * in2[2][1];
;845:	out[0][2] = in1[0][0] * in2[0][2] + in1[0][1] * in2[1][2] +
ADDRLP4 16
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 20
ADDRFP4 4
INDIRP4
ASGNP4
ADDRFP4 8
INDIRP4
CNSTI4 8
ADDP4
ADDRLP4 16
INDIRP4
INDIRF4
ADDRLP4 20
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
MULF4
ADDRLP4 16
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ADDRLP4 20
INDIRP4
CNSTI4 20
ADDP4
INDIRF4
MULF4
ADDF4
ADDRLP4 16
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ADDRLP4 20
INDIRP4
CNSTI4 32
ADDP4
INDIRF4
MULF4
ADDF4
ASGNF4
line 847
;846:				in1[0][2] * in2[2][2];
;847:	out[1][0] = in1[1][0] * in2[0][0] + in1[1][1] * in2[1][0] +
ADDRLP4 24
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 28
ADDRFP4 4
INDIRP4
ASGNP4
ADDRFP4 8
INDIRP4
CNSTI4 12
ADDP4
ADDRLP4 24
INDIRP4
CNSTI4 12
ADDP4
INDIRF4
ADDRLP4 28
INDIRP4
INDIRF4
MULF4
ADDRLP4 24
INDIRP4
CNSTI4 16
ADDP4
INDIRF4
ADDRLP4 28
INDIRP4
CNSTI4 12
ADDP4
INDIRF4
MULF4
ADDF4
ADDRLP4 24
INDIRP4
CNSTI4 20
ADDP4
INDIRF4
ADDRLP4 28
INDIRP4
CNSTI4 24
ADDP4
INDIRF4
MULF4
ADDF4
ASGNF4
line 849
;848:				in1[1][2] * in2[2][0];
;849:	out[1][1] = in1[1][0] * in2[0][1] + in1[1][1] * in2[1][1] +
ADDRLP4 32
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 36
ADDRFP4 4
INDIRP4
ASGNP4
ADDRFP4 8
INDIRP4
CNSTI4 16
ADDP4
ADDRLP4 32
INDIRP4
CNSTI4 12
ADDP4
INDIRF4
ADDRLP4 36
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
MULF4
ADDRLP4 32
INDIRP4
CNSTI4 16
ADDP4
INDIRF4
ADDRLP4 36
INDIRP4
CNSTI4 16
ADDP4
INDIRF4
MULF4
ADDF4
ADDRLP4 32
INDIRP4
CNSTI4 20
ADDP4
INDIRF4
ADDRLP4 36
INDIRP4
CNSTI4 28
ADDP4
INDIRF4
MULF4
ADDF4
ASGNF4
line 851
;850:				in1[1][2] * in2[2][1];
;851:	out[1][2] = in1[1][0] * in2[0][2] + in1[1][1] * in2[1][2] +
ADDRLP4 40
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 44
ADDRFP4 4
INDIRP4
ASGNP4
ADDRFP4 8
INDIRP4
CNSTI4 20
ADDP4
ADDRLP4 40
INDIRP4
CNSTI4 12
ADDP4
INDIRF4
ADDRLP4 44
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
MULF4
ADDRLP4 40
INDIRP4
CNSTI4 16
ADDP4
INDIRF4
ADDRLP4 44
INDIRP4
CNSTI4 20
ADDP4
INDIRF4
MULF4
ADDF4
ADDRLP4 40
INDIRP4
CNSTI4 20
ADDP4
INDIRF4
ADDRLP4 44
INDIRP4
CNSTI4 32
ADDP4
INDIRF4
MULF4
ADDF4
ASGNF4
line 853
;852:				in1[1][2] * in2[2][2];
;853:	out[2][0] = in1[2][0] * in2[0][0] + in1[2][1] * in2[1][0] +
ADDRLP4 48
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 52
ADDRFP4 4
INDIRP4
ASGNP4
ADDRFP4 8
INDIRP4
CNSTI4 24
ADDP4
ADDRLP4 48
INDIRP4
CNSTI4 24
ADDP4
INDIRF4
ADDRLP4 52
INDIRP4
INDIRF4
MULF4
ADDRLP4 48
INDIRP4
CNSTI4 28
ADDP4
INDIRF4
ADDRLP4 52
INDIRP4
CNSTI4 12
ADDP4
INDIRF4
MULF4
ADDF4
ADDRLP4 48
INDIRP4
CNSTI4 32
ADDP4
INDIRF4
ADDRLP4 52
INDIRP4
CNSTI4 24
ADDP4
INDIRF4
MULF4
ADDF4
ASGNF4
line 855
;854:				in1[2][2] * in2[2][0];
;855:	out[2][1] = in1[2][0] * in2[0][1] + in1[2][1] * in2[1][1] +
ADDRLP4 56
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 60
ADDRFP4 4
INDIRP4
ASGNP4
ADDRFP4 8
INDIRP4
CNSTI4 28
ADDP4
ADDRLP4 56
INDIRP4
CNSTI4 24
ADDP4
INDIRF4
ADDRLP4 60
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
MULF4
ADDRLP4 56
INDIRP4
CNSTI4 28
ADDP4
INDIRF4
ADDRLP4 60
INDIRP4
CNSTI4 16
ADDP4
INDIRF4
MULF4
ADDF4
ADDRLP4 56
INDIRP4
CNSTI4 32
ADDP4
INDIRF4
ADDRLP4 60
INDIRP4
CNSTI4 28
ADDP4
INDIRF4
MULF4
ADDF4
ASGNF4
line 857
;856:				in1[2][2] * in2[2][1];
;857:	out[2][2] = in1[2][0] * in2[0][2] + in1[2][1] * in2[1][2] +
ADDRLP4 64
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 68
ADDRFP4 4
INDIRP4
ASGNP4
ADDRFP4 8
INDIRP4
CNSTI4 32
ADDP4
ADDRLP4 64
INDIRP4
CNSTI4 24
ADDP4
INDIRF4
ADDRLP4 68
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
MULF4
ADDRLP4 64
INDIRP4
CNSTI4 28
ADDP4
INDIRF4
ADDRLP4 68
INDIRP4
CNSTI4 20
ADDP4
INDIRF4
MULF4
ADDF4
ADDRLP4 64
INDIRP4
CNSTI4 32
ADDP4
INDIRF4
ADDRLP4 68
INDIRP4
CNSTI4 32
ADDP4
INDIRF4
MULF4
ADDF4
ASGNF4
line 859
;858:				in1[2][2] * in2[2][2];
;859:}
LABELV $270
endproc MatrixMultiply 72 0
bss
align 4
LABELV $272
skip 4
align 4
LABELV $273
skip 4
align 4
LABELV $274
skip 4
align 4
LABELV $275
skip 4
align 4
LABELV $276
skip 4
align 4
LABELV $277
skip 4
export AngleVectors
code
proc AngleVectors 28 4
line 862
;860:
;861:
;862:void AngleVectors( const vec3_t angles, vec3_t forward, vec3_t right, vec3_t up) {
line 867
;863:	float		angle;
;864:	static float		sr, sp, sy, cr, cp, cy;
;865:	// static to help MS compiler fp bugs
;866:
;867:	angle = angles[YAW] * (M_PI*2 / 360);
ADDRLP4 0
ADDRFP4 0
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
CNSTF4 1016003125
MULF4
ASGNF4
line 868
;868:	sy = sin(angle);
ADDRLP4 0
INDIRF4
ARGF4
ADDRLP4 4
ADDRGP4 sin
CALLF4
ASGNF4
ADDRGP4 $274
ADDRLP4 4
INDIRF4
ASGNF4
line 869
;869:	cy = cos(angle);
ADDRLP4 0
INDIRF4
ARGF4
ADDRLP4 8
ADDRGP4 cos
CALLF4
ASGNF4
ADDRGP4 $277
ADDRLP4 8
INDIRF4
ASGNF4
line 870
;870:	angle = angles[PITCH] * (M_PI*2 / 360);
ADDRLP4 0
ADDRFP4 0
INDIRP4
INDIRF4
CNSTF4 1016003125
MULF4
ASGNF4
line 871
;871:	sp = sin(angle);
ADDRLP4 0
INDIRF4
ARGF4
ADDRLP4 12
ADDRGP4 sin
CALLF4
ASGNF4
ADDRGP4 $273
ADDRLP4 12
INDIRF4
ASGNF4
line 872
;872:	cp = cos(angle);
ADDRLP4 0
INDIRF4
ARGF4
ADDRLP4 16
ADDRGP4 cos
CALLF4
ASGNF4
ADDRGP4 $276
ADDRLP4 16
INDIRF4
ASGNF4
line 873
;873:	angle = angles[ROLL] * (M_PI*2 / 360);
ADDRLP4 0
ADDRFP4 0
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
CNSTF4 1016003125
MULF4
ASGNF4
line 874
;874:	sr = sin(angle);
ADDRLP4 0
INDIRF4
ARGF4
ADDRLP4 20
ADDRGP4 sin
CALLF4
ASGNF4
ADDRGP4 $272
ADDRLP4 20
INDIRF4
ASGNF4
line 875
;875:	cr = cos(angle);
ADDRLP4 0
INDIRF4
ARGF4
ADDRLP4 24
ADDRGP4 cos
CALLF4
ASGNF4
ADDRGP4 $275
ADDRLP4 24
INDIRF4
ASGNF4
line 877
;876:
;877:	if (forward)
ADDRFP4 4
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $278
line 878
;878:	{
line 879
;879:		forward[0] = cp*cy;
ADDRFP4 4
INDIRP4
ADDRGP4 $276
INDIRF4
ADDRGP4 $277
INDIRF4
MULF4
ASGNF4
line 880
;880:		forward[1] = cp*sy;
ADDRFP4 4
INDIRP4
CNSTI4 4
ADDP4
ADDRGP4 $276
INDIRF4
ADDRGP4 $274
INDIRF4
MULF4
ASGNF4
line 881
;881:		forward[2] = -sp;
ADDRFP4 4
INDIRP4
CNSTI4 8
ADDP4
ADDRGP4 $273
INDIRF4
NEGF4
ASGNF4
line 882
;882:	}
LABELV $278
line 883
;883:	if (right)
ADDRFP4 8
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $280
line 884
;884:	{
line 885
;885:		right[0] = (-1*sr*sp*cy+-1*cr*-sy);
ADDRFP4 8
INDIRP4
ADDRGP4 $272
INDIRF4
CNSTF4 3212836864
MULF4
ADDRGP4 $273
INDIRF4
MULF4
ADDRGP4 $277
INDIRF4
MULF4
ADDRGP4 $275
INDIRF4
CNSTF4 3212836864
MULF4
ADDRGP4 $274
INDIRF4
NEGF4
MULF4
ADDF4
ASGNF4
line 886
;886:		right[1] = (-1*sr*sp*sy+-1*cr*cy);
ADDRFP4 8
INDIRP4
CNSTI4 4
ADDP4
ADDRGP4 $272
INDIRF4
CNSTF4 3212836864
MULF4
ADDRGP4 $273
INDIRF4
MULF4
ADDRGP4 $274
INDIRF4
MULF4
ADDRGP4 $275
INDIRF4
CNSTF4 3212836864
MULF4
ADDRGP4 $277
INDIRF4
MULF4
ADDF4
ASGNF4
line 887
;887:		right[2] = -1*sr*cp;
ADDRFP4 8
INDIRP4
CNSTI4 8
ADDP4
ADDRGP4 $272
INDIRF4
CNSTF4 3212836864
MULF4
ADDRGP4 $276
INDIRF4
MULF4
ASGNF4
line 888
;888:	}
LABELV $280
line 889
;889:	if (up)
ADDRFP4 12
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $282
line 890
;890:	{
line 891
;891:		up[0] = (cr*sp*cy+-sr*-sy);
ADDRFP4 12
INDIRP4
ADDRGP4 $275
INDIRF4
ADDRGP4 $273
INDIRF4
MULF4
ADDRGP4 $277
INDIRF4
MULF4
ADDRGP4 $272
INDIRF4
NEGF4
ADDRGP4 $274
INDIRF4
NEGF4
MULF4
ADDF4
ASGNF4
line 892
;892:		up[1] = (cr*sp*sy+-sr*cy);
ADDRFP4 12
INDIRP4
CNSTI4 4
ADDP4
ADDRGP4 $275
INDIRF4
ADDRGP4 $273
INDIRF4
MULF4
ADDRGP4 $274
INDIRF4
MULF4
ADDRGP4 $272
INDIRF4
NEGF4
ADDRGP4 $277
INDIRF4
MULF4
ADDF4
ASGNF4
line 893
;893:		up[2] = cr*cp;
ADDRFP4 12
INDIRP4
CNSTI4 8
ADDP4
ADDRGP4 $275
INDIRF4
ADDRGP4 $276
INDIRF4
MULF4
ASGNF4
line 894
;894:	}
LABELV $282
line 895
;895:}
LABELV $271
endproc AngleVectors 28 4
export PerpendicularVector
proc PerpendicularVector 32 12
line 901
;896:
;897:/*
;898:** assumes "src" is normalized
;899:*/
;900:void PerpendicularVector( vec3_t dst, const vec3_t src )
;901:{
line 904
;902:	int	pos;
;903:	int i;
;904:	float minelem = 1.0F;
ADDRLP4 4
CNSTF4 1065353216
ASGNF4
line 910
;905:	vec3_t tempvec;
;906:
;907:	/*
;908:	** find the smallest magnitude axially aligned vector
;909:	*/
;910:	for ( pos = 0, i = 0; i < 3; i++ )
ADDRLP4 8
CNSTI4 0
ASGNI4
ADDRLP4 0
CNSTI4 0
ASGNI4
ADDRGP4 $288
JUMPV
LABELV $285
line 911
;911:	{
line 912
;912:		if ( fabs( src[i] ) < minelem )
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 4
INDIRP4
ADDP4
INDIRF4
ARGF4
ADDRLP4 24
ADDRGP4 fabs
CALLF4
ASGNF4
ADDRLP4 24
INDIRF4
ADDRLP4 4
INDIRF4
GEF4 $289
line 913
;913:		{
line 914
;914:			pos = i;
ADDRLP4 8
ADDRLP4 0
INDIRI4
ASGNI4
line 915
;915:			minelem = fabs( src[i] );
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 4
INDIRP4
ADDP4
INDIRF4
ARGF4
ADDRLP4 28
ADDRGP4 fabs
CALLF4
ASGNF4
ADDRLP4 4
ADDRLP4 28
INDIRF4
ASGNF4
line 916
;916:		}
LABELV $289
line 917
;917:	}
LABELV $286
line 910
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $288
ADDRLP4 0
INDIRI4
CNSTI4 3
LTI4 $285
line 918
;918:	tempvec[0] = tempvec[1] = tempvec[2] = 0.0F;
ADDRLP4 24
CNSTF4 0
ASGNF4
ADDRLP4 12+8
ADDRLP4 24
INDIRF4
ASGNF4
ADDRLP4 12+4
ADDRLP4 24
INDIRF4
ASGNF4
ADDRLP4 12
ADDRLP4 24
INDIRF4
ASGNF4
line 919
;919:	tempvec[pos] = 1.0F;
ADDRLP4 8
INDIRI4
CNSTI4 2
LSHI4
ADDRLP4 12
ADDP4
CNSTF4 1065353216
ASGNF4
line 924
;920:
;921:	/*
;922:	** project the point onto the plane defined by src
;923:	*/
;924:	ProjectPointOnPlane( dst, tempvec, src );
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 12
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRGP4 ProjectPointOnPlane
CALLV
pop
line 929
;925:
;926:	/*
;927:	** normalize the result
;928:	*/
;929:	VectorNormalize( dst );
ADDRFP4 0
INDIRP4
ARGP4
ADDRGP4 VectorNormalize
CALLF4
pop
line 930
;930:}
LABELV $284
endproc PerpendicularVector 32 12
export N_isnan
proc N_isnan 4 0
line 941
;931:
;932:
;933:/*
;934:================
;935:Q_isnan
;936:
;937:Don't pass doubles to this
;938:================
;939:*/
;940:int N_isnan( float x )
;941:{
line 944
;942:	floatint_t fi;
;943:
;944:	fi.f = x;
ADDRLP4 0
ADDRFP4 0
INDIRF4
ASGNF4
line 945
;945:	fi.u &= 0x7FFFFFFF;
ADDRLP4 0
ADDRLP4 0
INDIRU4
CNSTU4 2147483647
BANDU4
ASGNU4
line 946
;946:	fi.u = 0x7F800000 - fi.u;
ADDRLP4 0
CNSTU4 2139095040
ADDRLP4 0
INDIRU4
SUBU4
ASGNU4
line 948
;947:
;948:	return (int)( fi.u >> 31 );
ADDRLP4 0
INDIRU4
CNSTI4 31
RSHU4
CVUI4 4
RETI4
LABELV $293
endproc N_isnan 4 0
proc N_isfinite 8 0
line 959
;949:}
;950://------------------------------------------------------------------------
;951:
;952:
;953:/*
;954:================
;955:Q_isfinite
;956:================
;957:*/
;958:static int N_isfinite( float f )
;959:{
line 961
;960:	floatint_t fi;
;961:	fi.f = f;
ADDRLP4 0
ADDRFP4 0
INDIRF4
ASGNF4
line 963
;962:
;963:	if ( fi.u == 0xFF800000 || fi.u == 0x7F800000 )
ADDRLP4 4
ADDRLP4 0
INDIRU4
ASGNU4
ADDRLP4 4
INDIRU4
CNSTU4 4286578688
EQU4 $297
ADDRLP4 4
INDIRU4
CNSTU4 2139095040
NEU4 $295
LABELV $297
line 964
;964:		return 0; // -INF or +INF
CNSTI4 0
RETI4
ADDRGP4 $294
JUMPV
LABELV $295
line 966
;965:
;966:	fi.u = 0x7F800000 - (fi.u & 0x7FFFFFFF);
ADDRLP4 0
CNSTU4 2139095040
ADDRLP4 0
INDIRU4
CNSTU4 2147483647
BANDU4
SUBU4
ASGNU4
line 967
;967:	if ( (int)( fi.u >> 31 ) )
ADDRLP4 0
INDIRU4
CNSTI4 31
RSHU4
CVUI4 4
CNSTI4 0
EQI4 $298
line 968
;968:		return 0; // -NAN or +NAN
CNSTI4 0
RETI4
ADDRGP4 $294
JUMPV
LABELV $298
line 970
;969:
;970:	return 1;
CNSTI4 1
RETI4
LABELV $294
endproc N_isfinite 8 0
export N_atof
proc N_atof 12 4
line 980
;971:}
;972:
;973:
;974:/*
;975:================
;976:Q_atof
;977:================
;978:*/
;979:float N_atof( const char *str )
;980:{
line 983
;981:	float f;
;982:
;983:	f = atof( str );
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 4
ADDRGP4 atof
CALLI4
ASGNI4
ADDRLP4 0
ADDRLP4 4
INDIRI4
CVIF4 4
ASGNF4
line 988
;984:
;985:	// modern C11-like implementations of atof() may return INF or NAN
;986:	// which breaks all FP code where such values getting passed
;987:	// and effectively corrupts range checks for cvars as well
;988:	if ( !N_isfinite( f ) )
ADDRLP4 0
INDIRF4
ARGF4
ADDRLP4 8
ADDRGP4 N_isfinite
CALLI4
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 0
NEI4 $301
line 989
;989:		return 0.0f;
CNSTF4 0
RETF4
ADDRGP4 $300
JUMPV
LABELV $301
line 991
;990:
;991:	return f;
ADDRLP4 0
INDIRF4
RETF4
LABELV $300
endproc N_atof 12 4
export N_fabs
proc N_fabs 4 0
line 995
;992:}
;993:
;994:
;995:float N_fabs( float f ) {
line 997
;996:	floatint_t fi;
;997:	fi.f = f;
ADDRLP4 0
ADDRFP4 0
INDIRF4
ASGNF4
line 998
;998:	fi.i &= 0x7FFFFFFF;
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 2147483647
BANDI4
ASGNI4
line 999
;999:	return fi.f;
ADDRLP4 0
INDIRF4
RETF4
LABELV $303
endproc N_fabs 4 0
export N_log2f
proc N_log2f 8 4
line 1009
;1000:}
;1001:
;1002:
;1003:/*
;1004:================
;1005:Q_log2f
;1006:================
;1007:*/
;1008:float N_log2f( float f )
;1009:{
line 1010
;1010:	const float v = logf( f );
ADDRFP4 0
INDIRF4
ARGF4
ADDRLP4 4
ADDRGP4 logf
CALLI4
ASGNI4
ADDRLP4 0
ADDRLP4 4
INDIRI4
CVIF4 4
ASGNF4
line 1011
;1011:	return v / M_LN2;
ADDRLP4 0
INDIRF4
CNSTF4 1069066811
MULF4
RETF4
LABELV $304
endproc N_log2f 8 4
export N_exp2f
proc N_exp2f 4 8
line 1021
;1012:}
;1013:
;1014:
;1015:/*
;1016:================
;1017:Q_exp2f
;1018:================
;1019:*/
;1020:float N_exp2f( float f )
;1021:{
line 1022
;1022:	return powf( 2.0f, f );
CNSTF4 1073741824
ARGF4
ADDRFP4 0
INDIRF4
ARGF4
ADDRLP4 0
ADDRGP4 powf
CALLI4
ASGNI4
ADDRLP4 0
INDIRI4
CVIF4 4
RETF4
LABELV $305
endproc N_exp2f 4 8
import powf
import logf
import atof
import sqrtf
import pow
import I_GetParm
import Com_TouchMemory
import Hunk_TempIsClear
import Hunk_Check
import Hunk_Print
import Hunk_SetMark
import Hunk_ClearToMark
import Hunk_CheckMark
import Hunk_SmallLog
import Hunk_Log
import Hunk_MemoryRemaining
import Hunk_ClearTempMemory
import Hunk_FreeTempMemory
import Hunk_AllocateTempMemory
import Hunk_Clear
import Hunk_Alloc
import Hunk_InitMemory
import Z_InitMemory
import Z_InitSmallZoneMemory
import CopyString
import Z_AvailableMemory
import Z_FreeTags
import Z_Free
import S_Malloc
import Z_Malloc
import Z_Realloc
import CPU_flags
import FS_ReadLine
import FS_ListFiles
import FS_FreeFileList
import FS_FreeFile
import FS_SetBFFIndex
import FS_GetCurrentChunkList
import FS_Initialized
import FS_FileIsInBFF
import FS_StripExt
import FS_AllowedExtension
import FS_GetFileList
import FS_LoadLibrary
import FS_CopyString
import FS_BuildOSPath
import FS_FilenameCompare
import FS_FileTell
import FS_FileLength
import FS_FileSeek
import FS_FileExists
import FS_LastBFFIndex
import FS_LoadStack
import FS_Rename
import FS_FOpenFileRead
import FS_FOpenAppend
import FS_FOpenRW
import FS_FOpenWrite
import FS_FOpenRead
import FS_FOpenFileWithMode
import FS_FOpenWithMode
import FS_FileToFileno
import FS_Printf
import FS_GetGamePath
import FS_GetHomePath
import FS_GetBasePath
import FS_GetBaseGameDir
import FS_GetCurrentGameDir
import FS_Flush
import FS_ForceFlush
import FS_FClose
import FS_LoadFile
import FS_WriteFile
import FS_Write
import FS_Read
import FS_Remove
import FS_Restart
import FS_Shutdown
import FS_InitFilesystem
import FS_Startup
import FS_VM_CloseFiles
import FS_VM_FileLength
import FS_VM_Read
import FS_VM_Write
import FS_VM_WriteFile
import FS_VM_FClose
import FS_VM_FOpenFileRead
import FS_VM_FOpenFileWrite
import FS_VM_FOpenFile
import FS_VM_FileTell
import FS_VM_FileSeek
import FS_VM_FOpenRW
import FS_VM_FOpenAppend
import FS_VM_FOpenWrite
import FS_VM_FOpenRead
import com_errorMessage
import com_fullyInitialized
import com_errorEntered
import com_cacheLine
import com_frameTime
import com_fps
import com_frameNumber
import com_maxfps
import sys_cpuString
import com_devmode
import com_version
import com_logfile
import com_journal
import com_demo
import Con_HistoryGetNext
import Con_HistoryGetPrev
import Con_SaveField
import Con_ResetHistory
import Field_CompleteCommand
import Field_CompleteFilename
import Field_CompleteKeyBind
import Field_CompleteKeyname
import Field_AutoComplete
import Field_Clear
import Cbuf_Init
import Cbuf_Clear
import Cbuf_AddText
import Cbuf_Execute
import Cbuf_InsertText
import Cbuf_ExecuteText
import Cmd_CompleteArgument
import Cmd_CommandCompletion
import va
import Cmd_Clear
import Cmd_Argv
import Cmd_ArgsFrom
import Cmd_SetCommandCompletionFunc
import Cmd_TokenizeStringIgnoreQuotes
import Cmd_TokenizeString
import Cmd_ArgvBuffer
import Cmd_Argc
import Cmd_ExecuteString
import Cmd_ExecuteText
import Cmd_ArgsBuffer
import Cmd_ExecuteCommand
import Cmd_RemoveCommand
import Cmd_AddCommand
import Cmd_Init
import keys
import Key_WriteBindings
import Key_SetOverstrikeMode
import Key_GetOverstrikeMode
import Key_GetKey
import Key_GetCatcher
import Key_SetCatcher
import Key_ClearStates
import Key_GetBinding
import Key_IsDown
import Key_KeynumToString
import Key_StringToKeynum
import Key_KeynameCompletion
import Com_EventLoop
import Com_KeyEvent
import Com_SendKeyEvents
import Com_QueueEvent
import Com_InitKeyCommands
import Parse3DMatrix
import Parse2DMatrix
import Parse1DMatrix
import ParseHex
import SkipRestOfLine
import SkipBracedSection
import com_tokentype
import COM_ParseComplex
import Com_BlockChecksum
import COM_ParseWarning
import COM_ParseError
import COM_Compress
import COM_ParseExt
import COM_Parse
import COM_GetCurrentParseLine
import COM_BeginParseSession
import COM_StripExtension
import COM_GetExtension
import Com_TruncateLongString
import Com_SortFileList
import Com_Base64Decode
import Com_HasPatterns
import Com_FilterPath
import Com_Filter
import Com_FilterExt
import Com_HexStrToInt
import COM_DefaultExtension
import Com_WriteConfig
import Con_RenderConsole
import Com_GenerateHashValue
import Com_Shutdown
import Com_Init
import Com_StartupVariable
import crc32_buffer
import Com_EarlyParseCmdLine
import Com_Milliseconds
import Com_Frame
import Sys_SnapVector
import Con_DPrintf
import Con_Printf
import Con_Shutdown
import Con_Init
import Con_DrawConsole
import Con_AddText
import Info_RemoveKey
import Info_NextPair
import Info_ValidateKeyValue
import Info_Validate
import Info_SetValueForKey_s
import Info_ValueForKeyToken
import Info_Tokenize
import Info_ValueForKey
import Com_Clamp
import COM_SkipPath
import AngleDelta
import AngleNormalize180
import AngleNormalize360
import AnglesSubtract
import AngleSubtract
import LerpAngle
import AngleMod
import N_crandom
import N_random
import N_rand
import N_acos
import N_log2
import VectorInverse
import VectorNormalizeFast
import DistanceSquared
import Distance
import VectorLengthSquared
import N_Error
import locase
import mat4_identity
import Com_Split
import N_replace
import N_memcmp
import N_memchr
import N_memcpy
import N_memset
import N_strncpyz
import N_strncpy
import N_strcpy
import N_stradd
import N_strneq
import N_streq
import N_strlen
import N_atoi
import N_fmaxf
import N_stristr
import N_strcat
import N_strupr
import N_strlwr
import N_stricmpn
import N_stricmp
import N_strncmp
import N_strcmp
import N_isanumber
import N_isintegral
import N_isalpha
import N_isupper
import N_islower
import N_isprint
import Com_SkipCharset
import Com_SkipTokens
import Com_snprintf
import acos
import fabs
import abs
import tan
import atan2
import cos
import sin
import sqrt
import floor
import ceil
import sscanf
import vsprintf
import rand
import srand
import qsort
import toupper
import tolower
import strncmp
import strcmp
import strstr
import strchr
import strlen
import strcat
import strcpy
import memmove
import memset
import memchr
import memcpy
