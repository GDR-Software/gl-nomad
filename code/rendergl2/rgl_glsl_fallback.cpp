
const char *fallbackShader_imgui_fp =
"#if !defined(GLSL_LEGACY)\n"
"layout(location = 0) out vec4 a_Color;\n"
"#endif\n"
"\n"
"in vec2 v_TexCoord;\n"
"in vec4 v_Color;\n"
"\n"
"uniform sampler2D u_DiffuseMap;\n"
"uniform float u_GammaAmount;\n"
"\n"
"void main() {\n"
"    a_Color = v_Color * texture(u_DiffuseMap, v_TexCoord);\n"
"    a_Color.rgb = pow(a_Color.rgb, vec3( 1.0 / u_GammaAmount ));\n"
"}\n"
;

const char *fallbackShader_basic_vp =
"in vec3 a_Position;\n"
"in vec2 a_TexCoord;\n"
"in vec4 a_Color;\n"
"\n"
"out vec2 v_TexCoord;\n"
"out vec3 v_FragPos;\n"
"out vec4 v_Color;\n"
"\n"
"uniform mat4 u_ModelViewProjection;\n"
"uniform vec4 u_BaseColor;\n"
"uniform vec4 u_VertColor;\n"
"\n"
"#if defined(USE_RGBAGEN)\n"
"uniform int u_ColorGen;\n"
"uniform int u_AlphaGen;\n"
"uniform vec3 u_AmbientLight;\n"
"uniform vec3 u_DirectedLight;\n"
"#endif\n"
"\n"
"#if defined(USE_RGBAGEN)\n"
"vec4 CalcColor(vec3 position, vec3 normal)\n"
"{\n"
"	vec4 color = u_VertColor * a_Color + u_BaseColor;\n"
"\n"
"	if (u_ColorGen == CGEN_LIGHTING_DIFFUSE)\n"
"	{\n"
"		float incoming = clamp(dot(normal, u_ModelLightDir), 0.0, 1.0);\n"
"\n"
"		color.rgb = clamp(u_DirectedLight * incoming + u_AmbientLight, 0.0, 1.0);\n"
"	}\n"
"\n"
"	vec3 viewer = u_LocalViewOrigin - position;\n"
"\n"
"	if (u_AlphaGen == AGEN_LIGHTING_SPECULAR)\n"
"	{\n"
"		vec3 lightDir = normalize(vec3(-960.0, 1980.0, 96.0) - position);\n"
"		vec3 reflected = -reflect(lightDir, normal);\n"
"\n"
"		color.a = clamp(dot(reflected, normalize(viewer)), 0.0, 1.0);\n"
"		color.a *= color.a;\n"
"		color.a *= color.a;\n"
"	}\n"
"	else if (u_AlphaGen == AGEN_PORTAL)\n"
"	{\n"
"		color.a = clamp(length(viewer) / u_PortalRange, 0.0, 1.0);\n"
"	}\n"
"\n"
"	return color;\n"
"}\n"
"#endif\n"
"\n"
"void main()\n"
"{\n"
"#if defined(USE_RGBAGEN)\n"
"    v_Color = CalcColor(a_Position, a_Normal);\n"
"#else\n"
"//    v_Color = u_VertColor * a_Color + u_BaseColor;\n"
"#endif\n"
"	v_Color = a_Color;\n"
"	v_TexCoord = a_TexCoord;\n"
"	v_FragPos = vec4(u_ModelViewProjection * vec4(a_Position, 1.0)).xyz;\n"
"\n"
"    gl_Position = u_ModelViewProjection * vec4(a_Position, 1.0);\n"
"}\n"
;

const char *fallbackShader_basic_fp =
"#if !defined(GLSL_LEGACY)\n"
"out vec4 a_Color;\n"
"#endif\n"
"\n"
"in vec2 v_TexCoord;\n"
"in vec3 v_FragPos;\n"
"in vec4 v_Color;\n"
"\n"
"uniform sampler2D u_DiffuseMap;\n"
"uniform float u_AmbientIntensity = float(0.0);\n"
"uniform vec3 u_AmbientColor = vec3(0.0);\n"
"\n"
"//uniform sampler2D u_ColorMap;\n"
"\n"
"#if defined(USE_NORMALMAP)\n"
"uniform sampler2D u_NormalMap;\n"
"#endif\n"
"\n"
"#if defined(USE_SPECULARMAP)\n"
"uniform sampler2D u_SpecularMap;\n"
"#endif\n"
"\n"
"#if 0\n"
"void applyLighting() {\n"
"    vec3 ambient = u_AmbientColor + u_AmbientIntensity;\n"
"\n"
"    for (int i = 0; i < u_numLights; i++) {\n"
"        float diffuse = 0.0;\n"
"        mat4 model = mat4(1.0);\n"
"\n"
"        //\n"
"        // using world position will give the lighting a more\n"
"        // retro and pixel-game (8-bit) style look because\n"
"        // individual tiles will be lit up\n"
"        //\n"
"\n"
"        float dist = distance(lights[i].origin, v_WorldPos);\n"
"        vec3 color = lights[i].color + lights[i].intensity.x;\n"
"        float range = lights[i].intensity.y;\n"
"\n"
"        if (dist <= range) {\n"
"            diffuse = 1.0 - abs(dist / lights[i].intensity.x);\n"
"        }\n"
"\n"
"        a_Color *= vec4(min(a_Color.rgb * ((lights[i].color * diffuse) + u_AmbientColor), a_Color.rgb), 1.0);\n"
"    }\n"
"}\n"
"#endif\n"
"\n"
"void main() {\n"
"    a_Color = texture(u_DiffuseMap, v_TexCoord);\n"
"}\n"
;

const char *fallbackShader_imgui_vp =
"in vec3 a_Position;\n"
"in vec2 a_TexCoord;\n"
"in vec4 a_Color;\n"
"\n"
"uniform mat4 u_ModelViewProjection;\n"
"\n"
"out vec2 v_TexCoord;\n"
"out vec4 v_Color;\n"
"\n"
"void main() {\n"
"    v_TexCoord = a_TexCoord;\n"
"    v_Color = a_Color;\n"
"    gl_Position = u_ModelViewProjection * vec4(a_Position.xy, 0, 1);\n"
"}\n"
;
