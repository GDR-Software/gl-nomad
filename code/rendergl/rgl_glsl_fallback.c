
const char *fallbackShader_texturecolor_fp =
"#if !defined(GLSL_LEGACY)\n"
"layout( location = 0 ) out vec4 a_Color;\n"
"#endif\n"
"\n"
"uniform sampler2D u_DiffuseMap;\n"
"uniform vec4 u_Color;\n"
"\n"
"in vec2 v_TexCoords;\n"
"\n"
"void main() {\n"
"	a_Color = texture2D( u_DiffuseMap, v_TexCoords ) * u_Color;\n"
"}\n"
;

const char *fallbackShader_generic_fp =
"#if !defined(GLSL_LEGACY)\n"
"layout( location = 0 ) out vec4 a_Color;\n"
"#if defined(USE_BLOOM) && defined(USE_HDR)\n"
"layout( location = 1 ) out vec4 a_BrightColor;\n"
"#endif\n"
"#endif\n"
"\n"
"in vec2 v_TexCoords;\n"
"in vec3 v_FragPos;\n"
"in vec3 v_WorldPos;\n"
"in vec4 v_Color;\n"
"\n"
"uniform sampler2D u_DiffuseMap;\n"
"uniform float u_GammaAmount;\n"
"uniform bool u_GamePaused;\n"
"uniform bool u_HardwareGamma;\n"
"uniform int u_AntiAliasing;\n"
"\n"
"#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"uniform vec4 u_SpecularScale;\n"
"uniform vec4 u_NormalScale;\n"
"uniform int u_NumLights;\n"
"\n"
"uniform vec3 u_AmbientColor;\n"
"uniform float u_AmbientIntensity;\n"
"\n"
"struct Light {\n"
"    vec4 color;\n"
"    uvec2 origin;\n"
"    float brightness;\n"
"    float range;\n"
"    float linear;\n"
"    float quadratic;\n"
"    float constant;\n"
"    int type;\n"
"};\n"
"layout( std140, binding = 0 ) uniform u_LightBuffer {\n"
"    Light u_LightData[MAX_MAP_LIGHTS];\n"
"};\n"
"#endif\n"
"\n"
"#if defined(USE_HDR) && defined(USE_EXPOSURE_TONE_MAPPING)\n"
"uniform float u_Exposure;\n"
"#endif\n"
"\n"
"#if defined(USE_NORMALMAP)\n"
"uniform sampler2D u_NormalMap;\n"
"#endif\n"
"\n"
"#if defined(USE_SPECULARMAP)\n"
"uniform sampler2D u_SpecularMap;\n"
"#endif\n"
"\n"
"#if defined(USE_SHADOWMAP)\n"
"uniform sampler2D u_ShadowMap;\n"
"#endif\n"
"\n"
"uniform int u_AlphaTest;\n"
"\n"
"float CalcLightAttenuation(float point, float normDist)\n"
"{\n"
"	// zero light at 1.0, approximating q3 style\n"
"	// also don\'t attenuate directional light\n"
"	float attenuation = (0.5 * normDist - 1.5) * point + 1.0;\n"
"\n"
"	// clamp attenuation\n"
"#if defined(NO_LIGHT_CLAMP)\n"
"	attenuation = max(attenuation, 0.0);\n"
"#else\n"
"	attenuation = clamp(attenuation, 0.0, 1.0);\n"
"#endif\n"
"\n"
"	return attenuation;\n"
"}\n"
"\n"
"#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"//\n"
"// CalcPointLight: don\'t modify, straight from Valden\n"
"//\n"
"vec3 CalcPointLight( Light light ) {\n"
"    vec3 diffuse = a_Color.rgb;\n"
"    float dist = distance( v_WorldPos, vec3( light.origin, v_WorldPos.z ) );\n"
"    float diff = 0.0;\n"
"    float range = light.range;\n"
"    if ( dist <= light.range ) {\n"
"        diff = 1.0 - abs( dist / range );\n"
"    }\n"
"    diff += light.brightness;\n"
"    diffuse = min( diff * ( diffuse + vec3( light.color ) ), diffuse );\n"
"\n"
"    vec3 lightDir = vec3( 0.0 );\n"
"    vec3 viewDir = normalize( v_WorldPos - vec3( light.origin, 0.0 ) );\n"
"    vec3 halfwayDir = normalize( lightDir + viewDir );\n"
"\n"
"    vec3 reflectDir = reflect( -lightDir, v_WorldPos );\n"
"    float spec = pow( max( dot( v_WorldPos, reflectDir ), 0.0 ), 1.0 );\n"
"\n"
"#if defined(USE_SPECULARMAP)\n"
"    vec3 specular = spec * texture( u_SpecularMap, v_TexCoords ).rgb;\n"
"#else\n"
"    vec3 specular = vec3( 0.0 );\n"
"#endif\n"
"\n"
"    range = light.range + light.brightness;\n"
"    float attenuation = ( light.constant + light.linear * range\n"
"        + light.quadratic * ( range * range ) );\n"
"\n"
"    diffuse *= attenuation;\n"
"    specular *= attenuation;\n"
"\n"
"    return diffuse + specular;\n"
"}\n"
"#endif\n"
"\n"
"vec3 CalcDiffuse(vec3 diffuseAlbedo, float NH, float EH, float roughness)\n"
"{\n"
"#if defined(USE_BURLEY)\n"
"	// modified from https://disney-animation.s3.amazonaws.com/library/s2012_pbs_disney_brdf_notes_v2.pdf\n"
"	float fd90 = -0.5 + EH * EH * roughness;\n"
"	float burley = 1.0 + fd90 * 0.04 / NH;\n"
"	burley *= burley;\n"
"	return diffuseAlbedo * burley;\n"
"#else\n"
"	return diffuseAlbedo;\n"
"#endif\n"
"}\n"
"\n"
"void CalcNormal() {\n"
"#if defined(USE_NORMALMAP)\n"
"    vec3 normal = texture( u_NormalMap, v_TexCoords ).rgb;\n"
"    normal = normalize( normal * 2.0 - 1.0 );\n"
"    a_Color.rgb *= normal * 0.5 + 0.5;\n"
"#endif\n"
"}\n"
"\n"
"void ApplyLighting() {\n"
"    CalcNormal();\n"
"#if defined(USE_SPECULARMAP)\n"
"    if ( u_NumLights == 0 ) {\n"
"        a_Color.rgb += texture( u_SpecularMap, v_TexCoords ).rgb;\n"
"    }\n"
"#endif\n"
"#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"    for ( int i = 0; i < u_NumLights; i++ ) {\n"
"        switch ( u_LightData[i].type ) {\n"
"        case POINT_LIGHT:\n"
"            a_Color.rgb += CalcPointLight( u_LightData[i] );\n"
"            break;\n"
"        case DIRECTION_LIGHT:\n"
"            break;\n"
"        };\n"
"    }\n"
"#endif\n"
"//    a_Color.rgb = texture( u_DiffuseMap, v_TexCoords ).rgb;\n"
"}\n"
"\n"
"void texcoords( vec2 fragCoord, vec2 resolution, out vec2 v_rgbNW, out vec2 v_rgbNE, out vec2 v_rgbSW,\n"
"	out vec2 v_rgbSE, out vec2 v_rgbM )\n"
"{\n"
"	vec2 inverseVP = 1.0 / resolution.xy;\n"
"	v_rgbNW = ( fragCoord + vec2( -1.0, -1.0 ) ) * inverseVP;\n"
"	v_rgbNE = ( fragCoord + vec2( 1.0, -1.0 ) ) * inverseVP;\n"
"	v_rgbSW = ( fragCoord + vec2( -1.0, 1.0 ) ) * inverseVP;\n"
"	v_rgbSE = ( fragCoord + vec2( 1.0, 1.0 ) ) * inverseVP;\n"
"	v_rgbM = vec2( fragCoord * inverseVP );\n"
"}\n"
"\n"
"#ifndef FXAA_REDUCE_MIN\n"
"    #define FXAA_REDUCE_MIN   (1.0/ 128.0)\n"
"#endif\n"
"#ifndef FXAA_REDUCE_MUL\n"
"    #define FXAA_REDUCE_MUL   (1.0 / 8.0)\n"
"#endif\n"
"#ifndef FXAA_SPAN_MAX\n"
"    #define FXAA_SPAN_MAX     8.0\n"
"#endif\n"
"\n"
"//optimized version for mobile, where dependent\n"
"//texture reads can be a bottleneck\n"
"vec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 resolution,\n"
"            vec2 v_rgbNW, vec2 v_rgbNE,\n"
"            vec2 v_rgbSW, vec2 v_rgbSE,\n"
"            vec2 v_rgbM) {\n"
"    vec4 color;\n"
"    vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);\n"
"    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\n"
"    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\n"
"    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\n"
"    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\n"
"    vec4 texColor = texture2D(tex, v_rgbM);\n"
"    vec3 rgbM  = texColor.xyz;\n"
"    vec3 luma = vec3(0.299, 0.587, 0.114);\n"
"    float lumaNW = dot(rgbNW, luma);\n"
"    float lumaNE = dot(rgbNE, luma);\n"
"    float lumaSW = dot(rgbSW, luma);\n"
"    float lumaSE = dot(rgbSE, luma);\n"
"    float lumaM  = dot(rgbM,  luma);\n"
"    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n"
"    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n"
"\n"
"    vec2 dir;\n"
"    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n"
"    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n"
"\n"
"    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n"
"                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n"
"\n"
"    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n"
"    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n"
"              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n"
"              dir * rcpDirMin)) * inverseVP;\n"
"\n"
"    vec3 rgbA = 0.5 * (\n"
"        texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\n"
"        texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n"
"    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n"
"        texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\n"
"        texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n"
"\n"
"    float lumaB = dot(rgbB, luma);\n"
"    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n"
"        color = vec4(rgbA, texColor.a);\n"
"    else\n"
"        color = vec4(rgbB, texColor.a);\n"
"    return color;\n"
"}\n"
"\n"
"vec4 applyFXAA( sampler2D tex, vec2 fragCoord, vec2 resolution ) {\n"
"	vec2 v_rgbNW;\n"
"	vec2 v_rgbNE;\n"
"	vec2 v_rgbSW;\n"
"	vec2 v_rgbSE;\n"
"	vec2 v_rgbM;\n"
"\n"
"	texcoords( fragCoord, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM );\n"
"\n"
"	return fxaa( tex, fragCoord, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM );\n"
"}\n"
"\n"
"// -- Sharpening --\n"
"uniform float u_SharpenAmount;\n"
"uniform vec2 u_ScreenSize;\n"
"\n"
"#define sharp_clamp 0.000  //[0.000 to 1.000] Limits maximum amount of sharpening a pixel recieves - Default is 0.035\n"
"\n"
"// -- Advanced sharpening settings --\n"
"\n"
"#define offset_bias 6.0  //[0.0 to 6.0] Offset bias adjusts the radius of the sampling pattern.\n"
"                         //I designed the pattern for offset_bias 1.0, but feel free to experiment.\n"
"\n"
"#define CoefLuma vec3( 0.2126, 0.7152, 0.0722 )      // BT.709 & sRBG luma coefficient (Monitors and HD Television)\n"
"//#define CoefLuma vec3( 0.299, 0.587, 0.114 )       // BT.601 luma coefficient (SD Television)\n"
"//#define CoefLuma vec3( 1.0/3.0, 1.0/3.0, 1.0/3.0 ) // Equal weight coefficient\n"
"\n"
"vec4 sharpenImage( sampler2D tex, vec2 pos )\n"
"{\n"
"	vec4 colorInput = texture2D(tex, pos);\n"
"\n"
"	vec3 ori = colorInput.rgb;\n"
"\n"
"	// -- Combining the strength and luma multipliers --\n"
"	vec3 sharp_strength_luma = (CoefLuma * u_SharpenAmount); //I\'ll be combining even more multipliers with it later on\n"
"\n"
"	// -- Gaussian filter --\n"
"	//   [ .25, .50, .25]     [ 1 , 2 , 1 ]\n"
"	//   [ .50,   1, .50]  =  [ 2 , 4 , 2 ]\n"
" 	//   [ .25, .50, .25]     [ 1 , 2 , 1 ]\n"
"\n"
"\n"
"    float px = 1.0/u_ScreenSize[0];\n"
"	float py = 1.0/u_ScreenSize[1];\n"
"\n"
"	vec3 blur_ori = texture2D(tex, pos + vec2(px,-py) * 0.5 * offset_bias).rgb; // South East\n"
"	blur_ori += texture2D(tex, pos + vec2(-px,-py) * 0.5 * offset_bias).rgb;  // South West\n"
"	blur_ori += texture2D(tex, pos + vec2(px,py) * 0.5 * offset_bias).rgb; // North East\n"
"	blur_ori += texture2D(tex, pos + vec2(-px,py) * 0.5 * offset_bias).rgb; // North West\n"
"\n"
"	blur_ori *= 0.25;  // ( /= 4) Divide by the number of texture fetches\n"
"\n"
"\n"
"\n"
"	// -- Calculate the sharpening --\n"
"	vec3 sharp = ori - blur_ori;  //Subtracting the blurred image from the original image\n"
"\n"
"	// -- Adjust strength of the sharpening and clamp it--\n"
"	vec4 sharp_strength_luma_clamp = vec4(sharp_strength_luma * (0.5 / sharp_clamp),0.5); //Roll part of the clamp into the dot\n"
"\n"
"	float sharp_luma = clamp((dot(vec4(sharp,1.0), sharp_strength_luma_clamp)), 0.0,1.0 ); //Calculate the luma, adjust the strength, scale up and clamp\n"
"	sharp_luma = (sharp_clamp * 2.0) * sharp_luma - sharp_clamp; //scale down\n"
"\n"
"\n"
"	// -- Combining the values to get the final sharpened pixel	--\n"
"\n"
"	colorInput.rgb = colorInput.rgb + sharp_luma;    // Add the sharpening to the input color.\n"
"	return clamp(colorInput, 0.0,1.0);\n"
"}\n"
"\n"
"vec3 blur( vec3 color )\n"
"{\n"
"//    float weight[5] = float[] (0.227027, 0.1945946, 0.1216216, 0.054054, 0.016216);\n"
"    float weight[5] = float[]( 0.0, 0.0, 0.1, 0.0, 0.001 );\n"
"    vec2 tex_offset = 1.0 / textureSize( u_DiffuseMap, 0 );\n"
"    vec3 result = color * weight[0];\n"
"\n"
"    for ( int h = 0; h < 2; h++ ) {\n"
"        bool horizontal = h == 1;\n"
"        if ( horizontal ) {\n"
"            for ( int i = 1; i < 5; ++i ) {\n"
"                result += texture( u_DiffuseMap, v_TexCoords + vec2( tex_offset.x * i, 0.0 ) ).rgb * weight[i];\n"
"                result += texture( u_DiffuseMap, v_TexCoords - vec2( tex_offset.x * i, 0.0 ) ).rgb * weight[i];\n"
"            }\n"
"        }\n"
"        else {\n"
"            for( int i = 1; i < 5; ++i ) {\n"
"                result += texture( u_DiffuseMap, v_TexCoords + vec2( 0.0, tex_offset.y * i ) ).rgb * weight[i];\n"
"                result += texture( u_DiffuseMap, v_TexCoords - vec2( 0.0, tex_offset.y * i ) ).rgb * weight[i];\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    return result;\n"
"}\n"
"\n"
"void main() {\n"
"    if ( u_AntiAliasing == AntiAlias_FXAA ) {\n"
"        vec2 fragCoord = v_TexCoords * u_ScreenSize;\n"
"        a_Color = applyFXAA( u_DiffuseMap, fragCoord, u_ScreenSize );\n"
"    } else {\n"
"        a_Color = sharpenImage( u_DiffuseMap, v_TexCoords );\n"
"    }\n"
"    if ( a_Color.a == 0.0 ) {\n"
"        discard;\n"
"    }\n"
"\n"
"    ApplyLighting();\n"
"\n"
"#if defined(USE_HDR)\n"
"#if !defined(USE_EXPOSURE_TONE_MAPPING)\n"
"	// reinhard tone mapping\n"
"	a_Color.rgb = a_Color.rgb / ( a_Color.rgb + vec3( 1.0 ) );\n"
"#else\n"
"	// exposure tone mapping //  BROKEN\n"
"//	a_Color.rgb = vec3( 1.0 ) - exp( -a_Color.rgb * u_Exposure );\n"
"#endif\n"
"\n"
"#if defined(USE_BLOOM)\n"
"	// check whether fragment output is higher than threshold, if so output as brightness color\n"
"	float brightness = dot( a_Color.rgb, vec3( 0.2126, 0.7152, 0.0722 ) );\n"
"	if ( brightness > 1.0 ) {\n"
"		a_BrightColor = vec4( a_Color.rgb, 1.0 );\n"
"	} else {\n"
"		a_BrightColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n"
"	}\n"
"#endif\n"
"#endif\n"
"	a_Color.rgb = pow( a_Color.rgb, vec3( 1.0 / u_GammaAmount ) );\n"
"    a_Color.rgb *= v_Color.rgb;\n"
"//    a_Color.rgb = blur( a_Color.rgb );\n"
"\n"
"    if ( u_GamePaused ) {\n"
"        a_Color.rgb = vec3( 0.75, 0.75, 0.75 );\n"
"    }\n"
"}\n"
;

const char *fallbackShader_lightall_vp =
"in vec4 a_TexCoords;\n"
"#if defined(USE_LIGHTMAP) || defined(USE_TCGEN)\n"
"in vec4 a_LightCoords;\n"
"#endif\n"
"in vec4 a_Color;\n"
"\n"
"in vec3 a_Position;\n"
"in vec3 a_Normal;\n"
"in vec4 a_Tangent;\n"
"\n"
"#if defined(USE_LIGHT) && !defined(USE_LIGHT_VECTOR)\n"
"//in vec3 a_LightDirection;\n"
"#endif\n"
"\n"
"#if defined(USE_DELUXEMAP)\n"
"uniform vec4   u_EnableTextures; // x = normal, y = deluxe, z = specular, w = cube\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"uniform vec3   u_ViewOrigin;\n"
"#endif\n"
"\n"
"#if defined(USE_TCGEN)\n"
"uniform int    u_TCGen0;\n"
"uniform vec3   u_TCGen0Vector0;\n"
"uniform vec3   u_TCGen0Vector1;\n"
"uniform vec3   u_LocalViewOrigin;\n"
"#endif\n"
"\n"
"#if defined(USE_TCMOD)\n"
"uniform vec4   u_DiffuseTexMatrix;\n"
"uniform vec4   u_DiffuseTexOffTurb;\n"
"#endif\n"
"\n"
"uniform mat4   u_ModelViewProjectionMatrix;\n"
"uniform vec4   u_BaseColor;\n"
"uniform vec4   u_VertColor;\n"
"\n"
"#if defined(USE_MODELMATRIX)\n"
"uniform mat4   u_ModelMatrix;\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHT_VECTOR)\n"
"uniform vec4   u_LightOrigin;\n"
"uniform float  u_LightRadius;\n"
"uniform vec3   u_DirectedLight;\n"
"uniform vec3   u_AmbientLight;\n"
"#endif\n"
"\n"
"#if defined(USE_PRIMARY_LIGHT) || defined(USE_SHADOWMAP)\n"
"uniform vec4  u_PrimaryLightOrigin;\n"
"uniform float u_PrimaryLightRadius;\n"
"#endif\n"
"\n"
"out vec4   v_TexCoords;\n"
"\n"
"out vec4   v_Color;\n"
"#if defined(USE_LIGHT_VECTOR) && !defined(USE_FAST_LIGHT)\n"
"out vec4   v_ColorAmbient;\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"out vec4   v_Normal;\n"
"out vec4   v_Tangent;\n"
"out vec4   v_Bitangent;\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"out vec4   v_LightDir;\n"
"#endif\n"
"\n"
"#if defined(USE_PRIMARY_LIGHT) || defined(USE_SHADOWMAP)\n"
"out vec4   v_PrimaryLightDir;\n"
"#endif\n"
"\n"
"#if defined(USE_TCGEN)\n"
"vec2 GenTexCoords(int TCGen, vec3 position, vec3 normal, vec3 TCGenVector0, vec3 TCGenVector1)\n"
"{\n"
"	vec2 tex = a_TexCoords.st;\n"
"\n"
"	if (TCGen == TCGEN_LIGHTMAP)\n"
"	{\n"
"		tex = a_LightCoords.st;\n"
"	}\n"
"	else if (TCGen == TCGEN_ENVIRONMENT_MAPPED)\n"
"	{\n"
"		vec3 viewer = normalize(u_LocalViewOrigin - position);\n"
"		vec2 ref = reflect(viewer, normal).yz;\n"
"		tex.s = ref.x * -0.5 + 0.5;\n"
"		tex.t = ref.y *  0.5 + 0.5;\n"
"	}\n"
"	else if (TCGen == TCGEN_VECTOR)\n"
"	{\n"
"		tex = vec2(dot(position, TCGenVector0), dot(position, TCGenVector1));\n"
"	}\n"
"\n"
"	return tex;\n"
"}\n"
"#endif\n"
"\n"
"#if defined(USE_TCMOD)\n"
"vec2 ModTexCoords(vec2 st, vec3 position, vec4 texMatrix, vec4 offTurb)\n"
"{\n"
"	float amplitude = offTurb.z;\n"
"	float phase = offTurb.w * 2.0 * M_PI;\n"
"	vec2 st2;\n"
"	st2.x = st.x * texMatrix.x + (st.y * texMatrix.z + offTurb.x);\n"
"	st2.y = st.x * texMatrix.y + (st.y * texMatrix.w + offTurb.y);\n"
"\n"
"	vec2 offsetPos = vec2(position.x + position.z, position.y);\n"
"\n"
"	vec2 texOffset = sin(offsetPos * (2.0 * M_PI / 1024.0) + vec2(phase));\n"
"\n"
"	return st2 + texOffset * amplitude;\n"
"}\n"
"#endif\n"
"\n"
"\n"
"float CalcLightAttenuation(float point, float normDist)\n"
"{\n"
"	// zero light at 1.0, approximating q3 style\n"
"	// also don\'t attenuate directional light\n"
"	float attenuation = (0.5 * normDist - 1.5) * point + 1.0;\n"
"\n"
"	// clamp attenuation\n"
"	#if defined(NO_LIGHT_CLAMP)\n"
"	attenuation = max(attenuation, 0.0);\n"
"	#else\n"
"	attenuation = clamp(attenuation, 0.0, 1.0);\n"
"	#endif\n"
"\n"
"	return attenuation;\n"
"}\n"
"\n"
"\n"
"void main()\n"
"{\n"
"	vec3 position  = a_Position;\n"
"	vec3 normal    = a_Normal;\n"
"#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"	vec3 tangent   = a_Tangent.xyz;\n"
"#endif\n"
"\n"
"#if defined(USE_TCGEN)\n"
"	vec2 texCoords = GenTexCoords(u_TCGen0, position, normal, u_TCGen0Vector0, u_TCGen0Vector1);\n"
"#else\n"
"	vec2 texCoords = a_TexCoords.st;\n"
"#endif\n"
"\n"
"#if defined(USE_TCMOD)\n"
"	v_TexCoords.xy = ModTexCoords(texCoords, position, u_DiffuseTexMatrix, u_DiffuseTexOffTurb);\n"
"#else\n"
"	v_TexCoords.xy = texCoords;\n"
"#endif\n"
"\n"
"	gl_Position = u_ModelViewProjectionMatrix * vec4(position, 1.0);\n"
"\n"
"#if defined(USE_MODELMATRIX)\n"
"	position  = (u_ModelMatrix * vec4(position, 1.0)).xyz;\n"
"	normal    = (u_ModelMatrix * vec4(normal,   0.0)).xyz;\n"
"  #if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"	tangent   = (u_ModelMatrix * vec4(tangent,  0.0)).xyz;\n"
"  #endif\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"	vec3 bitangent = cross(normal, tangent) * a_Tangent.w;\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHT_VECTOR)\n"
"	vec3 L = u_LightOrigin.xyz - (position * u_LightOrigin.w);\n"
"#elif defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"//	vec3 L = a_LightDirection;\n"
"	vec3 L = vec3( 0.0 );\n"
"  #if defined(USE_MODELMATRIX)\n"
"	L = (u_ModelMatrix * vec4(L, 0.0)).xyz;\n"
"  #endif\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHTMAP)\n"
"	v_TexCoords.zw = a_LightCoords.st;\n"
"#endif\n"
"\n"
"	v_Color = u_VertColor * a_Color + u_BaseColor;\n"
"\n"
"#if defined(USE_LIGHT_VECTOR)\n"
"  #if defined(USE_FAST_LIGHT)\n"
"	float sqrLightDist = dot(L, L);\n"
"	float NL = clamp(dot(normalize(normal), L) / sqrt(sqrLightDist), 0.0, 1.0);\n"
"	float attenuation = CalcLightAttenuation(u_LightOrigin.w, u_LightRadius * u_LightRadius / sqrLightDist);\n"
"\n"
"	v_Color.rgb *= u_DirectedLight * (attenuation * NL) + u_AmbientLight;\n"
"  #else\n"
"	v_ColorAmbient.rgb = u_AmbientLight * v_Color.rgb;\n"
"	v_Color.rgb *= u_DirectedLight;\n"
"    #if defined(USE_PBR)\n"
"	v_ColorAmbient.rgb *= v_ColorAmbient.rgb;\n"
"    #endif\n"
"  #endif\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT) && defined(USE_PBR)\n"
"	v_Color.rgb *= v_Color.rgb;\n"
"#endif\n"
"\n"
"#if defined(USE_PRIMARY_LIGHT) || defined(USE_SHADOWMAP)\n"
"	v_PrimaryLightDir.xyz = u_PrimaryLightOrigin.xyz - (position * u_PrimaryLightOrigin.w);\n"
"	v_PrimaryLightDir.w = u_PrimaryLightRadius * u_PrimaryLightRadius;\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"  #if defined(USE_LIGHT_VECTOR)\n"
"	v_LightDir = vec4(L, u_LightRadius * u_LightRadius);\n"
"  #else\n"
"	v_LightDir = vec4(L, 0.0);\n"
"  #endif\n"
"  #if defined(USE_DELUXEMAP)\n"
"	v_LightDir -= u_EnableTextures.y * v_LightDir;\n"
"  #endif\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"	vec3 viewDir = u_ViewOrigin - position;\n"
"	// store view direction in tangent space to save on outs\n"
"	v_Normal    = vec4(normal,    viewDir.x);\n"
"	v_Tangent   = vec4(tangent,   viewDir.y);\n"
"	v_Bitangent = vec4(bitangent, viewDir.z);\n"
"#endif\n"
"}\n"
;

const char *fallbackShader_imgui_fp =
"#if !defined(GLSL_LEGACY)\n"
"layout( location = 0 ) out vec4 a_Color;\n"
"#endif\n"
"\n"
"in vec2 v_TexCoords;\n"
"in vec4 v_Color;\n"
"\n"
"uniform sampler2D u_DiffuseMap;\n"
"uniform float u_GammaAmount;\n"
"uniform vec2 u_ScreenSize;\n"
"uniform float u_SharpenAmount;\n"
"uniform bool u_HardwareGamma;\n"
"uniform bool u_GamePaused;\n"
"uniform int u_AntiAliasing;\n"
"\n"
"\n"
"void texcoords( vec2 fragCoord, vec2 resolution, out vec2 v_rgbNW, out vec2 v_rgbNE, out vec2 v_rgbSW,\n"
"	out vec2 v_rgbSE, out vec2 v_rgbM )\n"
"{\n"
"	vec2 inverseVP = 1.0 / resolution.xy;\n"
"	v_rgbNW = ( fragCoord + vec2( -1.0, -1.0 ) ) * inverseVP;\n"
"	v_rgbNE = ( fragCoord + vec2( 1.0, -1.0 ) ) * inverseVP;\n"
"	v_rgbSW = ( fragCoord + vec2( -1.0, 1.0 ) ) * inverseVP;\n"
"	v_rgbSE = ( fragCoord + vec2( 1.0, 1.0 ) ) * inverseVP;\n"
"	v_rgbM = vec2( fragCoord * inverseVP );\n"
"}\n"
"\n"
"#ifndef FXAA_REDUCE_MIN\n"
"    #define FXAA_REDUCE_MIN   (1.0/ 128.0)\n"
"#endif\n"
"#ifndef FXAA_REDUCE_MUL\n"
"    #define FXAA_REDUCE_MUL   (1.0 / 8.0)\n"
"#endif\n"
"#ifndef FXAA_SPAN_MAX\n"
"    #define FXAA_SPAN_MAX     8.0\n"
"#endif\n"
"\n"
"//optimized version for mobile, where dependent\n"
"//texture reads can be a bottleneck\n"
"vec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 resolution,\n"
"            vec2 v_rgbNW, vec2 v_rgbNE,\n"
"            vec2 v_rgbSW, vec2 v_rgbSE,\n"
"            vec2 v_rgbM) {\n"
"    vec4 color;\n"
"    vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);\n"
"    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\n"
"    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\n"
"    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\n"
"    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\n"
"    vec4 texColor = texture2D(tex, v_rgbM);\n"
"    vec3 rgbM  = texColor.xyz;\n"
"    vec3 luma = vec3(0.299, 0.587, 0.114);\n"
"    float lumaNW = dot(rgbNW, luma);\n"
"    float lumaNE = dot(rgbNE, luma);\n"
"    float lumaSW = dot(rgbSW, luma);\n"
"    float lumaSE = dot(rgbSE, luma);\n"
"    float lumaM  = dot(rgbM,  luma);\n"
"    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n"
"    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n"
"\n"
"    vec2 dir;\n"
"    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n"
"    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n"
"\n"
"    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n"
"                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n"
"\n"
"    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n"
"    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n"
"              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n"
"              dir * rcpDirMin)) * inverseVP;\n"
"\n"
"    vec3 rgbA = 0.5 * (\n"
"        texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\n"
"        texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n"
"    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n"
"        texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\n"
"        texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n"
"\n"
"    float lumaB = dot(rgbB, luma);\n"
"    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n"
"        color = vec4(rgbA, texColor.a);\n"
"    else\n"
"        color = vec4(rgbB, texColor.a);\n"
"    return color;\n"
"}\n"
"\n"
"vec4 applyFXAA( sampler2D tex, vec2 fragCoord, vec2 resolution ) {\n"
"	vec2 v_rgbNW;\n"
"	vec2 v_rgbNE;\n"
"	vec2 v_rgbSW;\n"
"	vec2 v_rgbSE;\n"
"	vec2 v_rgbM;\n"
"\n"
"	texcoords( fragCoord, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM );\n"
"\n"
"	return fxaa( tex, fragCoord, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM );\n"
"}\n"
"\n"
"#define sharp_clamp 20.000  //[0.000 to 1.000] Limits maximum amount of sharpening a pixel recieves - Default is 0.035\n"
"\n"
"// -- Advanced sharpening settings --\n"
"\n"
"#define offset_bias 6.0  //[0.0 to 6.0] Offset bias adjusts the radius of the sampling pattern.\n"
"                         //I designed the pattern for offset_bias 1.0, but feel free to experiment.\n"
"\n"
"//#define CoefLuma vec3( 0.2126, 0.7152, 0.0722 )      // BT.709 & sRBG luma coefficient (Monitors and HD Television)\n"
"//#define CoefLuma vec3( 0.299, 0.587, 0.114 )       // BT.601 luma coefficient (SD Television)\n"
"#define CoefLuma vec3( 1.0/3.0, 1.0/3.0, 1.0/3.0 ) // Equal weight coefficient\n"
"\n"
"vec4 sharpenImage( sampler2D tex, vec2 pos )\n"
"{\n"
"	vec4 colorInput = texture2D(tex, pos);\n"
"\n"
"	vec3 ori = colorInput.rgb;\n"
"\n"
"	// -- Combining the strength and luma multipliers --\n"
"	vec3 sharp_strength_luma = (CoefLuma * u_SharpenAmount); //I\'ll be combining even more multipliers with it later on\n"
"\n"
"	// -- Gaussian filter --\n"
"	//   [ .25, .50, .25]     [ 1 , 2 , 1 ]\n"
"	//   [ .50,   1, .50]  =  [ 2 , 4 , 2 ]\n"
" 	//   [ .25, .50, .25]     [ 1 , 2 , 1 ]\n"
"\n"
"    float px = 1.0/u_ScreenSize[0];\n"
"	float py = 1.0/u_ScreenSize[1];\n"
"\n"
"	vec3 blur_ori = texture2D(tex, pos + vec2(px,-py) * 0.5 * offset_bias).rgb; // South East\n"
"	blur_ori += texture2D(tex, pos + vec2(-px,-py) * 0.5 * offset_bias).rgb;  // South West\n"
"	blur_ori += texture2D(tex, pos + vec2(px,py) * 0.5 * offset_bias).rgb; // North East\n"
"	blur_ori += texture2D(tex, pos + vec2(-px,py) * 0.5 * offset_bias).rgb; // North West\n"
"\n"
"	blur_ori *= 0.25;  // ( /= 4) Divide by the number of texture fetches\n"
"\n"
"	// -- Calculate the sharpening --\n"
"	vec3 sharp = ori - blur_ori;  //Subtracting the blurred image from the original image\n"
"\n"
"	// -- Adjust strength of the sharpening and clamp it--\n"
"	vec4 sharp_strength_luma_clamp = vec4(sharp_strength_luma * (0.5 / sharp_clamp),0.5); //Roll part of the clamp into the dot\n"
"\n"
"	float sharp_luma = clamp((dot(vec4(sharp,1.0), sharp_strength_luma_clamp)), 0.0,1.0 ); //Calculate the luma, adjust the strength, scale up and clamp\n"
"	sharp_luma = (sharp_clamp * 2.0) * sharp_luma - sharp_clamp; //scale down\n"
"\n"
"\n"
"	// -- Combining the values to get the final sharpened pixel	--\n"
"\n"
"	colorInput.rgb = colorInput.rgb + sharp_luma;    // Add the sharpening to the input color.\n"
"	return clamp(colorInput, 0.0,1.0);\n"
"}\n"
"\n"
"void main() {\n"
"	if ( u_AntiAliasing == AntiAlias_FXAA ) {\n"
"		vec2 fragCoord = v_TexCoords * u_ScreenSize;\n"
"        a_Color = v_Color * applyFXAA( u_DiffuseMap, fragCoord, u_ScreenSize );\n"
"	} else {\n"
"	    a_Color = v_Color * sharpenImage( u_DiffuseMap, v_TexCoords );\n"
"	}\n"
"\n"
"\n"
"    a_Color.rgb = pow( a_Color.rgb, vec3( 1.0 / u_GammaAmount ) );\n"
"\n"
"    if ( u_GamePaused ) {\n"
"        a_Color.rgb *= vec3( 0.75, 0.75, 0.75 );\n"
"    }\n"
"}\n"
;

const char *fallbackShader_bokeh_vp =
"in vec3 a_Position;\n"
"in vec4 a_LightCoords;\n"
"\n"
"uniform mat4 u_ModelViewProjection;\n"
"\n"
"out vec2 v_TexCoords;\n"
"\n"
"void main() {\n"
"	gl_Position = u_ModelViewProjection * vec4( a_Position, 1.0 );\n"
"	v_TexCoords = a_LightCoords.st;\n"
"}\n"
;

const char *fallbackShader_depthblur_fp =
"#if !defined(GLSL_LEGACY)\n"
"out vec4 a_Color;\n"
"#endif\n"
"\n"
"uniform sampler2D u_ScreenImageMap;\n"
"uniform sampler2D u_ScreenDepthMap;\n"
"\n"
"uniform vec4 u_ViewInfo; // zfar / znear, zfar, 1/width, 1/height\n"
"in vec2 v_ScreenTex;\n"
"\n"
"//float gauss[8] = float[8](0.17, 0.17, 0.16, 0.14, 0.12, 0.1, 0.08, 0.06);\n"
"//float gauss[5] = float[5](0.30, 0.23, 0.097, 0.024, 0.0033);\n"
"//float gauss[4] = float[4](0.40, 0.24, 0.054, 0.0044);\n"
"//float gauss[3] = float[3](0.60, 0.19, 0.0066);\n"
"#define BLUR_SIZE 4\n"
"\n"
"#if !defined(USE_DEPTH)\n"
"//#define USE_GAUSS\n"
"#endif\n"
"\n"
"float getLinearDepth(sampler2D depthMap, const vec2 tex, const float zFarDivZNear) {\n"
"	float sampleZDivW = texture2D(depthMap, tex).r;\n"
"	return 1.0 / mix(zFarDivZNear, 1.0, sampleZDivW);\n"
"}\n"
"\n"
"vec4 depthGaussian1D(sampler2D imageMap, sampler2D depthMap, vec2 tex, float zFarDivZNear, float zFar, vec2 scale)\n"
"{\n"
"	float gauss[4];\n"
"\n"
"	gauss[0] = 0.40;\n"
"	gauss[1] = 0.24;\n"
"	gauss[2] = 0.054;\n"
"	gauss[3] = 0.0044;\n"
"\n"
"#if defined(USE_DEPTH)\n"
"	float depthCenter = getLinearDepth(depthMap, tex, zFarDivZNear);\n"
"	vec2 slope = vec2(dFdx(depthCenter), dFdy(depthCenter)) / vec2(dFdx(tex.x), dFdy(tex.y));\n"
"	scale /= clamp(zFarDivZNear * depthCenter / 32.0, 1.0, 2.0);\n"
"#endif\n"
"\n"
"#if defined(USE_HORIZONTAL_BLUR)\n"
"	vec2 direction = vec2(scale.x * 2.0, 0.0);\n"
"	vec2 nudge = vec2(0.0, scale.y * 0.5);\n"
"#else // if defined(USE_VERTICAL_BLUR)\n"
"	vec2 direction = vec2(0.0, scale.y * 2.0);\n"
"	vec2 nudge = vec2(-scale.x * 0.5, 0.0);\n"
"#endif\n"
"\n"
"#if defined(USE_GAUSS)\n"
"	vec4 result = texture2D(imageMap, tex) * gauss[0];\n"
"	float total = gauss[0];\n"
"#else\n"
"	vec4 result = texture2D(imageMap, tex);\n"
"	float total = 1.0;\n"
"#endif\n"
"\n"
"	float zLimit = 5.0 / zFar;\n"
"	int i, j;\n"
"	for (i = 0; i < 2; i++)\n"
"	{\n"
"		for (j = 1; j < BLUR_SIZE; j++)\n"
"		{\n"
"			vec2 offset = direction * (float(j) - 0.25) + nudge;\n"
"#if defined(USE_DEPTH)\n"
"			float depthSample = getLinearDepth(depthMap, tex + offset, zFarDivZNear);\n"
"			float depthExpected = depthCenter + dot(slope, offset);\n"
"			float useSample = float(abs(depthSample - depthExpected) < zLimit);\n"
"#else\n"
"			float useSample = 1.0;\n"
"#endif\n"
"#if defined(USE_GAUSS)\n"
"			result += texture2D(imageMap, tex + offset) * (gauss[j] * useSample);\n"
"			total += gauss[j] * useSample;\n"
"#else\n"
"			result += texture2D(imageMap, tex + offset) * useSample;\n"
"			total += useSample;\n"
"#endif\n"
"			nudge = -nudge;\n"
"		}\n"
"\n"
"		direction = -direction;\n"
"		nudge = -nudge;\n"
"	}\n"
"\n"
"	return result / total;\n"
"}\n"
"\n"
"void main() {\n"
"	a_Color = depthGaussian1D(u_ScreenImageMap, u_ScreenDepthMap, v_ScreenTex, u_ViewInfo.x, u_ViewInfo.y, u_ViewInfo.zw);\n"
"}\n"
;

const char *fallbackShader_bokeh_fp =
"#if !defined(GLSL_LEGACY)\n"
"out vec4 a_Color;\n"
"#endif\n"
"\n"
"uniform sampler2D u_TextureMap;\n"
"\n"
"uniform vec4 u_Color;\n"
"uniform vec2 u_InvTexRes;\n"
"\n"
"in vec2 v_TexCoords;\n"
"\n"
"void main()\n"
"{\n"
"	vec4 color;\n"
"	vec2 tc;\n"
"\n"
"#if 0\n"
"	float c[7];\n"
"\n"
"	c[0] = 1.0;\n"
"	c[1] = 0.9659258263;\n"
"	c[2] = 0.8660254038;\n"
"	c[3] = 0.7071067812;\n"
"	c[4] = 0.5;\n"
"	c[5] = 0.2588190451;\n"
"	c[6] = 0.0;\n"
"\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[0],  c[6]);  color =  texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[1],  c[5]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[2],  c[4]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[3],  c[3]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[4],  c[2]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[5],  c[1]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[6],  c[0]);  color += texture2D(u_TextureMap, tc);\n"
"\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[1], -c[5]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[2], -c[4]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[3], -c[3]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[4], -c[2]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[5], -c[1]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[6], -c[0]);  color += texture2D(u_TextureMap, tc);\n"
"\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( -c[0],  c[6]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( -c[1],  c[5]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( -c[2],  c[4]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( -c[3],  c[3]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( -c[4],  c[2]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( -c[5],  c[1]);  color += texture2D(u_TextureMap, tc);\n"
"\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( -c[1], -c[5]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( -c[2], -c[4]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( -c[3], -c[3]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( -c[4], -c[2]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( -c[5], -c[1]);  color += texture2D(u_TextureMap, tc);\n"
"\n"
"	a_Color = color * 0.04166667 * u_Color;\n"
"#endif\n"
"\n"
"	float c[5];\n"
"\n"
"	c[0] = 1.0;\n"
"	c[1] = 0.9238795325;\n"
"	c[2] = 0.7071067812;\n"
"	c[3] = 0.3826834324;\n"
"	c[4] = 0.0;\n"
"\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[0],  c[4]);  color =  texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[1],  c[3]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[2],  c[2]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[3],  c[1]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[4],  c[0]);  color += texture2D(u_TextureMap, tc);\n"
"\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[1], -c[3]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[2], -c[2]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[3], -c[1]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[4], -c[0]);  color += texture2D(u_TextureMap, tc);\n"
"\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( -c[0],  c[4]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( -c[1],  c[3]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( -c[2],  c[2]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( -c[3],  c[1]);  color += texture2D(u_TextureMap, tc);\n"
"\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( -c[1], -c[3]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( -c[2], -c[2]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( -c[3], -c[1]);  color += texture2D(u_TextureMap, tc);\n"
"\n"
"	a_Color = color * 0.0625 * u_Color;\n"
"}\n"
;

const char *fallbackShader_calclevels4x_fp =
"#if !defined(GLSL_LEGACY)\n"
"out vec4 a_Color;\n"
"#endif\n"
"\n"
"uniform sampler2D u_TextureMap;\n"
"\n"
"uniform vec4 u_Color;\n"
"uniform vec2 u_InvTexRes;\n"
"\n"
"in vec2 v_TexCoords;\n"
"\n"
"const vec3 LUMINANCE_VECTOR = vec3(0.2125, 0.7154, 0.0721); //vec3(0.299, 0.587, 0.114);\n"
"\n"
"vec3 GetValues( vec2 offset, vec3 current )\n"
"{\n"
"	vec2 tc = v_TexCoords + u_InvTexRes * offset;\n"
"	vec3 minAvgMax = texture2D( u_TextureMap, tc ).rgb;\n"
"\n"
"#ifdef FIRST_PASS\n"
"  #if defined(USE_PBR)\n"
"	minAvgMax *= minAvgMax;\n"
"  #endif\n"
"\n"
"	float lumi = max(dot(LUMINANCE_VECTOR, minAvgMax), 0.000001);\n"
"	float loglumi = clamp(log2(lumi), -10.0, 10.0);\n"
"	minAvgMax = vec3(loglumi * 0.05 + 0.5);\n"
"#endif\n"
"\n"
"	return vec3(min(current.x, minAvgMax.x), current.y + minAvgMax.y, max(current.z, minAvgMax.z));\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"	vec3 current = vec3(1.0, 0.0, 0.0);\n"
"\n"
"#ifdef FIRST_PASS\n"
"	current = GetValues(vec2( 0.0,  0.0), current);\n"
"#else\n"
"	current = GetValues(vec2(-1.5, -1.5), current);\n"
"	current = GetValues(vec2(-0.5, -1.5), current);\n"
"	current = GetValues(vec2( 0.5, -1.5), current);\n"
"	current = GetValues(vec2( 1.5, -1.5), current);\n"
"\n"
"	current = GetValues(vec2(-1.5, -0.5), current);\n"
"	current = GetValues(vec2(-0.5, -0.5), current);\n"
"	current = GetValues(vec2( 0.5, -0.5), current);\n"
"	current = GetValues(vec2( 1.5, -0.5), current);\n"
"\n"
"	current = GetValues(vec2(-1.5,  0.5), current);\n"
"	current = GetValues(vec2(-0.5,  0.5), current);\n"
"	current = GetValues(vec2( 0.5,  0.5), current);\n"
"	current = GetValues(vec2( 1.5,  0.5), current);\n"
"\n"
"	current = GetValues(vec2(-1.5,  1.5), current);\n"
"	current = GetValues(vec2(-0.5,  1.5), current);\n"
"	current = GetValues(vec2( 0.5,  1.5), current);\n"
"	current = GetValues(vec2( 1.5,  1.5), current);\n"
"\n"
"	current.y *= 0.0625;\n"
"#endif\n"
"\n"
"	a_Color = vec4(current, 1.0);\n"
"}\n"
;

const char *fallbackShader_lightall_fp =
"#if !defined(GLSL_LEGACY)\n"
"out vec4 a_Color;\n"
"#endif\n"
"\n"
"uniform sampler2D u_DiffuseMap;\n"
"\n"
"#if defined(USE_LIGHTMAP)\n"
"uniform sampler2D u_LightMap;\n"
"#endif\n"
"\n"
"#if defined(USE_NORMALMAP)\n"
"uniform sampler2D u_NormalMap;\n"
"#endif\n"
"\n"
"#if defined(USE_DELUXEMAP)\n"
"uniform sampler2D u_DeluxeMap;\n"
"#endif\n"
"\n"
"#if defined(USE_SPECULARMAP)\n"
"uniform sampler2D u_SpecularMap;\n"
"#endif\n"
"\n"
"#if defined(USE_SHADOWMAP)\n"
"uniform sampler2D u_ShadowMap;\n"
"#endif\n"
"\n"
"#if defined(USE_CUBEMAP)\n"
"uniform samplerCube u_CubeMap;\n"
"#endif\n"
"\n"
"#if defined(USE_NORMALMAP) || defined(USE_DELUXEMAP) || defined(USE_SPECULARMAP) || defined(USE_CUBEMAP)\n"
"// y = deluxe, w = cube\n"
"uniform vec4      u_EnableTextures;\n"
"#endif\n"
"\n"
"#if defined(USE_PRIMARY_LIGHT) || defined(USE_SHADOWMAP)\n"
"uniform vec3  u_PrimaryLightColor;\n"
"uniform vec3  u_PrimaryLightAmbient;\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"uniform vec4      u_NormalScale;\n"
"uniform vec4      u_SpecularScale;\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"#if defined(USE_CUBEMAP)\n"
"uniform vec4      u_CubeMapInfo;\n"
"#endif\n"
"#endif\n"
"\n"
"uniform int       u_AlphaTest;\n"
"\n"
"in vec4      v_TexCoords;\n"
"\n"
"in vec4      v_Color;\n"
"#if (defined(USE_LIGHT) && !defined(USE_FAST_LIGHT))\n"
"in vec4      v_ColorAmbient;\n"
"\n"
"struct Light {\n"
"    vec4 color;\n"
"    uvec2 origin;\n"
"    float brightness;\n"
"    float range;\n"
"    float linear;\n"
"    float quadratic;\n"
"    float constant;\n"
"    int type;\n"
"};\n"
"layout( std140, binding = 0 ) uniform u_LightBuffer {\n"
"    Light u_LightData[MAX_MAP_LIGHTS];\n"
"};\n"
"#endif\n"
"\n"
"#if (defined(USE_LIGHT) && !defined(USE_FAST_LIGHT))\n"
"in vec4   v_Normal;\n"
"in vec4   v_Tangent;\n"
"in vec4   v_Bitangent;\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"in vec4      v_LightDir;\n"
"#endif\n"
"\n"
"#if defined(USE_PRIMARY_LIGHT) || defined(USE_SHADOWMAP)\n"
"in vec4      v_PrimaryLightDir;\n"
"#endif\n"
"\n"
"\n"
"#define EPSILON 0.00000001\n"
"\n"
"#if defined(USE_PARALLAXMAP)\n"
"float SampleDepth(sampler2D normalMap, vec2 t)\n"
"{\n"
"  #if defined(SWIZZLE_NORMALMAP)\n"
"	return 1.0 - texture2D(normalMap, t).r;\n"
"  #else\n"
"	return 1.0 - texture2D(normalMap, t).a;\n"
"  #endif\n"
"}\n"
"\n"
"float RayIntersectDisplaceMap(vec2 dp, vec2 ds, sampler2D normalMap)\n"
"{\n"
"	const int linearSearchSteps = 16;\n"
"	const int binarySearchSteps = 6;\n"
"\n"
"	// current size of search window\n"
"	float size = 1.0 / float(linearSearchSteps);\n"
"\n"
"	// adjust position if offset above surface\n"
"	dp -= ds * r_parallaxMapOffset;\n"
"	// current depth position\n"
"	float depth = 0.0;\n"
"\n"
"	// best match found (starts with last position 1.0)\n"
"	float bestDepth = 1.0;\n"
"\n"
"	// texture depth at best depth\n"
"	float texDepth = 0.0;\n"
"\n"
"	float prevT = SampleDepth(normalMap, dp);\n"
"	float prevTexDepth = prevT;\n"
"\n"
"	// search front to back for first point inside object\n"
"	for(int i = 0; i < linearSearchSteps - 1; ++i)\n"
"	{\n"
"		depth += size;\n"
"\n"
"		float t = SampleDepth(normalMap, dp + ds * depth);\n"
"\n"
"		if(bestDepth > 0.996)		// if no depth found yet\n"
"			if(depth >= t)\n"
"			{\n"
"				bestDepth = depth;	// store best depth\n"
"				texDepth = t;\n"
"				prevTexDepth = prevT;\n"
"			}\n"
"		prevT = t;\n"
"	}\n"
"\n"
"	depth = bestDepth;\n"
"\n"
"#if !defined (USE_RELIEFMAP)\n"
"	float div = 1.0 / (1.0 + (prevTexDepth - texDepth) * float(linearSearchSteps));\n"
"	bestDepth -= (depth - size - prevTexDepth) * div;\n"
"#else\n"
"	// recurse around first point (depth) for closest match\n"
"	for(int i = 0; i < binarySearchSteps; ++i)\n"
"	{\n"
"		size *= 0.5;\n"
"\n"
"		float t = SampleDepth(normalMap, dp + ds * depth);\n"
"\n"
"		if(depth >= t)\n"
"		{\n"
"			bestDepth = depth;\n"
"			depth -= 2.0 * size;\n"
"		}\n"
"\n"
"		depth += size;\n"
"	}\n"
"#endif\n"
"\n"
"	return bestDepth - r_parallaxMapOffset;\n"
"}\n"
"\n"
"float LightRay(vec2 dp, vec2 ds, sampler2D normalMap)\n"
"{\n"
"	const int linearSearchSteps = 16;\n"
"\n"
"	// current height from initial texel depth\n"
"	float height = 0.0;\n"
"\n"
"	float startDepth = SampleDepth(normalMap, dp);\n"
"\n"
"	// size of search window\n"
"	float size = startDepth / float(linearSearchSteps);\n"
"\n"
"	// find a collision or escape\n"
"	for(int i = 0; i < linearSearchSteps - 1; ++i)\n"
"	{\n"
"		height += size;\n"
"\n"
"		float t = SampleDepth(normalMap, dp + ds * height);\n"
"\n"
"		if (startDepth > t + height)\n"
"			return 0.0;\n"
"	}\n"
"\n"
"	return 1.0;\n"
"}\n"
"#endif\n"
"\n"
"vec3 CalcDiffuse(vec3 diffuseAlbedo, float NH, float EH, float roughness)\n"
"{\n"
"#if defined(USE_BURLEY)\n"
"	// modified from https://disney-animation.s3.amazonaws.com/library/s2012_pbs_disney_brdf_notes_v2.pdf\n"
"	float fd90 = -0.5 + EH * EH * roughness;\n"
"	float burley = 1.0 + fd90 * 0.04 / NH;\n"
"	burley *= burley;\n"
"	return diffuseAlbedo * burley;\n"
"#else\n"
"	return diffuseAlbedo;\n"
"#endif\n"
"}\n"
"\n"
"vec3 EnvironmentBRDF(float roughness, float NE, vec3 specular)\n"
"{\n"
"	// from http://community.arm.com/servlet/JiveServlet/download/96891546-19496/siggraph2015-mmg-renaldas-slides.pdf\n"
"	float v = 1.0 - max(roughness, NE);\n"
"	v *= v * v;\n"
"	return vec3(v) + specular;\n"
"}\n"
"\n"
"vec3 CalcSpecular(vec3 specular, float NH, float EH, float roughness)\n"
"{\n"
"	// from http://community.arm.com/servlet/JiveServlet/download/96891546-19496/siggraph2015-mmg-renaldas-slides.pdf\n"
"	float rr = roughness*roughness;\n"
"	float rrrr = rr*rr;\n"
"	float d = (NH * NH) * (rrrr - 1.0) + 1.0;\n"
"	float v = (EH * EH) * (roughness + 0.5) + EPSILON;\n"
"	return specular * (rrrr / (4.0 * d * d * v));\n"
"}\n"
"\n"
"\n"
"float CalcLightAttenuation(float point, float normDist)\n"
"{\n"
"	// zero light at 1.0, approximating q3 style\n"
"	// also don\'t attenuate directional light\n"
"	float attenuation = (0.5 * normDist - 1.5) * point + 1.0;\n"
"\n"
"	// clamp attenuation\n"
"	#if defined(NO_LIGHT_CLAMP)\n"
"	attenuation = max(attenuation, 0.0);\n"
"	#else\n"
"	attenuation = clamp(attenuation, 0.0, 1.0);\n"
"	#endif\n"
"\n"
"	return attenuation;\n"
"}\n"
"\n"
"#if defined(USE_BOX_CUBEMAP_PARALLAX)\n"
"vec4 hitCube(vec3 ray, vec3 pos, vec3 invSize, float lod, samplerCube tex)\n"
"{\n"
"	// find any hits on cubemap faces facing the camera\n"
"	vec3 scale = (sign(ray) - pos) / ray;\n"
"\n"
"	// find the nearest hit\n"
"	float minScale = min(min(scale.x, scale.y), scale.z);\n"
"\n"
"	// if the nearest hit is behind the camera, ignore\n"
"	// should not be necessary as long as pos is inside the cube\n"
"	//if (minScale < 0.0)\n"
"		//return vec4(0.0);\n"
"\n"
"	// calculate the hit position, that\'s our texture coordinates\n"
"	vec3 tc = pos + ray * minScale;\n"
"\n"
"	// if the texture coordinates are outside the cube, ignore\n"
"	// necessary since we\'re not fading out outside the cube\n"
"	if (any(greaterThan(abs(tc), vec3(1.00001))))\n"
"		return vec4(0.0);\n"
"\n"
"	// fade out when approaching the cubemap edges\n"
"	//vec3 fade3 = abs(pos);\n"
"	//float fade = max(max(fade3.x, fade3.y), fade3.z);\n"
"	//fade = clamp(1.0 - fade, 0.0, 1.0);\n"
"\n"
"	//return vec4(textureCubeLod(tex, tc, lod).rgb * fade, fade);\n"
"	return vec4(textureCubeLod(tex, tc, lod).rgb, 1.0);\n"
"}\n"
"#endif\n"
"\n"
"void main()\n"
"{\n"
"	vec3 viewDir, lightColor, ambientColor, reflectance;\n"
"	vec3 L, N, E, H;\n"
"	float NL, NH, NE, EH, attenuation;\n"
"\n"
"#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"	mat3 tangentToWorld = mat3(v_Tangent.xyz, v_Bitangent.xyz, v_Normal.xyz);\n"
"	viewDir = vec3(v_Normal.w, v_Tangent.w, v_Bitangent.w);\n"
"	E = normalize(viewDir);\n"
"#endif\n"
"\n"
"	lightColor = v_Color.rgb;\n"
"\n"
"#if defined(USE_LIGHTMAP)\n"
"	vec4 lightmapColor = texture2D(u_LightMap, v_TexCoords.zw);\n"
"  #if defined(RGBM_LIGHTMAP)\n"
"	lightmapColor.rgb *= lightmapColor.a;\n"
"  #endif\n"
"  #if defined(USE_PBR) && !defined(USE_FAST_LIGHT)\n"
"	lightmapColor.rgb *= lightmapColor.rgb;\n"
"  #endif\n"
"	lightColor *= lightmapColor.rgb;\n"
"#endif\n"
"\n"
"	vec2 texCoords = v_TexCoords.xy;\n"
"\n"
"#if defined(USE_PARALLAXMAP)\n"
"	vec3 offsetDir = E * tangentToWorld;\n"
"\n"
"	offsetDir.xy *= -u_NormalScale.a / offsetDir.z;\n"
"\n"
"	texCoords += offsetDir.xy * RayIntersectDisplaceMap(texCoords, offsetDir.xy, u_NormalMap);\n"
"#endif\n"
"\n"
"	vec4 diffuse = texture2D(u_DiffuseMap, texCoords);\n"
"\n"
"	float alpha = diffuse.a * v_Color.a;\n"
"	if (u_AlphaTest == 1)\n"
"	{\n"
"		if (alpha == 0.0)\n"
"			discard;\n"
"	}\n"
"	else if (u_AlphaTest == 2)\n"
"	{\n"
"		if (alpha >= 0.5)\n"
"			discard;\n"
"	}\n"
"	else if (u_AlphaTest == 3)\n"
"	{\n"
"		if (alpha < 0.5)\n"
"			discard;\n"
"	}\n"
"\n"
"#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"	L = v_LightDir.xyz;\n"
"  #if defined(USE_DELUXEMAP)\n"
"	L += (texture2D(u_DeluxeMap, v_TexCoords.zw).xyz - vec3(0.5)) * u_EnableTextures.y;\n"
"  #endif\n"
"	float sqrLightDist = dot(L, L);\n"
"	L /= sqrt(sqrLightDist);\n"
"\n"
"  #if defined(USE_LIGHT_VECTOR)\n"
"	attenuation  = CalcLightAttenuation(float(v_LightDir.w > 0.0), v_LightDir.w / sqrLightDist);\n"
"  #else\n"
"	attenuation  = 1.0;\n"
"  #endif\n"
"\n"
"  #if defined(USE_NORMALMAP)\n"
"    #if defined(SWIZZLE_NORMALMAP)\n"
"	N.xy = texture2D(u_NormalMap, texCoords).ag - vec2(0.5);\n"
"    #else\n"
"	N.xy = texture2D(u_NormalMap, texCoords).rg - vec2(0.5);\n"
"    #endif\n"
"	N.xy *= u_NormalScale.xy;\n"
"	N.z = sqrt(clamp((0.25 - N.x * N.x) - N.y * N.y, 0.0, 1.0));\n"
"	N = tangentToWorld * N;\n"
"  #else\n"
"	N = v_Normal.xyz;\n"
"  #endif\n"
"\n"
"	N = normalize(N);\n"
"\n"
"  #if defined(USE_SHADOWMAP)\n"
"	vec2 shadowTex = gl_FragCoord.xy * r_FBufScale;\n"
"	float shadowValue = texture2D(u_ShadowMap, shadowTex).r;\n"
"\n"
"	// surfaces not facing the light are always shadowed\n"
"	shadowValue *= clamp(dot(N, v_PrimaryLightDir.xyz), 0.0, 1.0);\n"
"\n"
"    #if defined(SHADOWMAP_MODULATE)\n"
"	lightColor *= shadowValue * (1.0 - u_PrimaryLightAmbient.r) + u_PrimaryLightAmbient.r;\n"
"    #endif\n"
"  #endif\n"
"\n"
"  #if defined(USE_PARALLAXMAP) && defined(USE_PARALLAXMAP_SHADOWS)\n"
"	offsetDir = L * tangentToWorld;\n"
"	offsetDir.xy *= u_NormalScale.a / offsetDir.z;\n"
"	lightColor *= LightRay(texCoords, offsetDir.xy, u_NormalMap);\n"
"  #endif\n"
"\n"
"\n"
"  #if !defined(USE_LIGHT_VECTOR)\n"
"	ambientColor = lightColor;\n"
"	float surfNL = clamp(dot(v_Normal.xyz, L), 0.0, 1.0);\n"
"\n"
"	// reserve 25% ambient to avoid black areas on normalmaps\n"
"	lightColor *= 0.75;\n"
"\n"
"	// Scale the incoming light to compensate for the baked-in light angle\n"
"	// attenuation.\n"
"	lightColor /= max(surfNL, 0.25);\n"
"\n"
"	// Recover any unused light as ambient, in case attenuation is over 4x or\n"
"	// light is below the surface\n"
"	ambientColor = max(ambientColor - lightColor * surfNL, vec3(0.0));\n"
"  #else\n"
"	ambientColor = v_ColorAmbient.rgb;\n"
"  #endif\n"
"\n"
"	NL = clamp(dot(N, L), 0.0, 1.0);\n"
"	NE = clamp(dot(N, E), 0.0, 1.0);\n"
"	H = normalize(L + E);\n"
"	EH = clamp(dot(E, H), 0.0, 1.0);\n"
"	NH = clamp(dot(N, H), 0.0, 1.0);\n"
"\n"
"  #if defined(USE_SPECULARMAP)\n"
"	vec4 specular = texture2D(u_SpecularMap, texCoords);\n"
"  #else\n"
"	vec4 specular = vec4(1.0);\n"
"  #endif\n"
"	specular *= u_SpecularScale;\n"
"\n"
"  #if defined(USE_PBR)\n"
"	diffuse.rgb *= diffuse.rgb;\n"
"  #endif\n"
"\n"
"  #if defined(USE_PBR)\n"
"	// diffuse rgb is base color\n"
"	// specular red is gloss\n"
"	// specular green is metallicness\n"
"	float gloss = specular.r;\n"
"	float metal = specular.g;\n"
"	specular.rgb = metal * diffuse.rgb + vec3(0.04 - 0.04 * metal);\n"
"	diffuse.rgb *= 1.0 - metal;\n"
"  #else\n"
"	// diffuse rgb is diffuse\n"
"	// specular rgb is specular reflectance at normal incidence\n"
"	// specular alpha is gloss\n"
"	float gloss = specular.a;\n"
"\n"
"	// adjust diffuse by specular reflectance, to maintain energy conservation\n"
"	diffuse.rgb *= vec3(1.0) - specular.rgb;\n"
"  #endif\n"
"\n"
"  #if defined(GLOSS_IS_GLOSS)\n"
"	float roughness = exp2(-3.0 * gloss);\n"
"  #elif defined(GLOSS_IS_SMOOTHNESS)\n"
"	float roughness = 1.0 - gloss;\n"
"  #elif defined(GLOSS_IS_ROUGHNESS)\n"
"	float roughness = gloss;\n"
"  #elif defined(GLOSS_IS_SHININESS)\n"
"	float roughness = pow(2.0 / (8190.0 * gloss + 2.0), 0.25);\n"
"  #endif\n"
"\n"
"	reflectance  = CalcDiffuse(diffuse.rgb, NH, EH, roughness);\n"
"\n"
"  #if defined(r_deluxeSpecular)\n"
"    #if defined(USE_LIGHT_VECTOR)\n"
"	reflectance += CalcSpecular(specular.rgb, NH, EH, roughness) * r_deluxeSpecular;\n"
"    #else\n"
"	reflectance += CalcSpecular(specular.rgb, NH, EH, pow(roughness, r_deluxeSpecular));\n"
"    #endif\n"
"  #endif\n"
"\n"
"	a_Color.rgb  = lightColor   * reflectance * (attenuation * NL);\n"
"	a_Color.rgb += ambientColor * diffuse.rgb;\n"
"\n"
"  #if defined(USE_CUBEMAP)\n"
"	reflectance = EnvironmentBRDF(roughness, NE, specular.rgb);\n"
"\n"
"	vec3 R = reflect(E, N);\n"
"\n"
"	// parallax corrected cubemap (cheaper trick)\n"
"	// from http://seblagarde.wordpress.com/2012/09/29/image-based-lighting-approaches-and-parallax-corrected-cubemap/\n"
"	vec3 parallax = u_CubeMapInfo.xyz + u_CubeMapInfo.w * viewDir;\n"
"\n"
"  #if defined(USE_BOX_CUBEMAP_PARALLAX)\n"
"	vec3 cubeLightColor = hitCube(R * u_CubeMapInfo.w, parallax, u_CubeMapInfo.www, ROUGHNESS_MIPS * roughness, u_CubeMap).rgb * u_EnableTextures.w;\n"
"  #else\n"
"	vec3 cubeLightColor = textureCubeLod(u_CubeMap, R + parallax, ROUGHNESS_MIPS * roughness).rgb * u_EnableTextures.w;\n"
"  #endif\n"
"\n"
"	// normalize cubemap based on last roughness mip (~diffuse)\n"
"	// multiplying cubemap values by lighting below depends on either this or the cubemap being normalized at generation\n"
"	//vec3 cubeLightDiffuse = max(textureCubeLod(u_CubeMap, N, ROUGHNESS_MIPS).rgb, 0.5 / 255.0);\n"
"	//cubeLightColor /= dot(cubeLightDiffuse, vec3(0.2125, 0.7154, 0.0721));\n"
"\n"
"    #if defined(USE_PBR)\n"
"	cubeLightColor *= cubeLightColor;\n"
"    #endif\n"
"\n"
"	// multiply cubemap values by lighting\n"
"	// not technically correct, but helps make reflections look less unnatural\n"
"	//cubeLightColor *= lightColor * (attenuation * NL) + ambientColor;\n"
"\n"
"	a_Color.rgb += cubeLightColor * reflectance;\n"
"  #endif\n"
"\n"
"  #if defined(USE_PRIMARY_LIGHT) || defined(SHADOWMAP_MODULATE)\n"
"	vec3 L2, H2;\n"
"	float NL2, EH2, NH2;\n"
"\n"
"	L2 = v_PrimaryLightDir.xyz;\n"
"\n"
"	// enable when point lights are supported as primary lights\n"
"	//sqrLightDist = dot(L2, L2);\n"
"	//L2 /= sqrt(sqrLightDist);\n"
"\n"
"	NL2 = clamp(dot(N, L2), 0.0, 1.0);\n"
"	H2 = normalize(L2 + E);\n"
"	EH2 = clamp(dot(E, H2), 0.0, 1.0);\n"
"	NH2 = clamp(dot(N, H2), 0.0, 1.0);\n"
"\n"
"	reflectance  = CalcSpecular(specular.rgb, NH2, EH2, roughness);\n"
"\n"
"	// bit of a hack, with modulated shadowmaps, ignore diffuse\n"
"    #if !defined(SHADOWMAP_MODULATE)\n"
"	reflectance += CalcDiffuse(diffuse.rgb, NH2, EH2, roughness);\n"
"    #endif\n"
"\n"
"	lightColor = u_PrimaryLightColor;\n"
"\n"
"    #if defined(USE_SHADOWMAP)\n"
"	lightColor *= shadowValue;\n"
"    #endif\n"
"\n"
"	// enable when point lights are supported as primary lights\n"
"	//lightColor *= CalcLightAttenuation(float(u_PrimaryLightDir.w > 0.0), u_PrimaryLightDir.w / sqrLightDist);\n"
"\n"
"  #if defined(USE_PARALLAXMAP) && defined(USE_PARALLAXMAP_SHADOWS)\n"
"	offsetDir = L2 * tangentToWorld;\n"
"	offsetDir.xy *= u_NormalScale.a / offsetDir.z;\n"
"	lightColor *= LightRay(texCoords, offsetDir.xy, u_NormalMap);\n"
"  #endif\n"
"\n"
"	a_Color.rgb += lightColor * reflectance * NL2;\n"
"  #endif\n"
"\n"
"  #if defined(USE_PBR)\n"
"	a_Color.rgb = sqrt(a_Color.rgb);\n"
"  #endif\n"
"\n"
"#else\n"
"\n"
"	a_Color.rgb = diffuse.rgb * lightColor;\n"
"\n"
"#endif\n"
"\n"
"	a_Color.a = alpha;\n"
"}\n"
;

const char *fallbackShader_tile_vp =
"in vec3 a_Position;\n"
"in vec2 a_TexCoords;\n"
"in vec4 a_Color;\n"
"in vec3 a_WorldPos;\n"
"\n"
"out vec2 v_TexCoords;\n"
"out vec3 v_FragPos;\n"
"out vec4 v_Color;\n"
"out vec3 v_WorldPos;\n"
"\n"
"uniform mat4 u_ModelViewProjection;\n"
"uniform vec4 u_BaseColor;\n"
"uniform vec4 u_VertColor;\n"
"\n"
"uniform mat4 u_ModelMatrix;\n"
"\n"
"#if defined(USE_RGBAGEN)\n"
"uniform int u_ColorGen;\n"
"uniform int u_AlphaGen;\n"
"uniform vec3 u_DirectedLight;\n"
"#endif\n"
"\n"
"#if defined(USE_TCGEN)\n"
"uniform vec4 u_DiffuseTexMatrix;\n"
"uniform vec4 u_DiffuseTexOffTurb;\n"
"#endif\n"
"\n"
"#if defined(USE_TCGEN)\n"
"uniform int u_TCGen0;\n"
"uniform vec3 u_TCGen0Vector0;\n"
"uniform vec3 u_TCGen0Vector1;\n"
"uniform vec3 u_WorldPos;\n"
"#endif\n"
"\n"
"#if defined(USE_RGBAGEN)\n"
"vec4 CalcColor(vec3 position, vec3 normal)\n"
"{\n"
"	vec4 color = u_VertColor * a_Color + u_BaseColor;\n"
"\n"
"	if (u_ColorGen == CGEN_LIGHTING_DIFFUSE)\n"
"	{\n"
"		float incoming = clamp(dot(normal, u_ModelLightDir), 0.0, 1.0);\n"
"\n"
"//		color.rgb = clamp(u_DirectedLight * incoming + u_AmbientLight, 0.0, 1.0);\n"
"	}\n"
"\n"
"	vec3 viewer = u_LocalViewOrigin - position;\n"
"\n"
"	if (u_AlphaGen == AGEN_LIGHTING_SPECULAR)\n"
"	{\n"
"		vec3 lightDir = normalize(vec3(-960.0, 1980.0, 96.0) - position);\n"
"		vec3 reflected = -reflect(lightDir, normal);\n"
"\n"
"		color.a = clamp(dot(reflected, normalize(viewer)), 0.0, 1.0);\n"
"		color.a *= color.a;\n"
"		color.a *= color.a;\n"
"	}\n"
"	else if (u_AlphaGen == AGEN_PORTAL)\n"
"	{\n"
"		color.a = clamp(length(viewer) / u_PortalRange, 0.0, 1.0);\n"
"	}\n"
"\n"
"	return color;\n"
"}\n"
"#endif\n"
"\n"
"#if defined(USE_TCMOD)\n"
"vec2 ModTexCoords( vec2 st, vec3 position, vec4 texMatrix, vec4 offTurb )\n"
"{\n"
"	float amplitude = offTurb.z;\n"
"	float phase = offTurb.w * 2.0 * M_PI;\n"
"	vec2 st2;\n"
"\n"
"	st2.x = st.x * texMatrix.x + ( st.y * texMatrix.z + offTurb.x );\n"
"	st2.y = st.x * texMatrix.y + ( st.y * texMatrix.w + offTurb.y );\n"
"\n"
"	vec2 offsetPos = vec2( position.x + position.z, position.y );\n"
"\n"
"	vec2 texOffset = sin( offsetPos * ( 2.0 * M_PI / 1024.0 ) + vec2( phase ) );\n"
"\n"
"	return st2 + texOffset * amplitude;\n"
"}\n"
"#endif\n"
"\n"
"float CalcLightAttenuation( float point, float normDist )\n"
"{\n"
"	// zero light at 1.0, approximating q3 style\n"
"	// also don\'t attenuate directional light\n"
"	float attenuation = ( 0.5 * normDist - 1.5 ) * point + 1.0;\n"
"\n"
"	// clamp attenuation\n"
"#if defined(NO_LIGHT_CLAMP)\n"
"	attenuation = max( attenuation, 0.0 );\n"
"#else\n"
"	attenuation = clamp( attenuation, 0.0, 1.0 );\n"
"#endif\n"
"\n"
"	return attenuation;\n"
"}\n"
"\n"
"#if defined(USE_TCGEN)\n"
"vec2 GenTexCoords( int TCGen, vec3 position, vec3 normal, vec3 TCGenVector0, vec3 TCGenVector1 )\n"
"{\n"
"	vec2 tex = a_TexCoords;\n"
"\n"
"	if ( TCGen == TCGEN_LIGHTMAP ) {\n"
"		tex = a_TexCoords.st;\n"
"	}\n"
"	else if ( TCGen == TCGEN_ENVIRONMENT_MAPPED ) {\n"
"		vec3 viewer = normalize( u_WorldPos - position );\n"
"		vec2 ref = reflect( viewer, normal ).yz;\n"
"		tex.s = ref.x * -0.5 + 0.5;\n"
"		tex.t = ref.y *  0.5 + 0.5;\n"
"	}\n"
"	else if ( TCGen == TCGEN_VECTOR ) {\n"
"		tex = vec2( dot( position, TCGenVector0 ), dot( position, TCGenVector1 ) );\n"
"	}\n"
"\n"
"	return tex;\n"
"}\n"
"#endif\n"
"\n"
"void main()\n"
"{\n"
"\n"
"#if defined(USE_TCGEN)\n"
"	vec2 texCoords = GenTexCoords( u_TCGen0, a_Position, vec3( 0.0 ), u_TCGen0Vector0, u_TCGen0Vector1 );\n"
"#else\n"
"	vec2 texCoords = a_TexCoords;\n"
"#endif\n"
"\n"
"#if defined(USE_TCMOD)\n"
"	v_TexCoords = ModTexCoords( texCoords, a_Position, u_DiffuseTexMatrix, u_DiffuseTexOffTurb );\n"
"#else\n"
"	v_TexCoords = texCoords;\n"
"#endif\n"
"    v_Color = u_VertColor * a_Color + u_BaseColor;\n"
"	v_WorldPos = a_WorldPos;\n"
"\n"
"	v_FragPos = vec4( u_ModelViewProjection * vec4( a_Position, 1.0 ) ).xyz;\n"
"\n"
"    gl_Position = u_ModelViewProjection * vec4( a_Position, 1.0 );\n"
"}\n"
;

const char *fallbackShader_down4x_vp =
"in vec3 a_Position;\n"
"in vec4 a_LightCoords;\n"
"\n"
"uniform mat4 u_ModelViewProjection;\n"
"\n"
"out vec2 v_TexCoords;\n"
"\n"
"void main() {\n"
"	gl_Position = u_ModelViewProjection * vec4(a_Position, 1.0);\n"
"	v_TexCoords = a_LightCoords.st;\n"
"}\n"
;

const char *fallbackShader_tonemap_vp =
"in vec3 a_Position;\n"
"in vec4 a_LightCoords;\n"
"\n"
"uniform mat4 u_ModelViewProjection;\n"
"uniform vec3 u_ToneMinAvgMaxLinear;\n"
"\n"
"out vec2 v_TexCoords;\n"
"out float v_InvWhite;\n"
"\n"
"float FilmicTonemap(float x)\n"
"{\n"
"	const float SS  = 0.22; // Shoulder Strength\n"
"	const float LS  = 0.30; // Linear Strength\n"
"	const float LA  = 0.10; // Linear Angle\n"
"	const float TS  = 0.20; // Toe Strength\n"
"	const float TAN = 0.01; // Toe Angle Numerator\n"
"	const float TAD = 0.30; // Toe Angle Denominator\n"
"\n"
"	return ((x*(SS*x+LA*LS)+TS*TAN)/(x*(SS*x+LS)+TS*TAD)) - TAN/TAD;\n"
"}\n"
"\n"
"void main() {\n"
"	gl_Position = u_ModelViewProjection * vec4(a_Position, 1.0);\n"
"	v_TexCoords = a_LightCoords.st;\n"
"	v_InvWhite = 1.0 / FilmicTonemap(u_ToneMinAvgMaxLinear.z - u_ToneMinAvgMaxLinear.x);\n"
"}\n"
;

const char *fallbackShader_SMAABlend_fp =
"#if !defined(GLSL_LEGACY)\n"
"layout( location = 0 ) out vec4 a_Color;\n"
"#endif\n"
"\n"
"#define mad( a, b, c ) ( a * b + c )\n"
"\n"
"uniform sampler2D u_DiffuseMap;\n"
"uniform sampler2D u_BlendTexture;\n"
"\n"
"uniform vec2 u_ScreenSize;\n"
"\n"
"in vec2 v_TexCoords;\n"
"in vec4 v_Offset;\n"
"\n"
"vec4 SMAA_RT_METRICS = vec4( 1.0 / resolution.x, 1.0 / resolution.y, resolution.x, resolution.y );\n"
"\n"
"/**\n"
" * Conditional move:\n"
" */\n"
"void SMAAMovc( bvec2 cond, inout vec2 variable, vec2 value ) {\n"
"    if ( cond.x ) {\n"
"        variable.x = value.x;\n"
"    }\n"
"    if (  cond.y ) {\n"
"        variable.y = value.y;\n"
"    }\n"
"}\n"
"\n"
"void SMAAMovc( bvec4 cond, inout vec4 variable, vec4 value ) {\n"
"    SMAAMovc( cond.xy, variable.xy, value.xy );\n"
"    SMAAMovc( cond.zw, variable.zw, value.zw );\n"
"}\n"
"\n"
"void main() {\n"
"    vec4 color;\n"
"\n"
"    // Fetch the blending weights for current pixel:\n"
"    vec4 a;\n"
"    a.x = texture2D( u_BlendTexture, v_Offset.xy ).a; // Right\n"
"    a.y = texture2D( u_BlendTexture, v_Offset.zw ).g; // Top\n"
"    a.wz = texture2D( u_BlendTexture, v_TexCoords ).xz; // Bottom / Left\n"
"\n"
"    // Is there any blending weight with a value greater than 0.0?\n"
"    if ( dot( a, vec4( 1.0, 1.0, 1.0, 1.0 ) ) <= 1e - 5 ) {\n"
"        color = texture2D( u_DiffuseMap, v_TexCoords ); // LinearSampler\n"
"    } else {\n"
"        bool h = max( a.x, a.z ) > max( a.y, a.w ); // max(horizontal) > max(vertical)\n"
"\n"
"        // Calculate the blending offsets:\n"
"        vec4 blendingOffset = vec4( 0.0, a.y, 0.0, a.w );\n"
"        vec2 blendingWeight = a.yw;\n"
"        SMAAMovc( bvec4( h, h, h, h ), blendingOffset, vec4( a.x, 0.0, a.z, 0.0 ) );\n"
"        SMAAMovc( bvec2( h, h ), blendingWeight, a.xz);\n"
"        blendingWeight /= dot( blendingWeight, vec2( 1.0, 1.0 ) );\n"
"\n"
"        // Calculate the texture coordinates:\n"
"        vec4 blendingCoord = mad( blendingOffset, vec4( SMAA_RT_METRICS.xy, -SMAA_RT_METRICS.xy ), v_TexCoords.xyxy );\n"
"\n"
"        // We exploit bilinear filtering to mix current pixel with the chosen\n"
"        // neighbor:\n"
"        color = blendingWeight.x * texture2D( u_DiffuseMap, blendingCoord.xy ); // LinearSampler\n"
"        color += blendingWeight.y * texture2D( u_DiffuseMap, blendingCoord.zw ); // LinearSampler\n"
"    }\n"
"\n"
"    a_Color = color;\n"
"}\n"
;

const char *fallbackShader_SMAAWeights_vp =
"#define mad( a, b, c ) ( a * b + c )\n"
"\n"
"#if defined(SMAA_PRESET_LOW)\n"
"#define SMAA_MAX_SEARCH_STEPS 4\n"
"#elif defined(SMAA_PRESET_MEDIUM)\n"
"#define SMAA_MAX_SEARCH_STEPS 8\n"
"#elif defined(SMAA_PRESET_HIGH)\n"
"#define SMAA_MAX_SEARCH_STEPS 16\n"
"#elif defined(SMAA_PRESET_ULTRA)\n"
"#define SMAA_MAX_SEARCH_STEPS 32\n"
"#endif\n"
"\n"
"#if !defined(SMAA_MAX_SEARCH_STEPS)\n"
"#define SMAA_MAX_SEARCH_STEPS 16\n"
"#endif\n"
"\n"
"in vec2 a_Position;\n"
"\n"
"uniform vec2 u_ScreenSize;\n"
"\n"
"out vec2 v_TexCoords;\n"
"out vec2 v_PixCoord;\n"
"out vec4 v_Offset[3];\n"
"\n"
"void main() {\n"
"    vec4 SMAA_RT_METRICS = vec4( 1.0 / u_ScreenSize.x, 1.0 / u_ScreenSize.y, u_ScreenSize.x, u_ScreenSize.y );\n"
"\n"
"	v_TexCoords = vec2( ( a_Position + 1.0 ) / 2.0 );\n"
"    v_PixCoord = v_TexCoords * SMAA_RT_METRICS.zw;\n"
"\n"
"    // We will use these offsets for the searches later on (see @PSEUDO_GATHER4):\n"
"    v_Offset[0] = mad( SMAA_RT_METRICS.xyxy, vec4( -0.25, -0.125,  1.25, -0.125 ), v_TexCoords.xyxy );\n"
"    v_Offset[1] = mad( SMAA_RT_METRICS.xyxy, vec4( -0.125, -0.25, -0.125,  1.25 ), v_TexCoords.xyxy );\n"
"\n"
"    // And these for the searches, they indicate the ends of the loops:\n"
"    v_Offset[2] = mad(\n"
"        SMAA_RT_METRICS.xxyy,\n"
"        vec4( -2.0, 2.0, -2.0, 2.0 ) * float( SMAA_MAX_SEARCH_STEPS ),\n"
"        vec4( v_Offset[0].xz, v_Offset[1].yw )\n"
"    );\n"
"\n"
"    gl_Position = vec4( a_Position, 0.0, 1.0 );\n"
"}\n"
;

const char *fallbackShader_ssao_vp =
"in vec4 a_Position;\n"
"in vec4 a_LightCoords;\n"
"\n"
"out vec2 v_ScreenTex;\n"
"\n"
"void main() {\n"
"	gl_Position = a_Position;\n"
"	v_ScreenTex = a_TexCoords.xy;\n"
"	//vec2 screenCoords = gl_Position.xy / gl_Position.w;\n"
"	//var_ScreenTex = screenCoords * 0.5 + 0.5;\n"
"}\n"
;

const char *fallbackShader_down4x_fp =
"#if !defined(GLSL_LEGACY)\n"
"out vec4 a_Color;\n"
"#endif\n"
"\n"
"uniform sampler2D u_TextureMap;\n"
"\n"
"uniform vec2 u_InvTexRes;\n"
"in vec2 v_TexCoords;\n"
"\n"
"void main()\n"
"{\n"
"	vec4 color;\n"
"	vec2 tc;\n"
"\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(-1.5, -1.5);  color  = texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(-0.5, -1.5);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( 0.5, -1.5);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( 1.5, -1.5);  color += texture2D(u_TextureMap, tc);\n"
"\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(-1.5, -0.5); color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(-0.5, -0.5); color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( 0.5, -0.5); color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( 1.5, -0.5); color += texture2D(u_TextureMap, tc);\n"
"\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(-1.5,  0.5); color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(-0.5,  0.5); color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( 0.5,  0.5); color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( 1.5,  0.5); color += texture2D(u_TextureMap, tc);\n"
"\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(-1.5,  1.5);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(-0.5,  1.5);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( 0.5,  1.5);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( 1.5,  1.5);  color += texture2D(u_TextureMap, tc);\n"
"\n"
"	color *= 0.0625;\n"
"\n"
"	a_Color = color;\n"
"}\n"
;

const char *fallbackShader_SMAA_fp =
"/**\n"
" * Copyright (C) 2013 Jorge Jimenez (jorge@iryoku.com)\n"
" * Copyright (C) 2013 Jose I. Echevarria (joseignacioechevarria@gmail.com)\n"
" * Copyright (C) 2013 Belen Masia (bmasia@unizar.es)\n"
" * Copyright (C) 2013 Fernando Navarro (fernandn@microsoft.com)\n"
" * Copyright (C) 2013 Diego Gutierrez (diegog@unizar.es)\n"
" *\n"
" * Permission is hereby granted, free of charge, to any person obtaining a copy\n"
" * this software and associated documentation files (the \"Software\"), to deal in\n"
" * the Software without restriction, including without limitation the rights to\n"
" * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n"
" * of the Software, and to permit persons to whom the Software is furnished to\n"
" * do so, subject to the following conditions:\n"
" *\n"
" * The above copyright notice and this permission notice shall be included in\n"
" * all copies or substantial portions of the Software. As clarification, there\n"
" * is no requirement that the copyright notice and permission be included in\n"
" * binary distributions of the Software.\n"
" *\n"
" * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n"
" * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n"
" * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n"
" * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n"
" * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n"
" * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n"
" * SOFTWARE.\n"
" */\n"
"\n"
"\n"
"/**\n"
" *                  _______  ___  ___       ___           ___\n"
" *                 /       ||   \\/   |     /   \\         /   \\\n"
" *                |   (---- |  \\  /  |    /  ^  \\       /  ^  \\\n"
" *                 \\   \\    |  |\\/|  |   /  /_\\  \\     /  /_\\  \\\n"
" *              ----)   |   |  |  |  |  /  _____  \\   /  _____  \\\n"
" *             |_______/    |__|  |__| /__/     \\__\\ /__/     \\__\\\n"
" *\n"
" *                               E N H A N C E D\n"
" *       S U B P I X E L   M O R P H O L O G I C A L   A N T I A L I A S I N G\n"
" *\n"
" *                         http://www.iryoku.com/smaa/\n"
" *\n"
" * Hi, welcome aboard!\n"
" *\n"
" * Here you\'ll find instructions to get the shader up and running as fast as\n"
" * possible.\n"
" *\n"
" * IMPORTANTE NOTICE: when updating, remember to update both this file and the\n"
" * precomputed textures! They may change from version to version.\n"
" *\n"
" * The shader has three passes, chained together as follows:\n"
" *\n"
" *                           |input|------------------�\n"
" *                              v                     |\n"
" *                    [ SMAA*EdgeDetection ]          |\n"
" *                              v                     |\n"
" *                          |edgesTex|                |\n"
" *                              v                     |\n"
" *              [ SMAABlendingWeightCalculation ]     |\n"
" *                              v                     |\n"
" *                          |blendTex|                |\n"
" *                              v                     |\n"
" *                [ SMAANeighborhoodBlending ] <------�\n"
" *                              v\n"
" *                           |output|\n"
" *\n"
" * Note that each [pass] has its own vertex and pixel shader. Remember to use\n"
" * oversized triangles instead of quads to avoid overshading along the\n"
" * diagonal.\n"
" *\n"
" * You\'ve three edge detection methods to choose from: luma, color or depth.\n"
" * They represent different quality/performance and anti-aliasing/sharpness\n"
" * tradeoffs, so our recommendation is for you to choose the one that best\n"
" * suits your particular scenario:\n"
" *\n"
" * - Depth edge detection is usually the fastest but it may miss some edges.\n"
" *\n"
" * - Luma edge detection is usually more expensive than depth edge detection,\n"
" *   but catches visible edges that depth edge detection can miss.\n"
" *\n"
" * - Color edge detection is usually the most expensive one but catches\n"
" *   chroma-only edges.\n"
" *\n"
" * For quickstarters: just use luma edge detection.\n"
" *\n"
" * The general advice is to not rush the integration process and ensure each\n"
" * step is done correctly (don\'t try to integrate SMAA T2x with predicated edge\n"
" * detection from the start!). Ok then, let\'s go!\n"
" *\n"
" *  1. The first step is to create two RGBA temporal render targets for holding\n"
" *     |edgesTex| and |blendTex|.\n"
" *\n"
" *     In DX10 or DX11, you can use a RG render target for the edges texture.\n"
" *     In the case of NVIDIA GPUs, using RG render targets seems to actually be\n"
" *     slower.\n"
" *\n"
" *     On the Xbox 360, you can use the same render target for resolving both\n"
" *     |edgesTex| and |blendTex|, as they aren\'t needed simultaneously.\n"
" *\n"
" *  2. Both temporal render targets |edgesTex| and |blendTex| must be cleared\n"
" *     each frame. Do not forget to clear the alpha channel!\n"
" *\n"
" *  3. The next step is loading the two supporting precalculated textures,\n"
" *     \'areaTex\' and \'searchTex\'. You\'ll find them in the \'Textures\' folder as\n"
" *     C++ headers, and also as regular DDS files. They\'ll be needed for the\n"
" *     \'SMAABlendingWeightCalculation\' pass.\n"
" *\n"
" *     If you use the C++ headers, be sure to load them in the format specified\n"
" *     inside of them.\n"
" *\n"
" *     You can also compress \'areaTex\' and \'searchTex\' using BC5 and BC4\n"
" *     respectively, if you have that option in your content processor pipeline.\n"
" *     When compressing then, you get a non-perceptible quality decrease, and a\n"
" *     marginal performance increase.\n"
" *\n"
" *  4. All samplers must be set to linear filtering and clamp.\n"
" *\n"
" *     After you get the technique working, remember that 64-bit inputs have\n"
" *     half-rate linear filtering on GCN.\n"
" *\n"
" *     If SMAA is applied to 64-bit color buffers, switching to point filtering\n"
" *     when accesing them will increase the performance. Search for\n"
" *     \'SMAASamplePoint\' to see which textures may benefit from point\n"
" *     filtering, and where (which is basically the color input in the edge\n"
" *     detection and resolve passes).\n"
" *\n"
" *  5. All texture reads and buffer writes must be non-sRGB, with the exception\n"
" *     of the input read and the output write in\n"
" *     \'SMAANeighborhoodBlending\' (and only in this pass!). If sRGB reads in\n"
" *     this last pass are not possible, the technique will work anyway, but\n"
" *     will perform antialiasing in gamma space.\n"
" *\n"
" *     IMPORTANT: for best results the input read for the color/luma edge\n"
" *     detection should *NOT* be sRGB.\n"
" *\n"
" *  6. Before including SMAA.h you\'ll have to setup the render target metrics,\n"
" *     the target and any optional configuration defines. Optionally you can\n"
" *     use a preset.\n"
" *\n"
" *     You have the following targets available:\n"
" *         SMAA_HLSL_3\n"
" *         SMAA_HLSL_4\n"
" *         SMAA_HLSL_4_1\n"
" *         SMAA_GLSL_3 *\n"
" *         SMAA_GLSL_4 *\n"
" *\n"
" *         * (See SMAA_INCLUDE_VS and SMAA_INCLUDE_PS below).\n"
" *\n"
" *     And four presets:\n"
" *         SMAA_PRESET_LOW          (%60 of the quality)\n"
" *         SMAA_PRESET_MEDIUM       (%80 of the quality)\n"
" *         SMAA_PRESET_HIGH         (%95 of the quality)\n"
" *         SMAA_PRESET_ULTRA        (%99 of the quality)\n"
" *\n"
" *     For example:\n"
" *         #define SMAA_RT_METRICS vec4(1.0 / 1280.0, 1.0 / 720.0, 1280.0, 720.0)\n"
" *         #define SMAA_HLSL_4\n"
" *         #define SMAA_PRESET_HIGH\n"
" *         #include \"SMAA.h\"\n"
" *\n"
" *     Note that SMAA_RT_METRICS doesn\'t need to be a macro, it can be a\n"
" *     uniform variable. The code is designed to minimize the impact of not\n"
" *     using a constant value, but it is still better to hardcode it.\n"
" *\n"
" *     Depending on how you encoded \'areaTex\' and \'searchTex\', you may have to\n"
" *     add (and customize) the following defines before including SMAA.h:\n"
" *          #define SMAA_AREATEX_SELECT(sample) sample.rg\n"
" *          #define SMAA_SEARCHTEX_SELECT(sample) sample.r\n"
" *\n"
" *     If your engine is already using porting macros, you can define\n"
" *     SMAA_CUSTOM_SL, and define the porting functions by yourself.\n"
" *\n"
" *  7. Then, you\'ll have to setup the passes as indicated in the scheme above.\n"
" *     You can take a look into SMAA.fx, to see how we did it for our demo.\n"
" *     Checkout the function wrappers, you may want to copy-paste them!\n"
" *\n"
" *  8. It\'s recommended to validate the produced |edgesTex| and |blendTex|.\n"
" *     You can use a screenshot from your engine to compare the |edgesTex|\n"
" *     and |blendTex| produced inside of the engine with the results obtained\n"
" *     with the reference demo.\n"
" *\n"
" *  9. After you get the last pass to work, it\'s time to optimize. You\'ll have\n"
" *     to initialize a stencil buffer in the first pass (discard is already in\n"
" *     the code), then mask execution by using it the second pass. The last\n"
" *     pass should be executed in all pixels.\n"
" *\n"
" *\n"
" * After this point you can choose to enable predicated thresholding,\n"
" * temporal supersampling and motion blur integration:\n"
" *\n"
" * a) If you want to use predicated thresholding, take a look into\n"
" *    SMAA_PREDICATION; you\'ll need to pass an extra texture in the edge\n"
" *    detection pass.\n"
" *\n"
" * b) If you want to enable temporal supersampling (SMAA T2x):\n"
" *\n"
" * 1. The first step is to render using subpixel jitters. I won\'t go into\n"
" *    detail, but it\'s as simple as moving each vertex position in the\n"
" *    vertex shader, you can check how we do it in our DX10 demo.\n"
" *\n"
" * 2. Then, you must setup the temporal resolve. You may want to take a look\n"
" *    into SMAAResolve for resolving 2x modes. After you get it working, you\'ll\n"
" *    probably see ghosting everywhere. But fear not, you can enable the\n"
" *    CryENGINE temporal reprojection by setting the SMAA_REPROJECTION macro.\n"
" *    Check out SMAA_DECODE_VELOCITY if your velocity buffer is encoded.\n"
" *\n"
" * 3. The next step is to apply SMAA to each subpixel jittered frame, just as\n"
" *    done for 1x.\n"
" *\n"
" * 4. At this point you should already have something usable, but for best\n"
" *    results the proper area textures must be set depending on current jitter.\n"
" *    For this, the parameter \'subsampleIndices\' of\n"
" *    \'SMAABlendingWeightCalculationPS\' must be set as follows, for our T2x\n"
" *    mode:\n"
" *\n"
" *    @SUBSAMPLE_INDICES\n"
" *\n"
" *    | S# |  Camera Jitter   |  subsampleIndices    |\n"
" *    +----+------------------+---------------------+\n"
" *    |  0 |  ( 0.25, -0.25)  |  vec4(1, 1, 1, 0)  |\n"
" *    |  1 |  (-0.25,  0.25)  |  vec4(2, 2, 2, 0)  |\n"
" *\n"
" *    These jitter positions assume a bottom-to-top y axis. S# stands for the\n"
" *    sample number.\n"
" *\n"
" * More information about temporal supersampling here:\n"
" *    http://iryoku.com/aacourse/downloads/13-Anti-Aliasing-Methods-in-CryENGINE-3.pdf\n"
" *\n"
" * c) If you want to enable spatial multisampling (SMAA S2x):\n"
" *\n"
" * 1. The scene must be rendered using MSAA 2x. The MSAA 2x buffer must be\n"
" *    created with:\n"
" *      - DX10:     see below (*)\n"
" *      - DX10.1:   D3D10_STANDARD_MULTISAMPLE_PATTERN or\n"
" *      - DX11:     D3D11_STANDARD_MULTISAMPLE_PATTERN\n"
" *\n"
" *    This allows to ensure that the subsample order matches the table in\n"
" *    @SUBSAMPLE_INDICES.\n"
" *\n"
" *    (*) In the case of DX10, we refer the reader to:\n"
" *      - SMAA::detectMSAAOrder and\n"
" *      - SMAA::msaaReorder\n"
" *\n"
" *    These functions allow to match the standard multisample patterns by\n"
" *    detecting the subsample order for a specific GPU, and reordering\n"
" *    them appropriately.\n"
" *\n"
" * 2. A shader must be run to output each subsample into a separate buffer\n"
" *    (DX10 is required). You can use SMAASeparate for this purpose, or just do\n"
" *    it in an existing pass (for example, in the tone mapping pass, which has\n"
" *    the advantage of feeding tone mapped subsamples to SMAA, which will yield\n"
" *    better results).\n"
" *\n"
" * 3. The full SMAA 1x pipeline must be run for each separated buffer, storing\n"
" *    the results in the final buffer. The second run should alpha blend with\n"
" *    the existing final buffer using a blending factor of 0.5.\n"
" *    \'subsampleIndices\' must be adjusted as in the SMAA T2x case (see point\n"
" *    b).\n"
" *\n"
" * d) If you want to enable temporal supersampling on top of SMAA S2x\n"
" *    (which actually is SMAA 4x):\n"
" *\n"
" * 1. SMAA 4x consists on temporally jittering SMAA S2x, so the first step is\n"
" *    to calculate SMAA S2x for current frame. In this case, \'subsampleIndices\'\n"
" *    must be set as follows:\n"
" *\n"
" *    | F# | S# |   Camera Jitter    |    Net Jitter     |   subsampleIndices   |\n"
" *    +----+----+--------------------+-------------------+----------------------+\n"
" *    |  0 |  0 |  ( 0.125,  0.125)  |  ( 0.375, -0.125) |  vec4(5, 3, 1, 3)  |\n"
" *    |  0 |  1 |  ( 0.125,  0.125)  |  (-0.125,  0.375) |  vec4(4, 6, 2, 3)  |\n"
" *    +----+----+--------------------+-------------------+----------------------+\n"
" *    |  1 |  2 |  (-0.125, -0.125)  |  ( 0.125, -0.375) |  vec4(3, 5, 1, 4)  |\n"
" *    |  1 |  3 |  (-0.125, -0.125)  |  (-0.375,  0.125) |  vec4(6, 4, 2, 4)  |\n"
" *\n"
" *    These jitter positions assume a bottom-to-top y axis. F# stands for the\n"
" *    frame number. S# stands for the sample number.\n"
" *\n"
" * 2. After calculating SMAA S2x for current frame (with the new subsample\n"
" *    indices), previous frame must be reprojected as in SMAA T2x mode (see\n"
" *    point b).\n"
" *\n"
" * e) If motion blur is used, you may want to do the edge detection pass\n"
" *    together with motion blur. This has two advantages:\n"
" *\n"
" * 1. Pixels under heavy motion can be omitted from the edge detection process.\n"
" *    For these pixels we can just store \"no edge\", as motion blur will take\n"
" *    care of them.\n"
" * 2. The center pixel tap is reused.\n"
" *\n"
" * Note that in this case depth testing should be used instead of stenciling,\n"
" * as we have to write all the pixels in the motion blur pass.\n"
" *\n"
" * That\'s it!\n"
" */\n"
"\n"
"//-----------------------------------------------------------------------------\n"
"// SMAA Presets\n"
"\n"
"/**\n"
" * Note that if you use one of these presets, the following configuration\n"
" * macros will be ignored if set in the \"Configurable Defines\" section.\n"
" */\n"
"\n"
"#if defined(SMAA_PRESET_LOW)\n"
"#define SMAA_THRESHOLD 0.15\n"
"#define SMAA_MAX_SEARCH_STEPS 4\n"
"#define SMAA_DISABLE_DIAG_DETECTION\n"
"#define SMAA_DISABLE_CORNER_DETECTION\n"
"#elif defined(SMAA_PRESET_MEDIUM)\n"
"#define SMAA_THRESHOLD 0.1\n"
"#define SMAA_MAX_SEARCH_STEPS 8\n"
"#define SMAA_DISABLE_DIAG_DETECTION\n"
"#define SMAA_DISABLE_CORNER_DETECTION\n"
"#elif defined(SMAA_PRESET_HIGH)\n"
"#define SMAA_THRESHOLD 0.1\n"
"#define SMAA_MAX_SEARCH_STEPS 16\n"
"#define SMAA_MAX_SEARCH_STEPS_DIAG 8\n"
"#define SMAA_CORNER_ROUNDING 25\n"
"#elif defined(SMAA_PRESET_ULTRA)\n"
"#define SMAA_THRESHOLD 0.05\n"
"#define SMAA_MAX_SEARCH_STEPS 32\n"
"#define SMAA_MAX_SEARCH_STEPS_DIAG 16\n"
"#define SMAA_CORNER_ROUNDING 25\n"
"#endif\n"
"\n"
"//-----------------------------------------------------------------------------\n"
"// Configurable Defines\n"
"\n"
"/**\n"
" * SMAA_THRESHOLD specifies the threshold or sensitivity to edges.\n"
" * Lowering this value you will be able to detect more edges at the expense of\n"
" * performance.\n"
" *\n"
" * Range: [0, 0.5]\n"
" *   0.1 is a reasonable value, and allows to catch most visible edges.\n"
" *   0.05 is a rather overkill value, that allows to catch \'em all.\n"
" *\n"
" *   If temporal supersampling is used, 0.2 could be a reasonable value, as low\n"
" *   contrast edges are properly filtered by just 2x.\n"
" */\n"
"#ifndef SMAA_THRESHOLD\n"
"#define SMAA_THRESHOLD 0.1\n"
"#endif\n"
"\n"
"/**\n"
" * SMAA_DEPTH_THRESHOLD specifies the threshold for depth edge detection.\n"
" *\n"
" * Range: depends on the depth range of the scene.\n"
" */\n"
"#ifndef SMAA_DEPTH_THRESHOLD\n"
"#define SMAA_DEPTH_THRESHOLD (0.1 * SMAA_THRESHOLD)\n"
"#endif\n"
"\n"
"/**\n"
" * SMAA_MAX_SEARCH_STEPS specifies the maximum steps performed in the\n"
" * horizontal/vertical pattern searches, at each side of the pixel.\n"
" *\n"
" * In number of pixels, it\'s actually the double. So the maximum line length\n"
" * perfectly handled by, for example 16, is 64 (by perfectly, we meant that\n"
" * longer lines won\'t look as good, but still antialiased).\n"
" *\n"
" * Range: [0, 112]\n"
" */\n"
"#ifndef SMAA_MAX_SEARCH_STEPS\n"
"#define SMAA_MAX_SEARCH_STEPS 16\n"
"#endif\n"
"\n"
"/**\n"
" * SMAA_MAX_SEARCH_STEPS_DIAG specifies the maximum steps performed in the\n"
" * diagonal pattern searches, at each side of the pixel. In this case we jump\n"
" * one pixel at time, instead of two.\n"
" *\n"
" * Range: [0, 20]\n"
" *\n"
" * On high-end machines it is cheap (between a 0.8x and 0.9x slower for 16\n"
" * steps), but it can have a significant impact on older machines.\n"
" *\n"
" * Define SMAA_DISABLE_DIAG_DETECTION to disable diagonal processing.\n"
" */\n"
"#ifndef SMAA_MAX_SEARCH_STEPS_DIAG\n"
"#define SMAA_MAX_SEARCH_STEPS_DIAG 8\n"
"#endif\n"
"\n"
"/**\n"
" * SMAA_CORNER_ROUNDING specifies how much sharp corners will be rounded.\n"
" *\n"
" * Range: [0, 100]\n"
" *\n"
" * Define SMAA_DISABLE_CORNER_DETECTION to disable corner processing.\n"
" */\n"
"#ifndef SMAA_CORNER_ROUNDING\n"
"#define SMAA_CORNER_ROUNDING 25\n"
"#endif\n"
"\n"
"/**\n"
" * If there is an neighbor edge that has SMAA_LOCAL_CONTRAST_FACTOR times\n"
" * bigger contrast than current edge, current edge will be discarded.\n"
" *\n"
" * This allows to eliminate spurious crossing edges, and is based on the fact\n"
" * that, if there is too much contrast in a direction, that will hide\n"
" * perceptually contrast in the other neighbors.\n"
" */\n"
"#ifndef SMAA_LOCAL_CONTRAST_ADAPTATION_FACTOR\n"
"#define SMAA_LOCAL_CONTRAST_ADAPTATION_FACTOR 2.0\n"
"#endif\n"
"\n"
"/**\n"
" * Predicated thresholding allows to better preserve texture details and to\n"
" * improve performance, by decreasing the number of detected edges using an\n"
" * additional buffer like the light accumulation buffer, object ids or even the\n"
" * depth buffer (the depth buffer usage may be limited to indoor or short range\n"
" * scenes).\n"
" *\n"
" * It locally decreases the luma or color threshold if an edge is found in an\n"
" * additional buffer (so the global threshold can be higher).\n"
" *\n"
" * This method was developed by Playstation EDGE MLAA team, and used in\n"
" * Killzone 3, by using the light accumulation buffer. More information here:\n"
" *     http://iryoku.com/aacourse/downloads/06-MLAA-on-PS3.pptx\n"
" */\n"
"#ifndef SMAA_PREDICATION\n"
"#define SMAA_PREDICATION 0\n"
"#endif\n"
"\n"
"/**\n"
" * Threshold to be used in the additional predication buffer.\n"
" *\n"
" * Range: depends on the input, so you\'ll have to find the magic number that\n"
" * works for you.\n"
" */\n"
"#ifndef SMAA_PREDICATION_THRESHOLD\n"
"#define SMAA_PREDICATION_THRESHOLD 0.01\n"
"#endif\n"
"\n"
"/**\n"
" * How much to scale the global threshold used for luma or color edge\n"
" * detection when using predication.\n"
" *\n"
" * Range: [1, 5]\n"
" */\n"
"#ifndef SMAA_PREDICATION_SCALE\n"
"#define SMAA_PREDICATION_SCALE 2.0\n"
"#endif\n"
"\n"
"/**\n"
" * How much to locally decrease the threshold.\n"
" *\n"
" * Range: [0, 1]\n"
" */\n"
"#ifndef SMAA_PREDICATION_STRENGTH\n"
"#define SMAA_PREDICATION_STRENGTH 0.4\n"
"#endif\n"
"\n"
"/**\n"
" * Temporal reprojection allows to remove ghosting artifacts when using\n"
" * temporal supersampling. We use the CryEngine 3 method which also introduces\n"
" * velocity weighting. This feature is of extreme importance for totally\n"
" * removing ghosting. More information here:\n"
" *    http://iryoku.com/aacourse/downloads/13-Anti-Aliasing-Methods-in-CryENGINE-3.pdf\n"
" *\n"
" * Note that you\'ll need to setup a velocity buffer for enabling reprojection.\n"
" * For static geometry, saving the previous depth buffer is a viable\n"
" * alternative.\n"
" */\n"
"#ifndef SMAA_REPROJECTION\n"
"#define SMAA_REPROJECTION 0\n"
"#endif\n"
"\n"
"/**\n"
" * SMAA_REPROJECTION_WEIGHT_SCALE controls the velocity weighting. It allows to\n"
" * remove ghosting trails behind the moving object, which are not removed by\n"
" * just using reprojection. Using low values will exhibit ghosting, while using\n"
" * high values will disable temporal supersampling under motion.\n"
" *\n"
" * Behind the scenes, velocity weighting removes temporal supersampling when\n"
" * the velocity of the subsamples differs (meaning they are different objects).\n"
" *\n"
" * Range: [0, 80]\n"
" */\n"
"#ifndef SMAA_REPROJECTION_WEIGHT_SCALE\n"
"#define SMAA_REPROJECTION_WEIGHT_SCALE 30.0\n"
"#endif\n"
"\n"
"/**\n"
" * On some compilers, discard cannot be used in vertex shaders. Thus, they need\n"
" * to be compiled separately.\n"
" */\n"
"#ifndef SMAA_INCLUDE_VS\n"
"#define SMAA_INCLUDE_VS 1\n"
"#endif\n"
"#ifndef SMAA_INCLUDE_PS\n"
"#define SMAA_INCLUDE_PS 1\n"
"#endif\n"
"\n"
"//-----------------------------------------------------------------------------\n"
"// Texture Access Defines\n"
"\n"
"#ifndef SMAA_AREATEX_SELECT\n"
"#if defined(SMAA_HLSL_3)\n"
"#define SMAA_AREATEX_SELECT(sample) sample.ra\n"
"#else\n"
"#define SMAA_AREATEX_SELECT(sample) sample.rg\n"
"#endif\n"
"#endif\n"
"\n"
"#ifndef SMAA_SEARCHTEX_SELECT\n"
"#define SMAA_SEARCHTEX_SELECT(sample) sample.r\n"
"#endif\n"
"\n"
"#ifndef SMAA_DECODE_VELOCITY\n"
"#define SMAA_DECODE_VELOCITY(sample) sample.rg\n"
"#endif\n"
"\n"
"//-----------------------------------------------------------------------------\n"
"// Non-Configurable Defines\n"
"\n"
"#define SMAA_AREATEX_MAX_DISTANCE 16\n"
"#define SMAA_AREATEX_MAX_DISTANCE_DIAG 20\n"
"#define SMAA_AREATEX_PIXEL_SIZE (1.0 / vec2(160.0, 560.0))\n"
"#define SMAA_AREATEX_SUBTEX_SIZE (1.0 / 7.0)\n"
"#define SMAA_SEARCHTEX_SIZE vec2(66.0, 33.0)\n"
"#define SMAA_SEARCHTEX_PACKED_SIZE vec2(64.0, 16.0)\n"
"#define SMAA_CORNER_ROUNDING_NORM (float(SMAA_CORNER_ROUNDING) / 100.0)\n"
"\n"
"#define SMAATexture2D(tex) sampler2D tex\n"
"#define SMAATexturePass2D(tex) tex\n"
"#define SMAASampleLevelZero(tex, coord) textureLod(tex, coord, 0.0)\n"
"#define SMAASampleLevelZeroPoint(tex, coord) textureLod(tex, coord, 0.0)\n"
"#define SMAASampleLevelZeroOffset(tex, coord, offset) textureLodOffset(tex, coord, 0.0, offset)\n"
"#define SMAASample(tex, coord) texture(tex, coord)\n"
"#define SMAASamplePoint(tex, coord) texture(tex, coord)\n"
"#define SMAASampleOffset(tex, coord, offset) texture(tex, coord, offset)\n"
"#define SMAA_FLATTEN\n"
"#define SMAA_BRANCH\n"
"#define lerp(a, b, t) mix(a, b, t)\n"
"#define saturate(a) clamp(a, 0.0, 1.0)\n"
"#if defined(SMAA_GLSL_4)\n"
"#define mad(a, b, c) fma(a, b, c)\n"
"#define SMAAGather(tex, coord) textureGather(tex, coord)\n"
"#else\n"
"#define mad(a, b, c) (a * b + c)\n"
"#endif\n"
"\n"
"//-----------------------------------------------------------------------------\n"
"// Misc functions\n"
"\n"
"/**\n"
" * Gathers current pixel, and the top-left neighbors.\n"
" */\n"
"vec3 SMAAGatherNeighbours(vec2 texcoord,\n"
"                            vec4 offset[3],\n"
"                            SMAATexture2D(tex)) {\n"
"#ifdef SMAAGather\n"
"    return SMAAGather(tex, texcoord + SMAA_RT_METRICS.xy * vec2(-0.5, -0.5)).grb;\n"
"#else\n"
"    float P = SMAASamplePoint(tex, texcoord).r;\n"
"    float Pleft = SMAASamplePoint(tex, offset[0].xy).r;\n"
"    float Ptop  = SMAASamplePoint(tex, offset[0].zw).r;\n"
"    return vec3(P, Pleft, Ptop);\n"
"#endif\n"
"}\n"
"\n"
"/**\n"
" * Adjusts the threshold by means of predication.\n"
" */\n"
"vec2 SMAACalculatePredicatedThreshold(vec2 texcoord,\n"
"                                        vec4 offset[3],\n"
"                                        SMAATexture2D(predicationTex)) {\n"
"    vec3 neighbours = SMAAGatherNeighbours(texcoord, offset, SMAATexturePass2D(predicationTex));\n"
"    vec2 delta = abs(neighbours.xx - neighbours.yz);\n"
"    vec2 edges = step(SMAA_PREDICATION_THRESHOLD, delta);\n"
"    return SMAA_PREDICATION_SCALE * SMAA_THRESHOLD * (1.0 - SMAA_PREDICATION_STRENGTH * edges);\n"
"}\n"
"\n"
"/**\n"
" * Conditional move:\n"
" */\n"
"void SMAAMovc(bool2 cond, inout vec2 variable, vec2 value) {\n"
"    SMAA_FLATTEN if (cond.x) variable.x = value.x;\n"
"    SMAA_FLATTEN if (cond.y) variable.y = value.y;\n"
"}\n"
"\n"
"void SMAAMovc(bool4 cond, inout vec4 variable, vec4 value) {\n"
"    SMAAMovc(cond.xy, variable.xy, value.xy);\n"
"    SMAAMovc(cond.zw, variable.zw, value.zw);\n"
"}\n"
"\n"
"//-----------------------------------------------------------------------------\n"
"// Edge Detection Pixel Shaders (First Pass)\n"
"\n"
"/**\n"
" * Luma Edge Detection\n"
" *\n"
" * IMPORTANT NOTICE: luma edge detection requires gamma-corrected colors, and\n"
" * thus \'colorTex\' should be a non-sRGB texture.\n"
" */\n"
"vec2 SMAALumaEdgeDetectionPS(vec2 texcoord,\n"
"                               vec4 offset[3],\n"
"                               SMAATexture2D(colorTex)\n"
"                               #if SMAA_PREDICATION\n"
"                               , SMAATexture2D(predicationTex)\n"
"                               #endif\n"
"                               ) {\n"
"    // Calculate the threshold:\n"
"#if SMAA_PREDICATION\n"
"    vec2 threshold = SMAACalculatePredicatedThreshold(texcoord, offset, SMAATexturePass2D(predicationTex));\n"
"#else\n"
"    vec2 threshold = vec2(SMAA_THRESHOLD, SMAA_THRESHOLD);\n"
"#endif\n"
"\n"
"    // Calculate lumas:\n"
"    vec3 weights = vec3(0.2126, 0.7152, 0.0722);\n"
"    float L = dot(SMAASamplePoint(colorTex, texcoord).rgb, weights);\n"
"\n"
"    float Lleft = dot(SMAASamplePoint(colorTex, offset[0].xy).rgb, weights);\n"
"    float Ltop  = dot(SMAASamplePoint(colorTex, offset[0].zw).rgb, weights);\n"
"\n"
"    // We do the usual threshold:\n"
"    vec4 delta;\n"
"    delta.xy = abs(L - vec2(Lleft, Ltop));\n"
"    vec2 edges = step(threshold, delta.xy);\n"
"\n"
"    // Then discard if there is no edge:\n"
"    if (dot(edges, vec2(1.0, 1.0)) == 0.0)\n"
"        discard;\n"
"\n"
"    // Calculate right and bottom deltas:\n"
"    float Lright = dot(SMAASamplePoint(colorTex, offset[1].xy).rgb, weights);\n"
"    float Lbottom  = dot(SMAASamplePoint(colorTex, offset[1].zw).rgb, weights);\n"
"    delta.zw = abs(L - vec2(Lright, Lbottom));\n"
"\n"
"    // Calculate the maximum delta in the direct neighborhood:\n"
"    vec2 maxDelta = max(delta.xy, delta.zw);\n"
"\n"
"    // Calculate left-left and top-top deltas:\n"
"    float Lleftleft = dot(SMAASamplePoint(colorTex, offset[2].xy).rgb, weights);\n"
"    float Ltoptop = dot(SMAASamplePoint(colorTex, offset[2].zw).rgb, weights);\n"
"    delta.zw = abs(vec2(Lleft, Ltop) - vec2(Lleftleft, Ltoptop));\n"
"\n"
"    // Calculate the final maximum delta:\n"
"    maxDelta = max(maxDelta.xy, delta.zw);\n"
"    float finalDelta = max(maxDelta.x, maxDelta.y);\n"
"\n"
"    // Local contrast adaptation:\n"
"    edges.xy *= step(finalDelta, SMAA_LOCAL_CONTRAST_ADAPTATION_FACTOR * delta.xy);\n"
"\n"
"    return edges;\n"
"}\n"
"\n"
"/**\n"
" * Color Edge Detection\n"
" *\n"
" * IMPORTANT NOTICE: color edge detection requires gamma-corrected colors, and\n"
" * thus \'colorTex\' should be a non-sRGB texture.\n"
" */\n"
"vec2 SMAAColorEdgeDetectionPS(vec2 texcoord,\n"
"                                vec4 offset[3],\n"
"                                SMAATexture2D(colorTex)\n"
"                                #if SMAA_PREDICATION\n"
"                                , SMAATexture2D(predicationTex)\n"
"                                #endif\n"
"                                ) {\n"
"    // Calculate the threshold:\n"
"    #if SMAA_PREDICATION\n"
"    vec2 threshold = SMAACalculatePredicatedThreshold(texcoord, offset, predicationTex);\n"
"    #else\n"
"    vec2 threshold = vec2(SMAA_THRESHOLD, SMAA_THRESHOLD);\n"
"    #endif\n"
"\n"
"    // Calculate color deltas:\n"
"    vec4 delta;\n"
"    vec3 C = SMAASamplePoint(colorTex, texcoord).rgb;\n"
"\n"
"    vec3 Cleft = SMAASamplePoint(colorTex, offset[0].xy).rgb;\n"
"    vec3 t = abs(C - Cleft);\n"
"    delta.x = max(max(t.r, t.g), t.b);\n"
"\n"
"    vec3 Ctop  = SMAASamplePoint(colorTex, offset[0].zw).rgb;\n"
"    t = abs(C - Ctop);\n"
"    delta.y = max(max(t.r, t.g), t.b);\n"
"\n"
"    // We do the usual threshold:\n"
"    vec2 edges = step(threshold, delta.xy);\n"
"\n"
"    // Then discard if there is no edge:\n"
"    if (dot(edges, vec2(1.0, 1.0)) == 0.0)\n"
"        discard;\n"
"\n"
"    // Calculate right and bottom deltas:\n"
"    vec3 Cright = SMAASamplePoint(colorTex, offset[1].xy).rgb;\n"
"    t = abs(C - Cright);\n"
"    delta.z = max(max(t.r, t.g), t.b);\n"
"\n"
"    vec3 Cbottom  = SMAASamplePoint(colorTex, offset[1].zw).rgb;\n"
"    t = abs(C - Cbottom);\n"
"    delta.w = max(max(t.r, t.g), t.b);\n"
"\n"
"    // Calculate the maximum delta in the direct neighborhood:\n"
"    vec2 maxDelta = max(delta.xy, delta.zw);\n"
"\n"
"    // Calculate left-left and top-top deltas:\n"
"    vec3 Cleftleft  = SMAASamplePoint(colorTex, offset[2].xy).rgb;\n"
"    t = abs(C - Cleftleft);\n"
"    delta.z = max(max(t.r, t.g), t.b);\n"
"\n"
"    vec3 Ctoptop = SMAASamplePoint(colorTex, offset[2].zw).rgb;\n"
"    t = abs(C - Ctoptop);\n"
"    delta.w = max(max(t.r, t.g), t.b);\n"
"\n"
"    // Calculate the final maximum delta:\n"
"    maxDelta = max(maxDelta.xy, delta.zw);\n"
"    float finalDelta = max(maxDelta.x, maxDelta.y);\n"
"\n"
"    // Local contrast adaptation:\n"
"    edges.xy *= step(finalDelta, SMAA_LOCAL_CONTRAST_ADAPTATION_FACTOR * delta.xy);\n"
"\n"
"    return edges;\n"
"}\n"
"\n"
"/**\n"
" * Depth Edge Detection\n"
" */\n"
"vec2 SMAADepthEdgeDetectionPS(vec2 texcoord,\n"
"                                vec4 offset[3],\n"
"                                SMAATexture2D(depthTex)) {\n"
"    vec3 neighbours = SMAAGatherNeighbours(texcoord, offset, SMAATexturePass2D(depthTex));\n"
"    vec2 delta = abs(neighbours.xx - vec2(neighbours.y, neighbours.z));\n"
"    vec2 edges = step(SMAA_DEPTH_THRESHOLD, delta);\n"
"\n"
"    if (dot(edges, vec2(1.0, 1.0)) == 0.0)\n"
"        discard;\n"
"\n"
"    return edges;\n"
"}\n"
"\n"
"//-----------------------------------------------------------------------------\n"
"// Diagonal Search Functions\n"
"\n"
"#if !defined(SMAA_DISABLE_DIAG_DETECTION)\n"
"\n"
"/**\n"
" * Allows to decode two binary values from a bilinear-filtered access.\n"
" */\n"
"vec2 SMAADecodeDiagBilinearAccess(vec2 e) {\n"
"    // Bilinear access for fetching \'e\' have a 0.25 offset, and we are\n"
"    // interested in the R and G edges:\n"
"    //\n"
"    // +---G---+-------+\n"
"    // |   x o R   x   |\n"
"    // +-------+-------+\n"
"    //\n"
"    // Then, if one of these edge is enabled:\n"
"    //   Red:   (0.75 * X + 0.25 * 1) => 0.25 or 1.0\n"
"    //   Green: (0.75 * 1 + 0.25 * X) => 0.75 or 1.0\n"
"    //\n"
"    // This function will unpack the values (mad + mul + round):\n"
"    // wolframalpha.com: round(x * abs(5 * x - 5 * 0.75)) plot 0 to 1\n"
"    e.r = e.r * abs(5.0 * e.r - 5.0 * 0.75);\n"
"    return round(e);\n"
"}\n"
"\n"
"vec4 SMAADecodeDiagBilinearAccess(vec4 e) {\n"
"    e.rb = e.rb * abs(5.0 * e.rb - 5.0 * 0.75);\n"
"    return round(e);\n"
"}\n"
"\n"
"/**\n"
" * These functions allows to perform diagonal pattern searches.\n"
" */\n"
"vec2 SMAASearchDiag1(SMAATexture2D(edgesTex), vec2 texcoord, vec2 dir, out vec2 e) {\n"
"    vec4 coord = vec4(texcoord, -1.0, 1.0);\n"
"    vec3 t = vec3(SMAA_RT_METRICS.xy, 1.0);\n"
"    while (coord.z < float(SMAA_MAX_SEARCH_STEPS_DIAG - 1) &&\n"
"           coord.w > 0.9) {\n"
"        coord.xyz = mad(t, vec3(dir, 1.0), coord.xyz);\n"
"        e = SMAASampleLevelZero(edgesTex, coord.xy).rg;\n"
"        coord.w = dot(e, vec2(0.5, 0.5));\n"
"    }\n"
"    return coord.zw;\n"
"}\n"
"\n"
"vec2 SMAASearchDiag2(SMAATexture2D(edgesTex), vec2 texcoord, vec2 dir, out vec2 e) {\n"
"    vec4 coord = vec4(texcoord, -1.0, 1.0);\n"
"    coord.x += 0.25 * SMAA_RT_METRICS.x; // See @SearchDiag2Optimization\n"
"    vec3 t = vec3(SMAA_RT_METRICS.xy, 1.0);\n"
"    while (coord.z < float(SMAA_MAX_SEARCH_STEPS_DIAG - 1) &&\n"
"           coord.w > 0.9) {\n"
"        coord.xyz = mad(t, vec3(dir, 1.0), coord.xyz);\n"
"\n"
"        // @SearchDiag2Optimization\n"
"        // Fetch both edges at once using bilinear filtering:\n"
"        e = SMAASampleLevelZero(edgesTex, coord.xy).rg;\n"
"        e = SMAADecodeDiagBilinearAccess(e);\n"
"\n"
"        // Non-optimized version:\n"
"        // e.g = SMAASampleLevelZero(edgesTex, coord.xy).g;\n"
"        // e.r = SMAASampleLevelZeroOffset(edgesTex, coord.xy, int2(1, 0)).r;\n"
"\n"
"        coord.w = dot(e, vec2(0.5, 0.5));\n"
"    }\n"
"    return coord.zw;\n"
"}\n"
"\n"
"/**\n"
" * Similar to SMAAArea, this calculates the area corresponding to a certain\n"
" * diagonal distance and crossing edges \'e\'.\n"
" */\n"
"vec2 SMAAAreaDiag(SMAATexture2D(areaTex), vec2 dist, vec2 e, float offset) {\n"
"    vec2 texcoord = mad(vec2(SMAA_AREATEX_MAX_DISTANCE_DIAG, SMAA_AREATEX_MAX_DISTANCE_DIAG), e, dist);\n"
"\n"
"    // We do a scale and bias for mapping to texel space:\n"
"    texcoord = mad(SMAA_AREATEX_PIXEL_SIZE, texcoord, 0.5 * SMAA_AREATEX_PIXEL_SIZE);\n"
"\n"
"    // Diagonal areas are on the second half of the texture:\n"
"    texcoord.x += 0.5;\n"
"\n"
"    // Move to proper place, according to the subpixel offset:\n"
"    texcoord.y += SMAA_AREATEX_SUBTEX_SIZE * offset;\n"
"\n"
"    // Do it!\n"
"    return SMAA_AREATEX_SELECT(SMAASampleLevelZero(areaTex, texcoord));\n"
"}\n"
"\n"
"/**\n"
" * This searches for diagonal patterns and returns the corresponding weights.\n"
" */\n"
"vec2 SMAACalculateDiagWeights(SMAATexture2D(edgesTex), SMAATexture2D(areaTex), vec2 texcoord, vec2 e, vec4 subsampleIndices) {\n"
"    vec2 weights = vec2(0.0, 0.0);\n"
"\n"
"    // Search for the line ends:\n"
"    vec4 d;\n"
"    vec2 end;\n"
"    if (e.r > 0.0) {\n"
"        d.xz = SMAASearchDiag1(SMAATexturePass2D(edgesTex), texcoord, vec2(-1.0,  1.0), end);\n"
"        d.x += float(end.y > 0.9);\n"
"    } else\n"
"        d.xz = vec2(0.0, 0.0);\n"
"    d.yw = SMAASearchDiag1(SMAATexturePass2D(edgesTex), texcoord, vec2(1.0, -1.0), end);\n"
"\n"
"    SMAA_BRANCH\n"
"    if (d.x + d.y > 2.0) { // d.x + d.y + 1 > 3\n"
"        // Fetch the crossing edges:\n"
"        vec4 coords = mad(vec4(-d.x + 0.25, d.x, d.y, -d.y - 0.25), SMAA_RT_METRICS.xyxy, texcoord.xyxy);\n"
"        vec4 c;\n"
"        c.xy = SMAASampleLevelZeroOffset(edgesTex, coords.xy, int2(-1,  0)).rg;\n"
"        c.zw = SMAASampleLevelZeroOffset(edgesTex, coords.zw, int2( 1,  0)).rg;\n"
"        c.yxwz = SMAADecodeDiagBilinearAccess(c.xyzw);\n"
"\n"
"        // Non-optimized version:\n"
"        // vec4 coords = mad(vec4(-d.x, d.x, d.y, -d.y), SMAA_RT_METRICS.xyxy, texcoord.xyxy);\n"
"        // vec4 c;\n"
"        // c.x = SMAASampleLevelZeroOffset(edgesTex, coords.xy, int2(-1,  0)).g;\n"
"        // c.y = SMAASampleLevelZeroOffset(edgesTex, coords.xy, int2( 0,  0)).r;\n"
"        // c.z = SMAASampleLevelZeroOffset(edgesTex, coords.zw, int2( 1,  0)).g;\n"
"        // c.w = SMAASampleLevelZeroOffset(edgesTex, coords.zw, int2( 1, -1)).r;\n"
"\n"
"        // Merge crossing edges at each side into a single value:\n"
"        vec2 cc = mad(vec2(2.0, 2.0), c.xz, c.yw);\n"
"\n"
"        // Remove the crossing edge if we didn\'t found the end of the line:\n"
"        SMAAMovc(bool2(step(0.9, d.zw)), cc, vec2(0.0, 0.0));\n"
"\n"
"        // Fetch the areas for this line:\n"
"        weights += SMAAAreaDiag(SMAATexturePass2D(areaTex), d.xy, cc, subsampleIndices.z);\n"
"    }\n"
"\n"
"    // Search for the line ends:\n"
"    d.xz = SMAASearchDiag2(SMAATexturePass2D(edgesTex), texcoord, vec2(-1.0, -1.0), end);\n"
"    if (SMAASampleLevelZeroOffset(edgesTex, texcoord, int2(1, 0)).r > 0.0) {\n"
"        d.yw = SMAASearchDiag2(SMAATexturePass2D(edgesTex), texcoord, vec2(1.0, 1.0), end);\n"
"        d.y += float(end.y > 0.9);\n"
"    } else\n"
"        d.yw = vec2(0.0, 0.0);\n"
"\n"
"    SMAA_BRANCH\n"
"    if (d.x + d.y > 2.0) { // d.x + d.y + 1 > 3\n"
"        // Fetch the crossing edges:\n"
"        vec4 coords = mad(vec4(-d.x, -d.x, d.y, d.y), SMAA_RT_METRICS.xyxy, texcoord.xyxy);\n"
"        vec4 c;\n"
"        c.x  = SMAASampleLevelZeroOffset(edgesTex, coords.xy, int2(-1,  0)).g;\n"
"        c.y  = SMAASampleLevelZeroOffset(edgesTex, coords.xy, int2( 0, -1)).r;\n"
"        c.zw = SMAASampleLevelZeroOffset(edgesTex, coords.zw, int2( 1,  0)).gr;\n"
"        vec2 cc = mad(vec2(2.0, 2.0), c.xz, c.yw);\n"
"\n"
"        // Remove the crossing edge if we didn\'t found the end of the line:\n"
"        SMAAMovc(bool2(step(0.9, d.zw)), cc, vec2(0.0, 0.0));\n"
"\n"
"        // Fetch the areas for this line:\n"
"        weights += SMAAAreaDiag(SMAATexturePass2D(areaTex), d.xy, cc, subsampleIndices.w).gr;\n"
"    }\n"
"\n"
"    return weights;\n"
"}\n"
"#endif\n"
"\n"
"//-----------------------------------------------------------------------------\n"
"// Horizontal/Vertical Search Functions\n"
"\n"
"/**\n"
" * This allows to determine how much length should we add in the last step\n"
" * of the searches. It takes the bilinearly interpolated edge (see\n"
" * @PSEUDO_GATHER4), and adds 0, 1 or 2, depending on which edges and\n"
" * crossing edges are active.\n"
" */\n"
"float SMAASearchLength(SMAATexture2D(searchTex), vec2 e, float offset) {\n"
"    // The texture is flipped vertically, with left and right cases taking half\n"
"    // of the space horizontally:\n"
"    vec2 scale = SMAA_SEARCHTEX_SIZE * vec2(0.5, -1.0);\n"
"    vec2 bias = SMAA_SEARCHTEX_SIZE * vec2(offset, 1.0);\n"
"\n"
"    // Scale and bias to access texel centers:\n"
"    scale += vec2(-1.0,  1.0);\n"
"    bias  += vec2( 0.5, -0.5);\n"
"\n"
"    // Convert from pixel coordinates to texcoords:\n"
"    // (We use SMAA_SEARCHTEX_PACKED_SIZE because the texture is cropped)\n"
"    scale *= 1.0 / SMAA_SEARCHTEX_PACKED_SIZE;\n"
"    bias *= 1.0 / SMAA_SEARCHTEX_PACKED_SIZE;\n"
"\n"
"    // Lookup the search texture:\n"
"    return SMAA_SEARCHTEX_SELECT(SMAASampleLevelZero(searchTex, mad(scale, e, bias)));\n"
"}\n"
"\n"
"/**\n"
" * Horizontal/vertical search functions for the 2nd pass.\n"
" */\n"
"float SMAASearchXLeft(SMAATexture2D(edgesTex), SMAATexture2D(searchTex), vec2 texcoord, float end) {\n"
"    /**\n"
"     * @PSEUDO_GATHER4\n"
"     * This texcoord has been offset by (-0.25, -0.125) in the vertex shader to\n"
"     * sample between edge, thus fetching four edges in a row.\n"
"     * Sampling with different offsets in each direction allows to disambiguate\n"
"     * which edges are active from the four fetched ones.\n"
"     */\n"
"    vec2 e = vec2(0.0, 1.0);\n"
"    while (texcoord.x > end &&\n"
"           e.g > 0.8281 && // Is there some edge not activated?\n"
"           e.r == 0.0) { // Or is there a crossing edge that breaks the line?\n"
"        e = SMAASampleLevelZero(edgesTex, texcoord).rg;\n"
"        texcoord = mad(-vec2(2.0, 0.0), SMAA_RT_METRICS.xy, texcoord);\n"
"    }\n"
"\n"
"    float offset = mad(-(255.0 / 127.0), SMAASearchLength(SMAATexturePass2D(searchTex), e, 0.0), 3.25);\n"
"    return mad(SMAA_RT_METRICS.x, offset, texcoord.x);\n"
"\n"
"    // Non-optimized version:\n"
"    // We correct the previous (-0.25, -0.125) offset we applied:\n"
"    // texcoord.x += 0.25 * SMAA_RT_METRICS.x;\n"
"\n"
"    // The searches are bias by 1, so adjust the coords accordingly:\n"
"    // texcoord.x += SMAA_RT_METRICS.x;\n"
"\n"
"    // Disambiguate the length added by the last step:\n"
"    // texcoord.x += 2.0 * SMAA_RT_METRICS.x; // Undo last step\n"
"    // texcoord.x -= SMAA_RT_METRICS.x * (255.0 / 127.0) * SMAASearchLength(SMAATexturePass2D(searchTex), e, 0.0);\n"
"    // return mad(SMAA_RT_METRICS.x, offset, texcoord.x);\n"
"}\n"
"\n"
"float SMAASearchXRight(SMAATexture2D(edgesTex), SMAATexture2D(searchTex), vec2 texcoord, float end) {\n"
"    vec2 e = vec2(0.0, 1.0);\n"
"    while (texcoord.x < end &&\n"
"           e.g > 0.8281 && // Is there some edge not activated?\n"
"           e.r == 0.0) { // Or is there a crossing edge that breaks the line?\n"
"        e = SMAASampleLevelZero(edgesTex, texcoord).rg;\n"
"        texcoord = mad(vec2(2.0, 0.0), SMAA_RT_METRICS.xy, texcoord);\n"
"    }\n"
"    float offset = mad(-(255.0 / 127.0), SMAASearchLength(SMAATexturePass2D(searchTex), e, 0.5), 3.25);\n"
"    return mad(-SMAA_RT_METRICS.x, offset, texcoord.x);\n"
"}\n"
"\n"
"float SMAASearchYUp(SMAATexture2D(edgesTex), SMAATexture2D(searchTex), vec2 texcoord, float end) {\n"
"    vec2 e = vec2(1.0, 0.0);\n"
"    while (texcoord.y > end &&\n"
"           e.r > 0.8281 && // Is there some edge not activated?\n"
"           e.g == 0.0) { // Or is there a crossing edge that breaks the line?\n"
"        e = SMAASampleLevelZero(edgesTex, texcoord).rg;\n"
"        texcoord = mad(-vec2(0.0, 2.0), SMAA_RT_METRICS.xy, texcoord);\n"
"    }\n"
"    float offset = mad(-(255.0 / 127.0), SMAASearchLength(SMAATexturePass2D(searchTex), e.gr, 0.0), 3.25);\n"
"    return mad(SMAA_RT_METRICS.y, offset, texcoord.y);\n"
"}\n"
"\n"
"float SMAASearchYDown(SMAATexture2D(edgesTex), SMAATexture2D(searchTex), vec2 texcoord, float end) {\n"
"    vec2 e = vec2(1.0, 0.0);\n"
"    while (texcoord.y < end &&\n"
"           e.r > 0.8281 && // Is there some edge not activated?\n"
"           e.g == 0.0) { // Or is there a crossing edge that breaks the line?\n"
"        e = SMAASampleLevelZero(edgesTex, texcoord).rg;\n"
"        texcoord = mad(vec2(0.0, 2.0), SMAA_RT_METRICS.xy, texcoord);\n"
"    }\n"
"    float offset = mad(-(255.0 / 127.0), SMAASearchLength(SMAATexturePass2D(searchTex), e.gr, 0.5), 3.25);\n"
"    return mad(-SMAA_RT_METRICS.y, offset, texcoord.y);\n"
"}\n"
"\n"
"/**\n"
" * Ok, we have the distance and both crossing edges. So, what are the areas\n"
" * at each side of current edge?\n"
" */\n"
"vec2 SMAAArea(SMAATexture2D(areaTex), vec2 dist, float e1, float e2, float offset) {\n"
"    // Rounding prevents precision errors of bilinear filtering:\n"
"    vec2 texcoord = mad(vec2(SMAA_AREATEX_MAX_DISTANCE, SMAA_AREATEX_MAX_DISTANCE), round(4.0 * vec2(e1, e2)), dist);\n"
"\n"
"    // We do a scale and bias for mapping to texel space:\n"
"    texcoord = mad(SMAA_AREATEX_PIXEL_SIZE, texcoord, 0.5 * SMAA_AREATEX_PIXEL_SIZE);\n"
"\n"
"    // Move to proper place, according to the subpixel offset:\n"
"    texcoord.y = mad(SMAA_AREATEX_SUBTEX_SIZE, offset, texcoord.y);\n"
"\n"
"    // Do it!\n"
"    return SMAA_AREATEX_SELECT(SMAASampleLevelZero(areaTex, texcoord));\n"
"}\n"
"\n"
"//-----------------------------------------------------------------------------\n"
"// Corner Detection Functions\n"
"\n"
"void SMAADetectHorizontalCornerPattern(SMAATexture2D(edgesTex), inout vec2 weights, vec4 texcoord, vec2 d) {\n"
"    #if !defined(SMAA_DISABLE_CORNER_DETECTION)\n"
"    vec2 leftRight = step(d.xy, d.yx);\n"
"    vec2 rounding = (1.0 - SMAA_CORNER_ROUNDING_NORM) * leftRight;\n"
"\n"
"    rounding /= leftRight.x + leftRight.y; // Reduce blending for pixels in the center of a line.\n"
"\n"
"    vec2 factor = vec2(1.0, 1.0);\n"
"    factor.x -= rounding.x * SMAASampleLevelZeroOffset(edgesTex, texcoord.xy, int2(0,  1)).r;\n"
"    factor.x -= rounding.y * SMAASampleLevelZeroOffset(edgesTex, texcoord.zw, int2(1,  1)).r;\n"
"    factor.y -= rounding.x * SMAASampleLevelZeroOffset(edgesTex, texcoord.xy, int2(0, -2)).r;\n"
"    factor.y -= rounding.y * SMAASampleLevelZeroOffset(edgesTex, texcoord.zw, int2(1, -2)).r;\n"
"\n"
"    weights *= saturate(factor);\n"
"    #endif\n"
"}\n"
"\n"
"void SMAADetectVerticalCornerPattern(SMAATexture2D(edgesTex), inout vec2 weights, vec4 texcoord, vec2 d) {\n"
"    #if !defined(SMAA_DISABLE_CORNER_DETECTION)\n"
"    vec2 leftRight = step(d.xy, d.yx);\n"
"    vec2 rounding = (1.0 - SMAA_CORNER_ROUNDING_NORM) * leftRight;\n"
"\n"
"    rounding /= leftRight.x + leftRight.y;\n"
"\n"
"    vec2 factor = vec2(1.0, 1.0);\n"
"    factor.x -= rounding.x * SMAASampleLevelZeroOffset(edgesTex, texcoord.xy, int2( 1, 0)).g;\n"
"    factor.x -= rounding.y * SMAASampleLevelZeroOffset(edgesTex, texcoord.zw, int2( 1, 1)).g;\n"
"    factor.y -= rounding.x * SMAASampleLevelZeroOffset(edgesTex, texcoord.xy, int2(-2, 0)).g;\n"
"    factor.y -= rounding.y * SMAASampleLevelZeroOffset(edgesTex, texcoord.zw, int2(-2, 1)).g;\n"
"\n"
"    weights *= saturate(factor);\n"
"    #endif\n"
"}\n"
"\n"
"//-----------------------------------------------------------------------------\n"
"// Blending Weight Calculation Pixel Shader (Second Pass)\n"
"\n"
"vec4 SMAABlendingWeightCalculationPS(vec2 texcoord,\n"
"                                       vec2 pixcoord,\n"
"                                       vec4 offset[3],\n"
"                                       SMAATexture2D(edgesTex),\n"
"                                       SMAATexture2D(areaTex),\n"
"                                       SMAATexture2D(searchTex),\n"
"                                       vec4 subsampleIndices) { // Just pass zero for SMAA 1x, see @SUBSAMPLE_INDICES.\n"
"    vec4 weights = vec4(0.0, 0.0, 0.0, 0.0);\n"
"\n"
"    vec2 e = SMAASample(edgesTex, texcoord).rg;\n"
"\n"
"    SMAA_BRANCH\n"
"    if (e.g > 0.0) { // Edge at north\n"
"        #if !defined(SMAA_DISABLE_DIAG_DETECTION)\n"
"        // Diagonals have both north and west edges, so searching for them in\n"
"        // one of the boundaries is enough.\n"
"        weights.rg = SMAACalculateDiagWeights(SMAATexturePass2D(edgesTex), SMAATexturePass2D(areaTex), texcoord, e, subsampleIndices);\n"
"\n"
"        // We give priority to diagonals, so if we find a diagonal we skip\n"
"        // horizontal/vertical processing.\n"
"        SMAA_BRANCH\n"
"        if (weights.r == -weights.g) { // weights.r + weights.g == 0.0\n"
"        #endif\n"
"\n"
"        vec2 d;\n"
"\n"
"        // Find the distance to the left:\n"
"        vec3 coords;\n"
"        coords.x = SMAASearchXLeft(SMAATexturePass2D(edgesTex), SMAATexturePass2D(searchTex), offset[0].xy, offset[2].x);\n"
"        coords.y = offset[1].y; // offset[1].y = texcoord.y - 0.25 * SMAA_RT_METRICS.y (@CROSSING_OFFSET)\n"
"        d.x = coords.x;\n"
"\n"
"        // Now fetch the left crossing edges, two at a time using bilinear\n"
"        // filtering. Sampling at -0.25 (see @CROSSING_OFFSET) enables to\n"
"        // discern what value each edge has:\n"
"        float e1 = SMAASampleLevelZero(edgesTex, coords.xy).r;\n"
"\n"
"        // Find the distance to the right:\n"
"        coords.z = SMAASearchXRight(SMAATexturePass2D(edgesTex), SMAATexturePass2D(searchTex), offset[0].zw, offset[2].y);\n"
"        d.y = coords.z;\n"
"\n"
"        // We want the distances to be in pixel units (doing this here allow to\n"
"        // better interleave arithmetic and memory accesses):\n"
"        d = abs(round(mad(SMAA_RT_METRICS.zz, d, -pixcoord.xx)));\n"
"\n"
"        // SMAAArea below needs a sqrt, as the areas texture is compressed\n"
"        // quadratically:\n"
"        vec2 sqrt_d = sqrt(d);\n"
"\n"
"        // Fetch the right crossing edges:\n"
"        float e2 = SMAASampleLevelZeroOffset(edgesTex, coords.zy, int2(1, 0)).r;\n"
"\n"
"        // Ok, we know how this pattern looks like, now it is time for getting\n"
"        // the actual area:\n"
"        weights.rg = SMAAArea(SMAATexturePass2D(areaTex), sqrt_d, e1, e2, subsampleIndices.y);\n"
"\n"
"        // Fix corners:\n"
"        coords.y = texcoord.y;\n"
"        SMAADetectHorizontalCornerPattern(SMAATexturePass2D(edgesTex), weights.rg, coords.xyzy, d);\n"
"\n"
"        #if !defined(SMAA_DISABLE_DIAG_DETECTION)\n"
"        } else\n"
"            e.r = 0.0; // Skip vertical processing.\n"
"        #endif\n"
"    }\n"
"\n"
"    SMAA_BRANCH\n"
"    if (e.r > 0.0) { // Edge at west\n"
"        vec2 d;\n"
"\n"
"        // Find the distance to the top:\n"
"        vec3 coords;\n"
"        coords.y = SMAASearchYUp(SMAATexturePass2D(edgesTex), SMAATexturePass2D(searchTex), offset[1].xy, offset[2].z);\n"
"        coords.x = offset[0].x; // offset[1].x = texcoord.x - 0.25 * SMAA_RT_METRICS.x;\n"
"        d.x = coords.y;\n"
"\n"
"        // Fetch the top crossing edges:\n"
"        float e1 = SMAASampleLevelZero(edgesTex, coords.xy).g;\n"
"\n"
"        // Find the distance to the bottom:\n"
"        coords.z = SMAASearchYDown(SMAATexturePass2D(edgesTex), SMAATexturePass2D(searchTex), offset[1].zw, offset[2].w);\n"
"        d.y = coords.z;\n"
"\n"
"        // We want the distances to be in pixel units:\n"
"        d = abs(round(mad(SMAA_RT_METRICS.ww, d, -pixcoord.yy)));\n"
"\n"
"        // SMAAArea below needs a sqrt, as the areas texture is compressed\n"
"        // quadratically:\n"
"        vec2 sqrt_d = sqrt(d);\n"
"\n"
"        // Fetch the bottom crossing edges:\n"
"        float e2 = SMAASampleLevelZeroOffset(edgesTex, coords.xz, int2(0, 1)).g;\n"
"\n"
"        // Get the area for this direction:\n"
"        weights.ba = SMAAArea(SMAATexturePass2D(areaTex), sqrt_d, e1, e2, subsampleIndices.x);\n"
"\n"
"        // Fix corners:\n"
"        coords.x = texcoord.x;\n"
"        SMAADetectVerticalCornerPattern(SMAATexturePass2D(edgesTex), weights.ba, coords.xyxz, d);\n"
"    }\n"
"\n"
"    return weights;\n"
"}\n"
"\n"
"//-----------------------------------------------------------------------------\n"
"// Neighborhood Blending Pixel Shader (Third Pass)\n"
"\n"
"vec4 SMAANeighborhoodBlendingPS(vec2 texcoord,\n"
"                                  vec4 offset,\n"
"                                  SMAATexture2D(colorTex),\n"
"                                  SMAATexture2D(blendTex)\n"
"                                  #if SMAA_REPROJECTION\n"
"                                  , SMAATexture2D(velocityTex)\n"
"                                  #endif\n"
"                                  ) {\n"
"    // Fetch the blending weights for current pixel:\n"
"    vec4 a;\n"
"    a.x = SMAASample(blendTex, offset.xy).a; // Right\n"
"    a.y = SMAASample(blendTex, offset.zw).g; // Top\n"
"    a.wz = SMAASample(blendTex, texcoord).xz; // Bottom / Left\n"
"\n"
"    // Is there any blending weight with a value greater than 0.0?\n"
"    SMAA_BRANCH\n"
"    if (dot(a, vec4(1.0, 1.0, 1.0, 1.0)) < 1e-5) {\n"
"        vec4 color = SMAASampleLevelZero(colorTex, texcoord);\n"
"\n"
"        #if SMAA_REPROJECTION\n"
"        vec2 velocity = SMAA_DECODE_VELOCITY(SMAASampleLevelZero(velocityTex, texcoord));\n"
"\n"
"        // Pack velocity into the alpha channel:\n"
"        color.a = sqrt(5.0 * length(velocity));\n"
"        #endif\n"
"\n"
"        return color;\n"
"    } else {\n"
"        bool h = max(a.x, a.z) > max(a.y, a.w); // max(horizontal) > max(vertical)\n"
"\n"
"        // Calculate the blending offsets:\n"
"        vec4 blendingOffset = vec4(0.0, a.y, 0.0, a.w);\n"
"        vec2 blendingWeight = a.yw;\n"
"        SMAAMovc(bool4(h, h, h, h), blendingOffset, vec4(a.x, 0.0, a.z, 0.0));\n"
"        SMAAMovc(bool2(h, h), blendingWeight, a.xz);\n"
"        blendingWeight /= dot(blendingWeight, vec2(1.0, 1.0));\n"
"\n"
"        // Calculate the texture coordinates:\n"
"        vec4 blendingCoord = mad(blendingOffset, vec4(SMAA_RT_METRICS.xy, -SMAA_RT_METRICS.xy), texcoord.xyxy);\n"
"\n"
"        // We exploit bilinear filtering to mix current pixel with the chosen\n"
"        // neighbor:\n"
"        vec4 color = blendingWeight.x * SMAASampleLevelZero(colorTex, blendingCoord.xy);\n"
"        color += blendingWeight.y * SMAASampleLevelZero(colorTex, blendingCoord.zw);\n"
"\n"
"        #if SMAA_REPROJECTION\n"
"        // Antialias velocity for proper reprojection in a later stage:\n"
"        vec2 velocity = blendingWeight.x * SMAA_DECODE_VELOCITY(SMAASampleLevelZero(velocityTex, blendingCoord.xy));\n"
"        velocity += blendingWeight.y * SMAA_DECODE_VELOCITY(SMAASampleLevelZero(velocityTex, blendingCoord.zw));\n"
"\n"
"        // Pack velocity into the alpha channel:\n"
"        color.a = sqrt(5.0 * length(velocity));\n"
"        #endif\n"
"\n"
"        return color;\n"
"    }\n"
"}\n"
"\n"
"//-----------------------------------------------------------------------------\n"
"// Temporal Resolve Pixel Shader (Optional Pass)\n"
"\n"
"vec4 SMAAResolvePS(vec2 texcoord,\n"
"                     SMAATexture2D(currentColorTex),\n"
"                     SMAATexture2D(previousColorTex)\n"
"                     #if SMAA_REPROJECTION\n"
"                     , SMAATexture2D(velocityTex)\n"
"                     #endif\n"
"                     ) {\n"
"    #if SMAA_REPROJECTION\n"
"    // Velocity is assumed to be calculated for motion blur, so we need to\n"
"    // inverse it for reprojection:\n"
"    vec2 velocity = -SMAA_DECODE_VELOCITY(SMAASamplePoint(velocityTex, texcoord).rg);\n"
"\n"
"    // Fetch current pixel:\n"
"    vec4 current = SMAASamplePoint(currentColorTex, texcoord);\n"
"\n"
"    // Reproject current coordinates and fetch previous pixel:\n"
"    vec4 previous = SMAASamplePoint(previousColorTex, texcoord + velocity);\n"
"\n"
"    // Attenuate the previous pixel if the velocity is different:\n"
"    float delta = abs(current.a * current.a - previous.a * previous.a) / 5.0;\n"
"    float weight = 0.5 * saturate(1.0 - sqrt(delta) * SMAA_REPROJECTION_WEIGHT_SCALE);\n"
"\n"
"    // Blend the pixels according to the calculated weight:\n"
"    return lerp(current, previous, weight);\n"
"    #else\n"
"    // Just blend the pixels:\n"
"    vec4 current = SMAASamplePoint(currentColorTex, texcoord);\n"
"    vec4 previous = SMAASamplePoint(previousColorTex, texcoord);\n"
"    return lerp(current, previous, 0.5);\n"
"    #endif\n"
"}\n"
"\n"
"//-----------------------------------------------------------------------------\n"
"// Separate Multisamples Pixel Shader (Optional Pass)\n"
"\n"
"#ifdef SMAALoad\n"
"void SMAASeparatePS(vec4 position,\n"
"                    vec2 texcoord,\n"
"                    out vec4 target0,\n"
"                    out vec4 target1,\n"
"                    SMAATexture2DMS2(colorTexMS)) {\n"
"    int2 pos = int2(position.xy);\n"
"    target0 = SMAALoad(colorTexMS, pos, 0);\n"
"    target1 = SMAALoad(colorTexMS, pos, 1);\n"
"}\n"
"#endif\n"
"\n"
"//-----------------------------------------------------------------------------\n"
;

const char *fallbackShader_SMAA_vp =
"//-----------------------------------------------------------------------------\n"
"// Vertex Shaders\n"
"\n"
"/**\n"
" * Edge Detection Vertex Shader\n"
" */\n"
"void SMAAEdgeDetectionVS(float2 texcoord,\n"
"                         out float4 offset[3]) {\n"
"    offset[0] = mad(SMAA_RT_METRICS.xyxy, float4(-1.0, 0.0, 0.0, -1.0), texcoord.xyxy);\n"
"    offset[1] = mad(SMAA_RT_METRICS.xyxy, float4( 1.0, 0.0, 0.0,  1.0), texcoord.xyxy);\n"
"    offset[2] = mad(SMAA_RT_METRICS.xyxy, float4(-2.0, 0.0, 0.0, -2.0), texcoord.xyxy);\n"
"}\n"
"\n"
"/**\n"
" * Blend Weight Calculation Vertex Shader\n"
" */\n"
"void SMAABlendingWeightCalculationVS(float2 texcoord,\n"
"                                     out float2 pixcoord,\n"
"                                     out float4 offset[3]) {\n"
"    pixcoord = texcoord * SMAA_RT_METRICS.zw;\n"
"\n"
"    // We will use these offsets for the searches later on (see @PSEUDO_GATHER4):\n"
"    offset[0] = mad(SMAA_RT_METRICS.xyxy, float4(-0.25, -0.125,  1.25, -0.125), texcoord.xyxy);\n"
"    offset[1] = mad(SMAA_RT_METRICS.xyxy, float4(-0.125, -0.25, -0.125,  1.25), texcoord.xyxy);\n"
"\n"
"    // And these for the searches, they indicate the ends of the loops:\n"
"    offset[2] = mad(SMAA_RT_METRICS.xxyy,\n"
"                    float4(-2.0, 2.0, -2.0, 2.0) * float(SMAA_MAX_SEARCH_STEPS),\n"
"                    float4(offset[0].xz, offset[1].yw));\n"
"}\n"
"\n"
"/**\n"
" * Neighborhood Blending Vertex Shader\n"
" */\n"
"void SMAANeighborhoodBlendingVS(float2 texcoord,\n"
"                                out float4 offset) {\n"
"    offset = mad(SMAA_RT_METRICS.xyxy, float4( 1.0, 0.0, 0.0,  1.0), texcoord.xyxy);\n"
"}\n"
;

const char *fallbackShader_texturecolor_vp =
"in vec3 a_Position;\n"
"in vec2 a_TexCoords;\n"
"\n"
"uniform mat4 u_ModelViewProjection;\n"
"\n"
"out vec2 v_TexCoords;\n"
"\n"
"void main() {\n"
"	gl_Position = u_ModelViewProjection * vec4( a_Position, 1.0 );\n"
"	v_TexCoords = a_TexCoords;\n"
"}\n"
;

const char *fallbackShader_SMAAEdges_vp =
"#define mad( a, b, c ) ( a * b + c )\n"
"\n"
"in vec3 a_Position;\n"
"\n"
"uniform vec2 u_ScreenSize;\n"
"\n"
"out vec2 v_TexCoords;\n"
"out vec4 v_Offset[3];\n"
"\n"
"void main() {\n"
"    vec4 SMAA_RT_METRICS = vec4( 1.0 / u_ScreenSize.x, 1.0 / u_ScreenSize.y, u_ScreenSize.x, u_ScreenSize.y );\n"
"\n"
"    v_TexCoords = vec2( ( a_Position + 1.0 ) / 2.0 );\n"
"\n"
"    v_Offset[0] = mad( SMAA_RT_METRICS.xyxy, vec4( -1.0, 0.0, 0.0, -1.0 ), v_TexCoords.xyxy );\n"
"    v_Offset[1] = mad( SMAA_RT_METRICS.xyxy, vec4(  1.0, 0.0, 0.0,  1.0 ), v_TexCoords.xyxy );\n"
"    v_Offset[2] = mad( SMAA_RT_METRICS.xyxy, vec4( -2.0, 0.0, 0.0, -2.0 ), v_TexCoords.xyxy );\n"
"\n"
"    gl_Position = vec4( a_Position, 0.0, 1.0 );\n"
"}\n"
;

const char *fallbackShader_generic_vp =
"in vec3 a_Position;\n"
"in vec3 a_WorldPos;\n"
"in vec2 a_TexCoords;\n"
"in vec4 a_Color;\n"
"\n"
"out vec2 v_TexCoords;\n"
"out vec3 v_FragPos;\n"
"out vec4 v_Color;\n"
"out vec3 v_WorldPos;\n"
"\n"
"uniform mat4 u_ModelViewProjection;\n"
"uniform vec4 u_BaseColor;\n"
"uniform vec4 u_VertColor;\n"
"\n"
"uniform mat4 u_ModelMatrix;\n"
"\n"
"#if defined(USE_RGBAGEN)\n"
"uniform int u_ColorGen;\n"
"uniform int u_AlphaGen;\n"
"uniform vec3 u_DirectedLight;\n"
"#endif\n"
"\n"
"#if defined(USE_TCGEN)\n"
"uniform vec4 u_DiffuseTexMatrix;\n"
"uniform vec4 u_DiffuseTexOffTurb;\n"
"#endif\n"
"\n"
"#if defined(USE_TCGEN)\n"
"uniform int u_TCGen0;\n"
"uniform vec3 u_TCGen0Vector0;\n"
"uniform vec3 u_TCGen0Vector1;\n"
"uniform vec3 u_WorldPos;\n"
"#endif\n"
"\n"
"#if defined(USE_RGBAGEN) && 0\n"
"vec4 CalcColor(vec3 position, vec3 normal)\n"
"{\n"
"	vec4 color = u_VertColor * a_Color + u_BaseColor;\n"
"\n"
"	if (u_ColorGen == CGEN_LIGHTING_DIFFUSE)\n"
"	{\n"
"		float incoming = clamp(dot(normal, u_ModelLightDir), 0.0, 1.0);\n"
"\n"
"		color.rgb = clamp(u_DirectedLight * incoming + u_AmbientLight, 0.0, 1.0);\n"
"	}\n"
"\n"
"	vec3 viewer = u_LocalViewOrigin - position;\n"
"\n"
"	if ( u_AlphaGen == AGEN_LIGHTING_SPECULAR ) {\n"
"		vec3 lightDir = normalize(vec3(-960.0, 1980.0, 96.0) - position);\n"
"		vec3 reflected = -reflect(lightDir, normal);\n"
"\n"
"		color.a = clamp(dot(reflected, normalize(viewer)), 0.0, 1.0);\n"
"		color.a *= color.a;\n"
"		color.a *= color.a;\n"
"	}\n"
"\n"
"	return color;\n"
"}\n"
"#endif\n"
"\n"
"#if defined(USE_TCMOD)\n"
"vec2 ModTexCoords( vec2 st, vec3 position, vec4 texMatrix, vec4 offTurb )\n"
"{\n"
"	float amplitude = offTurb.z;\n"
"	float phase = offTurb.w * 2.0 * M_PI;\n"
"	vec2 st2;\n"
"\n"
"	st2.x = st.x * texMatrix.x + ( st.y * texMatrix.z + offTurb.x );\n"
"	st2.y = st.x * texMatrix.y + ( st.y * texMatrix.w + offTurb.y );\n"
"\n"
"	vec2 offsetPos = vec2( position.x + position.z, position.y );\n"
"\n"
"	vec2 texOffset = sin( offsetPos * ( 2.0 * M_PI / 1024.0 ) + vec2( phase ) );\n"
"\n"
"	return st2 + texOffset * amplitude;\n"
"}\n"
"#endif\n"
"\n"
"float CalcLightAttenuation( float point, float normDist )\n"
"{\n"
"	// zero light at 1.0, approximating q3 style\n"
"	// also don\'t attenuate directional light\n"
"	float attenuation = ( 0.5 * normDist - 1.5 ) * point + 1.0;\n"
"\n"
"	// clamp attenuation\n"
"#if defined(NO_LIGHT_CLAMP)\n"
"	attenuation = max( attenuation, 0.0 );\n"
"#else\n"
"	attenuation = clamp( attenuation, 0.0, 1.0 );\n"
"#endif\n"
"\n"
"	return attenuation;\n"
"}\n"
"\n"
"#if defined(USE_TCGEN)\n"
"vec2 GenTexCoords( int TCGen, vec3 position, vec3 normal, vec3 TCGenVector0, vec3 TCGenVector1 )\n"
"{\n"
"	vec2 tex = a_TexCoords;\n"
"\n"
"	if ( TCGen == TCGEN_LIGHTMAP ) {\n"
"		tex = a_TexCoords.st;\n"
"	}\n"
"	else if ( TCGen == TCGEN_ENVIRONMENT_MAPPED ) {\n"
"		vec3 viewer = normalize( vec3( 0.0 ) - position );\n"
"		vec2 ref = reflect( viewer, normal ).yz;\n"
"		tex.s = ref.x * -0.5 + 0.5;\n"
"		tex.t = ref.y *  0.5 + 0.5;\n"
"	}\n"
"	else if ( TCGen == TCGEN_VECTOR ) {\n"
"		tex = vec2( dot( position, TCGenVector0 ), dot( position, TCGenVector1 ) );\n"
"	}\n"
"\n"
"	return tex;\n"
"}\n"
"#endif\n"
"\n"
"void main()\n"
"{\n"
"	if ( u_ColorGen == CGEN_VERTEX ) {\n"
"//		v_Color = vec4( 1.0 );\n"
"	}\n"
"	else {\n"
"//		v_Color = u_VertColor * a_Color + u_BaseColor;\n"
"	}\n"
"	v_Color = vec4( 1.0 );\n"
"\n"
"#if defined(USE_TCGEN)\n"
"	vec2 texCoords = GenTexCoords( u_TCGen0, a_Position, vec3( 0.0 ), u_TCGen0Vector0, u_TCGen0Vector1 );\n"
"#else\n"
"	vec2 texCoords = a_TexCoords;\n"
"#endif\n"
"\n"
"#if defined(USE_TCMOD)\n"
"	v_TexCoords = ModTexCoords( texCoords, a_Position, u_DiffuseTexMatrix, u_DiffuseTexOffTurb );\n"
"#else\n"
"	v_TexCoords = texCoords;\n"
"#endif\n"
"\n"
"	v_WorldPos = a_WorldPos;\n"
"\n"
"	v_FragPos = vec4( u_ModelViewProjection * vec4( a_Position, 1.0 ) ).xyz;\n"
"\n"
"    gl_Position = u_ModelViewProjection * vec4( a_Position, 1.0 );\n"
"}\n"
;

const char *fallbackShader_imgui_vp =
"in vec3 a_Position;\n"
"in vec2 a_TexCoords;\n"
"in vec4 a_Color;\n"
"\n"
"uniform mat4 u_ModelViewProjection;\n"
"uniform vec2 u_ScreenSize;\n"
"\n"
"out vec2 v_TexCoords;\n"
"out vec4 v_Color;\n"
"\n"
"#if defined(USE_SMAA)\n"
"#define mad(a,b,c) ( a * b + c )\n"
"#if defined(SMAA_PRESET_LOW)\n"
"#define SMAA_MAX_SEARCH_STEPS 4\n"
"#elif defined(SMAA_PRESET_MEDIUM)\n"
"#define SMAA_MAX_SEARCH_STEPS 8\n"
"#elif defined(SMAA_PRESET_HIGH)\n"
"#define SMAA_MAX_SEARCH_STEPS 16\n"
"#elif defined(SMAA_PRESET_ULTRA)\n"
"#define SMAA_MAX_SEARCH_STEPS 32\n"
"#endif\n"
"\n"
"#if defined(USE_SMAA)\n"
"#if !defined(SMAA_MAX_SEARCH_STEPS)\n"
"#define SMAA_MAX_SEARCH_STEPS 16\n"
"#endif\n"
"out vec4 v_Offset[3];\n"
"out vec2 v_PixCoord;\n"
"#endif\n"
"#endif\n"
"\n"
"#if defined(USE_TCGEN)\n"
"uniform vec4 u_DiffuseTexMatrix;\n"
"uniform vec4 u_DiffuseTexOffTurb;\n"
"#endif\n"
"\n"
"#if defined(USE_TCGEN)\n"
"uniform int u_TCGen0;\n"
"uniform vec3 u_TCGen0Vector0;\n"
"uniform vec3 u_TCGen0Vector1;\n"
"uniform vec3 u_WorldPos;\n"
"#endif\n"
"\n"
"\n"
"#if defined(USE_TCMOD)\n"
"vec2 ModTexCoords( vec2 st, vec3 position, vec4 texMatrix, vec4 offTurb )\n"
"{\n"
"	float amplitude = offTurb.z;\n"
"	float phase = offTurb.w * 2.0 * M_PI;\n"
"	vec2 st2;\n"
"\n"
"	st2.x = st.x * texMatrix.x + ( st.y * texMatrix.z + offTurb.x );\n"
"	st2.y = st.x * texMatrix.y + ( st.y * texMatrix.w + offTurb.y );\n"
"\n"
"	vec2 offsetPos = vec2( position.x + position.z, position.y );\n"
"\n"
"	vec2 texOffset = sin( offsetPos * ( 2.0 * M_PI / 1024.0 ) + vec2( phase ) );\n"
"\n"
"	return st2 + texOffset * amplitude;\n"
"}\n"
"#endif\n"
"\n"
"float CalcLightAttenuation( float point, float normDist )\n"
"{\n"
"	// zero light at 1.0, approximating q3 style\n"
"	// also don\'t attenuate directional light\n"
"	float attenuation = ( 0.5 * normDist - 1.5 ) * point + 1.0;\n"
"\n"
"	// clamp attenuation\n"
"#if defined(NO_LIGHT_CLAMP)\n"
"	attenuation = max( attenuation, 0.0 );\n"
"#else\n"
"	attenuation = clamp( attenuation, 0.0, 1.0 );\n"
"#endif\n"
"\n"
"	return attenuation;\n"
"}\n"
"\n"
"#if defined(USE_TCGEN)\n"
"vec2 GenTexCoords( int TCGen, vec3 position, vec3 normal, vec3 TCGenVector0, vec3 TCGenVector1 )\n"
"{\n"
"	vec2 tex = a_TexCoords;\n"
"\n"
"	if ( TCGen == TCGEN_LIGHTMAP ) {\n"
"		tex = a_TexCoords.st;\n"
"	}\n"
"	else if ( TCGen == TCGEN_ENVIRONMENT_MAPPED ) {\n"
"		vec3 viewer = normalize( vec3( 0.0 ) - position );\n"
"		vec2 ref = reflect( viewer, normal ).yz;\n"
"		tex.s = ref.x * -0.5 + 0.5;\n"
"		tex.t = ref.y *  0.5 + 0.5;\n"
"	}\n"
"	else if ( TCGen == TCGEN_VECTOR ) {\n"
"		tex = vec2( dot( position, TCGenVector0 ), dot( position, TCGenVector1 ) );\n"
"	}\n"
"\n"
"	return tex;\n"
"}\n"
"#endif\n"
"\n"
"void main() {\n"
"#if defined(USE_TCGEN)\n"
"	vec2 texCoords = GenTexCoords( u_TCGen0, a_Position, vec3( 0.0 ), u_TCGen0Vector0, u_TCGen0Vector1 );\n"
"#else\n"
"	vec2 texCoords = a_TexCoords;\n"
"#endif\n"
"#if defined(USE_TCMOD)\n"
"	v_TexCoords = ModTexCoords( texCoords, a_Position, u_DiffuseTexMatrix, u_DiffuseTexOffTurb );\n"
"#else\n"
"	v_TexCoords = texCoords;\n"
"#endif\n"
"    v_Color = a_Color;\n"
"\n"
"#if defined(USE_SMAA)\n"
"	vec4 SMAA_RT_METRICS = vec4( 1.0 / u_ScreenSize.x, 1.0 / u_ScreenSize.y, u_ScreenSize.x, u_ScreenSize.y );\n"
"\n"
"	vec2 texCoord = vec2( ( a_Position + 1.0 ) / 2.0 );\n"
"\n"
"	v_PixCoord = texCoord * SMAA_RT_METRICS.zw;\n"
"\n"
"	// We will use these offsets for the searches later on (see @PSEUDO_GATHER4):\n"
"	v_Offset[0] = mad(SMAA_RT_METRICS.xyxy, vec4(-0.25, -0.125,  1.25, -0.125), texCoord.xyxy);\n"
"	v_Offset[1] = mad(SMAA_RT_METRICS.xyxy, vec4(-0.125, -0.25, -0.125,  1.25), texCoord.xyxy);\n"
"\n"
"	// And these for the searches, they indicate the ends of the loops:\n"
"	v_Offset[2] = mad(\n"
"		SMAA_RT_METRICS.xxyy,\n"
"		vec4(-2.0, 2.0, -2.0, 2.0) * float(SMAA_MAX_SEARCH_STEPS),\n"
"		vec4(v_Offset[0].xz, v_Offset[1].yw)\n"
"	);\n"
"#endif\n"
"\n"
"    gl_Position = u_ModelViewProjection * vec4( a_Position.xy, 0.0, 1.0 );\n"
"}\n"
;

const char *fallbackShader_tile_fp =
"#if !defined(GLSL_LEGACY)\n"
"layout( location = 0 ) out vec4 a_Color;\n"
"#if defined(USE_HDR) && defined(USE_BLOOM)\n"
"layout( location = 1 ) out vec4 a_BrightColor;\n"
"#endif\n"
"#endif\n"
"\n"
"#if !defined(FXAA_PRESET)\n"
"    #define FXAA_PRESET 5\n"
"#endif\n"
"#if FXAA_PRESET == 3\n"
"    #define FXAA_EDGE_THRESHOLD      ( 1.0 / 8.0 )\n"
"    #define FXAA_EDGE_THRESHOLD_MIN  ( 1.0 / 16.0 )\n"
"    #define FXAA_SEARCH_STEPS        16\n"
"    #define FXAA_SEARCH_THRESHOLD    ( 1.0 / 4.0 )\n"
"    #define FXAA_SUBPIX_CAP          ( 3.0 / 4.0 )\n"
"    #define FXAA_SUBPIX_TRIM         ( 1.0 / 4.0 )\n"
"#elif FXAA_PRESET == 4\n"
"    #define FXAA_EDGE_THRESHOLD      ( 1.0 / 8.0 )\n"
"    #define FXAA_EDGE_THRESHOLD_MIN  ( 1.0 / 24.0 )\n"
"    #define FXAA_SEARCH_STEPS        24\n"
"    #define FXAA_SEARCH_THRESHOLD    ( 1.0 / 4.0 )\n"
"    #define FXAA_SUBPIX_CAP          ( 3.0 / 4.0 )\n"
"    #define FXAA_SUBPIX_TRIM         ( 1.0 / 4.0 )\n"
"#elif FXAA_PRESET == 5\n"
"    #define FXAA_EDGE_THRESHOLD      ( 1.0 / 8.0 )\n"
"    #define FXAA_EDGE_THRESHOLD_MIN  ( 1.0 / 24.0 )\n"
"    #define FXAA_SEARCH_STEPS        32\n"
"    #define FXAA_SEARCH_THRESHOLD    ( 1.0 / 4.0 )\n"
"    #define FXAA_SUBPIX_CAP          ( 3.0 / 4.0 )\n"
"    #define FXAA_SUBPIX_TRIM         ( 1.0 / 4.0 )\n"
"#endif\n"
"\n"
"#define FXAA_SUBPIX_TRIM_SCALE ( 1.0 / ( 1.0 - FXAA_SUBPIX_TRIM ) )\n"
"\n"
"in vec2 v_TexCoords;\n"
"in vec3 v_FragPos;\n"
"in vec4 v_Color;\n"
"in vec3 v_WorldPos;\n"
"\n"
"uniform sampler2D u_DiffuseMap;\n"
"uniform float u_GammaAmount;\n"
"uniform bool u_GamePaused;\n"
"uniform bool u_HardwareGamma;\n"
"uniform int u_AntiAliasing;\n"
"\n"
"#if defined(USE_LIGHT)\n"
"uniform vec3 u_AmbientColor;\n"
"uniform float u_AmbientIntensity;\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"uniform vec4 u_SpecularScale;\n"
"uniform vec4 u_NormalScale;\n"
"uniform int u_NumLights;\n"
"\n"
"struct Light {\n"
"    vec4 color;\n"
"    uvec2 origin;\n"
"    float brightness;\n"
"    float range;\n"
"    float linear;\n"
"    float quadratic;\n"
"    float constant;\n"
"    int type;\n"
"};\n"
"layout( std140, binding = 0 ) uniform u_LightBuffer {\n"
"    Light u_LightData[MAX_MAP_LIGHTS];\n"
"};\n"
"#endif\n"
"\n"
"#if defined(USE_EXPOSURE_TONE_MAPPING)\n"
"uniform float u_CameraExposure;\n"
"#endif\n"
"\n"
"#if defined(USE_NORMALMAP)\n"
"uniform sampler2D u_NormalMap;\n"
"#endif\n"
"\n"
"#if defined(USE_SPECULARMAP)\n"
"uniform sampler2D u_SpecularMap;\n"
"#endif\n"
"\n"
"#if defined(USE_SHADOWMAP)\n"
"uniform sampler2D u_ShadowMap;\n"
"#endif\n"
"\n"
"#if defined(USE_FXAA)\n"
"uniform vec2 u_ScreenSize;\n"
"#endif\n"
"\n"
"uniform int u_AlphaTest;\n"
"\n"
"#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"//\n"
"// CalcPointLight: don\'t modify, straight from Valden\n"
"//\n"
"vec3 CalcPointLight( Light light ) {\n"
"    vec3 diffuse = a_Color.rgb;\n"
"    float dist = distance( v_WorldPos, vec3( light.origin, v_WorldPos.z ) );\n"
"    float diff = 0.0;\n"
"    float range = light.range;\n"
"    if ( dist <= light.range ) {\n"
"        diff = 1.0 - abs( dist / range );\n"
"    }\n"
"    diff += light.brightness;\n"
"    diffuse = min( diff * ( diffuse + vec3( light.color ) ), diffuse );\n"
"\n"
"    vec3 lightDir = vec3( 0.0 );\n"
"    vec3 viewDir = normalize( v_WorldPos - vec3( light.origin, 0.0 ) );\n"
"    vec3 halfwayDir = normalize( lightDir + viewDir );\n"
"\n"
"    vec3 reflectDir = reflect( -lightDir, v_WorldPos );\n"
"    float spec = pow( max( dot( v_WorldPos, reflectDir ), 0.0 ), 1.0 );\n"
"\n"
"#if defined(USE_SPECULARMAP)\n"
"    vec3 specular = spec * texture( u_SpecularMap, v_TexCoords ).rgb;\n"
"#else\n"
"    vec3 specular = vec3( 0.0 );\n"
"#endif\n"
"\n"
"    range = light.range + light.brightness;\n"
"    float attenuation = ( light.constant + light.linear * range\n"
"        + light.quadratic * ( range * range ) );\n"
"\n"
"    diffuse *= attenuation;\n"
"    specular *= attenuation;\n"
"\n"
"    return diffuse + specular;\n"
"}\n"
"#endif\n"
"\n"
"float CalcLightAttenuation(float point, float normDist)\n"
"{\n"
"	// zero light at 1.0, approximating q3 style\n"
"	// also don\'t attenuate directional light\n"
"	float attenuation = (0.5 * normDist - 1.5) * point + 1.0;\n"
"\n"
"	// clamp attenuation\n"
"	#if defined(NO_LIGHT_CLAMP)\n"
"	attenuation = max(attenuation, 0.0);\n"
"	#else\n"
"	attenuation = clamp(attenuation, 0.0, 1.0);\n"
"	#endif\n"
"\n"
"	return attenuation;\n"
"}\n"
"\n"
"vec3 CalcDiffuse(vec3 diffuseAlbedo, float NH, float EH, float roughness)\n"
"{\n"
"#if defined(USE_BURLEY)\n"
"	// modified from https://disney-animation.s3.amazonaws.com/library/s2012_pbs_disney_brdf_notes_v2.pdf\n"
"	float fd90 = -0.5 + EH * EH * roughness;\n"
"	float burley = 1.0 + fd90 * 0.04 / NH;\n"
"	burley *= burley;\n"
"	return diffuseAlbedo * burley;\n"
"#else\n"
"	return diffuseAlbedo;\n"
"#endif\n"
"}\n"
"\n"
"void CalcNormal() {\n"
"#if defined(USE_NORMALMAP)\n"
"    vec3 normal = texture( u_NormalMap, v_TexCoords ).rgb;\n"
"    normal = normalize( normal * 2.0 - 1.0 );\n"
"    a_Color.rgb *= normal * 0.5 + 0.5;\n"
"#endif\n"
"}\n"
"\n"
"void ApplyLighting() {\n"
"    a_Color = texture( u_DiffuseMap, v_TexCoords );\n"
"    CalcNormal();\n"
"#if defined(USE_SPECULARMAP)\n"
"    if ( u_NumLights == 0 ) {\n"
"        a_Color.rgb += texture( u_SpecularMap, v_TexCoords ).rgb;\n"
"    }\n"
"#endif\n"
"#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"    for ( int i = 0; i < u_NumLights; i++ ) {\n"
"        switch ( lights[i].type ) {\n"
"        case POINT_LIGHT:\n"
"            a_Color.rgb += CalcPointLight( u_LightData[i] );\n"
"            break;\n"
"        case DIRECTION_LIGHT:\n"
"            break;\n"
"        };\n"
"    }\n"
"#endif\n"
"    a_Color.rgb += texture( u_DiffuseMap, v_TexCoords ).rgb;\n"
"}\n"
"\n"
"\n"
"void texcoords( vec2 fragCoord, vec2 resolution, out vec2 v_rgbNW, out vec2 v_rgbNE, out vec2 v_rgbSW,\n"
"	out vec2 v_rgbSE, out vec2 v_rgbM )\n"
"{\n"
"	vec2 inverseVP = 1.0 / resolution.xy;\n"
"	v_rgbNW = ( fragCoord + vec2( -1.0, -1.0 ) ) * inverseVP;\n"
"	v_rgbNE = ( fragCoord + vec2( 1.0, -1.0 ) ) * inverseVP;\n"
"	v_rgbSW = ( fragCoord + vec2( -1.0, 1.0 ) ) * inverseVP;\n"
"	v_rgbSE = ( fragCoord + vec2( 1.0, 1.0 ) ) * inverseVP;\n"
"	v_rgbM = vec2( fragCoord * inverseVP );\n"
"}\n"
"\n"
"#ifndef FXAA_REDUCE_MIN\n"
"    #define FXAA_REDUCE_MIN   (1.0/ 128.0)\n"
"#endif\n"
"#ifndef FXAA_REDUCE_MUL\n"
"    #define FXAA_REDUCE_MUL   (1.0 / 8.0)\n"
"#endif\n"
"#ifndef FXAA_SPAN_MAX\n"
"    #define FXAA_SPAN_MAX     8.0\n"
"#endif\n"
"\n"
"//optimized version for mobile, where dependent\n"
"//texture reads can be a bottleneck\n"
"vec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 resolution,\n"
"            vec2 v_rgbNW, vec2 v_rgbNE,\n"
"            vec2 v_rgbSW, vec2 v_rgbSE,\n"
"            vec2 v_rgbM) {\n"
"    vec4 color;\n"
"    vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);\n"
"    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\n"
"    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\n"
"    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\n"
"    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\n"
"    vec4 texColor = texture2D(tex, v_rgbM);\n"
"    vec3 rgbM  = texColor.xyz;\n"
"    vec3 luma = vec3(0.299, 0.587, 0.114);\n"
"    float lumaNW = dot(rgbNW, luma);\n"
"    float lumaNE = dot(rgbNE, luma);\n"
"    float lumaSW = dot(rgbSW, luma);\n"
"    float lumaSE = dot(rgbSE, luma);\n"
"    float lumaM  = dot(rgbM,  luma);\n"
"    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n"
"    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n"
"\n"
"    vec2 dir;\n"
"    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n"
"    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n"
"\n"
"    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n"
"                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n"
"\n"
"    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n"
"    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n"
"              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n"
"              dir * rcpDirMin)) * inverseVP;\n"
"\n"
"    vec3 rgbA = 0.5 * (\n"
"        texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\n"
"        texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n"
"    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n"
"        texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\n"
"        texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n"
"\n"
"    float lumaB = dot(rgbB, luma);\n"
"    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n"
"        color = vec4(rgbA, texColor.a);\n"
"    else\n"
"        color = vec4(rgbB, texColor.a);\n"
"    return color;\n"
"}\n"
"\n"
"vec4 applyFXAA( sampler2D tex, vec2 fragCoord, vec2 resolution ) {\n"
"	vec2 v_rgbNW;\n"
"	vec2 v_rgbNE;\n"
"	vec2 v_rgbSW;\n"
"	vec2 v_rgbSE;\n"
"	vec2 v_rgbM;\n"
"\n"
"	texcoords( fragCoord, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM );\n"
"\n"
"	return fxaa( tex, fragCoord, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM );\n"
"}\n"
"\n"
"// -- Sharpening --\n"
"uniform float u_SharpenAmount;\n"
"uniform vec2 u_ScreenSize;\n"
"\n"
"#define sharp_clamp 0.000  //[0.000 to 1.000] Limits maximum amount of sharpening a pixel recieves - Default is 0.035\n"
"\n"
"// -- Advanced sharpening settings --\n"
"\n"
"#define offset_bias 6.0  //[0.0 to 6.0] Offset bias adjusts the radius of the sampling pattern.\n"
"                         //I designed the pattern for offset_bias 1.0, but feel free to experiment.\n"
"\n"
"//#define CoefLuma vec3( 0.2126, 0.7152, 0.0722 )      // BT.709 & sRBG luma coefficient (Monitors and HD Television)\n"
"//#define CoefLuma vec3( 0.299, 0.587, 0.114 )       // BT.601 luma coefficient (SD Television)\n"
"#define CoefLuma vec3( 1.0/3.0, 1.0/3.0, 1.0/3.0 ) // Equal weight coefficient\n"
"\n"
"vec4 sharpenImage( sampler2D tex, vec2 pos )\n"
"{\n"
"	vec4 colorInput = texture2D(tex, pos);\n"
"\n"
"	vec3 ori = colorInput.rgb;\n"
"\n"
"	// -- Combining the strength and luma multipliers --\n"
"	vec3 sharp_strength_luma = (CoefLuma * u_SharpenAmount); //I\'ll be combining even more multipliers with it later on\n"
"\n"
"	// -- Gaussian filter --\n"
"	//   [ .25, .50, .25]     [ 1 , 2 , 1 ]\n"
"	//   [ .50,   1, .50]  =  [ 2 , 4 , 2 ]\n"
" 	//   [ .25, .50, .25]     [ 1 , 2 , 1 ]\n"
"\n"
"\n"
"    float px = 1.0/u_ScreenSize[0];\n"
"	float py = 1.0/u_ScreenSize[1];\n"
"\n"
"	vec3 blur_ori = texture2D(tex, pos + vec2(px,-py) * 0.5 * offset_bias).rgb; // South East\n"
"	blur_ori += texture2D(tex, pos + vec2(-px,-py) * 0.5 * offset_bias).rgb;  // South West\n"
"	blur_ori += texture2D(tex, pos + vec2(px,py) * 0.5 * offset_bias).rgb; // North East\n"
"	blur_ori += texture2D(tex, pos + vec2(-px,py) * 0.5 * offset_bias).rgb; // North West\n"
"\n"
"	blur_ori *= 0.25;  // ( /= 4) Divide by the number of texture fetches\n"
"\n"
"\n"
"\n"
"	// -- Calculate the sharpening --\n"
"	vec3 sharp = ori - blur_ori;  //Subtracting the blurred image from the original image\n"
"\n"
"	// -- Adjust strength of the sharpening and clamp it--\n"
"	vec4 sharp_strength_luma_clamp = vec4(sharp_strength_luma * (0.5 / sharp_clamp),0.5); //Roll part of the clamp into the dot\n"
"\n"
"	float sharp_luma = clamp((dot(vec4(sharp,1.0), sharp_strength_luma_clamp)), 0.0,1.0 ); //Calculate the luma, adjust the strength, scale up and clamp\n"
"	sharp_luma = (sharp_clamp * 2.0) * sharp_luma - sharp_clamp; //scale down\n"
"\n"
"\n"
"	// -- Combining the values to get the final sharpened pixel	--\n"
"\n"
"	colorInput.rgb = colorInput.rgb + sharp_luma;    // Add the sharpening to the input color.\n"
"	return clamp(colorInput, 0.0,1.0);\n"
"}\n"
"\n"
"void main() {\n"
"    if ( u_AntiAliasing == AntiAlias_FXAA ) {\n"
"        vec2 fragCoord = v_TexCoords * u_ScreenSize;\n"
"        a_Color = applyFXAA( u_DiffuseMap, fragCoord, u_ScreenSize );\n"
"    } else {\n"
"        a_Color = sharpenImage( u_DiffuseMap, v_TexCoords );\n"
"    }\n"
"\n"
"    ApplyLighting();\n"
"\n"
"#if defined(USE_HDR)\n"
"#if !defined(USE_EXPOSURE_TONE_MAPPING)\n"
"	// reinhard tone mapping\n"
"	a_Color.rgb = a_Color.rgb / ( a_Color.rgb + vec3( 1.0 ) );\n"
"#else\n"
"	// exposure tone mapping\n"
"	a_Color.rgb = vec3( 1.0 ) - exp( -a_Color.rgb * u_CameraExposure );\n"
"#endif\n"
"#endif\n"
"#if defined(USE_BLOOM)\n"
"	// check whether fragment output is higher than threshold, if so output as brightness color\n"
"	float brightness = dot( a_Color.rgb, vec3( 0.2126, 0.7152, 0.0722 ) );\n"
"	if ( brightness > 1.0 ) {\n"
"		a_BrightColor = vec4( a_Color.rgb, 1.0 );\n"
"	} else {\n"
"		a_BrightColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n"
"	}\n"
"#endif\n"
"    if ( u_HardwareGamma ) {\n"
"        a_Color.rgb = pow( a_Color.rgb, vec3( 1.0 / u_GammaAmount ) );\n"
"    }\n"
"    if ( u_GamePaused ) {\n"
"        a_Color.rgb = vec3( 0.75, 0.75, 0.75 );\n"
"    }\n"
"}\n"
;

const char *fallbackShader_tonemap_fp =
"#if !defined(GLSL_LEGACY)\n"
"layout(location = 0) out vec4 a_Color;\n"
"#endif\n"
"\n"
"uniform sampler2D u_TextureMap;\n"
"uniform sampler2D u_LevelsMap;\n"
"\n"
"uniform vec4 u_Color;\n"
"\n"
"\n"
"uniform vec2 u_AutoExposureMinMax;\n"
"uniform vec3 u_ToneMinAvgMaxLinear;\n"
"\n"
"in vec2 v_TexCoords;\n"
"in float v_InvWhite;\n"
"\n"
"const vec3  LUMINANCE_VECTOR =   vec3(0.2125, 0.7154, 0.0721); //vec3(0.299, 0.587, 0.114);\n"
"\n"
"float FilmicTonemap(float x)\n"
"{\n"
"	const float SS  = 0.22; // Shoulder Strength\n"
"	const float LS  = 0.30; // Linear Strength\n"
"	const float LA  = 0.10; // Linear Angle\n"
"	const float TS  = 0.20; // Toe Strength\n"
"	const float TAN = 0.01; // Toe Angle Numerator\n"
"	const float TAD = 0.30; // Toe Angle Denominator\n"
"\n"
"	return ((x*(SS*x+LA*LS)+TS*TAN)/(x*(SS*x+LS)+TS*TAD)) - TAN/TAD;\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"	vec4 color = texture2D(u_TextureMap, v_TexCoords) * u_Color;\n"
"\n"
"#if defined(USE_PBR)\n"
"	color.rgb *= color.rgb;\n"
"#endif\n"
"\n"
"	vec3 minAvgMax = texture2D(u_LevelsMap, v_TexCoords).rgb;\n"
"	vec3 logMinAvgMaxLum = clamp(minAvgMax * 20.0 - 10.0, -u_AutoExposureMinMax.y, -u_AutoExposureMinMax.x);\n"
"\n"
"	float invAvgLum = u_ToneMinAvgMaxLinear.y * exp2(-logMinAvgMaxLum.y);\n"
"\n"
"	color.rgb = color.rgb * invAvgLum - u_ToneMinAvgMaxLinear.xxx;\n"
"	color.rgb = max(vec3(0.0), color.rgb);\n"
"\n"
"	color.r = FilmicTonemap(color.r);\n"
"	color.g = FilmicTonemap(color.g);\n"
"	color.b = FilmicTonemap(color.b);\n"
"\n"
"	color.rgb = clamp(color.rgb * v_InvWhite, 0.0, 1.0);\n"
"\n"
"#if defined(USE_PBR)\n"
"	color.rgb = sqrt(color.rgb);\n"
"#endif\n"
"\n"
"	// add a bit of dither to reduce banding\n"
"	color.rgb += vec3(1.0/510.0 * mod(gl_FragCoord.x + gl_FragCoord.y, 2.0) - 1.0/1020.0);\n"
"\n"
"	a_Color = color;\n"
"}\n"
;

const char *fallbackShader_calclevels4x_vp =
"in vec3 a_Position;\n"
"in vec4 a_LightCoords;\n"
"\n"
"uniform mat4 u_ModelViewProjection;\n"
"\n"
"out vec2 v_TexCoords;\n"
"\n"
"void main() {\n"
"	gl_Position = u_ModelViewProjection * vec4( a_Position, 1.0 );\n"
"	v_TexCoords = a_LightCoords.st;\n"
"}\n"
;

const char *fallbackShader_depthblur_vp =
"in vec4 a_Position;\n"
"in vec4 a_LightCoords;\n"
"\n"
"uniform vec4 u_ViewInfo; // zfar / znear, zfar, 1/width, 1/height\n"
"\n"
"out vec2 v_ScreenTex;\n"
"\n"
"void main() {\n"
"	gl_Position = a_Position;\n"
"	vec2 wh = vec2( 1.0 ) / u_ViewInfo.zw - vec2( 1.0 );\n"
"	v_ScreenTex = ( floor( a_LightCoords.xy * wh ) + vec2( 0.5 ) ) * u_ViewInfo.zw;\n"
"\n"
"	//vec2 screenCoords = gl_Position.xy / gl_Position.w;\n"
"	//var_ScreenTex = screenCoords * 0.5 + 0.5;\n"
"}\n"
;

const char *fallbackShader_SMAAWeights_fp =
"#if !defined(GLSL_LEGACY)\n"
"layout( location = 0 ) out vec4 a_Color;\n"
"#endif\n"
"\n"
"#if !defined(SMAA_THRESHOLD)\n"
"#define SMAA_THRESHOLD 0.1\n"
"#endif\n"
"#if !defined(SMAA_MAX_SEARCH_STEPS)\n"
"#define SMAA_MAX_SEARCH_STEPS 16\n"
"#endif\n"
"#if !defined(SMAA_MAX_SEARCH_STEPS_DIAG)\n"
"#define SMAA_MAX_SEARCH_STEPS_DIAG 8\n"
"#endif\n"
"#if !defined(SMAA_CORNER_ROUNDING)\n"
"#define SMAA_CORNER_ROUNDING 25\n"
"#endif\n"
"\n"
"// Non-Configurable Defines\n"
"#define SMAA_AREATEX_MAX_DISTANCE 16\n"
"#define SMAA_AREATEX_MAX_DISTANCE_DIAG 20\n"
"#define SMAA_AREATEX_PIXEL_SIZE ( 1.0 / vec2( 160.0, 560.0 ) )\n"
"#define SMAA_AREATEX_SUBTEX_SIZE ( 1.0 / 7.0 )\n"
"#define SMAA_SEARCHTEX_SIZE vec2( 66.0, 33.0 )\n"
"#define SMAA_SEARCHTEX_PACKED_SIZE vec2( 64.0, 16.0 )\n"
"#define SMAA_CORNER_ROUNDING_NORM ( float( SMAA_CORNER_ROUNDING ) / 100.0 )\n"
"\n"
"// Texture Access Defines\n"
"#if !defined(SMAA_AREATEX_SELECT)\n"
"#define SMAA_AREATEX_SELECT(sample) sample.rg\n"
"#endif\n"
"\n"
"#if !defined(SMAA_SEARCHTEX_SELECT)\n"
"#define SMAA_SEARCHTEX_SELECT(sample) sample.r\n"
"#endif\n"
"\n"
"uniform vec2 u_ScreenSize;\n"
"\n"
"uniform sampler2D u_EdgesTexture;\n"
"uniform sampler2D u_AreaTexture;\n"
"uniform sampler2D u_SearchTexture;\n"
"\n"
"in vec2 v_TexCoords;\n"
"in vec4 v_Offset[3];\n"
"in vec2 v_PixCoord;\n"
"\n"
"vec4 SMAA_RT_METRICS = vec4( 1.0 / u_ScreenSize.x, 1.0 / u_ScreenSize.y, u_ScreenSize.x, u_ScreenSize.y );\n"
"\n"
"#define mad( a, b, c ) ( a * b + c )\n"
"#define saturate( a ) clamp( a, 0.0, 1.0 )\n"
"#define round( v ) floor( v + 0.5 )\n"
"#define SMAASampleLevelZeroOffset( tex, coord, offset ) texture2D( tex, coord + offset * SMAA_RT_METRICS.xy )\n"
"\n"
"/**\n"
" * Conditional move:\n"
" */\n"
"void SMAAMovc( bvec2 cond, inout vec2 variable, vec2 value ) {\n"
"    if ( cond.x ) {\n"
"        variable.x = value.x;\n"
"    }\n"
"    if ( cond.y ) {\n"
"        variable.y = value.y;\n"
"    }\n"
"}\n"
"\n"
"void SMAAMovc( bvec4 cond, inout vec4 variable, vec4 value ) {\n"
"    SMAAMovc( cond.xy, variable.xy, value.xy );\n"
"    SMAAMovc( cond.zw, variable.zw, value.zw );\n"
"}\n"
"\n"
"/**\n"
" * Allows to decode two binary values from a bilinear-filtered access.\n"
" */\n"
"vec2 SMAADecodeDiagBilinearAccess( vec2 e ) {\n"
"    // Bilinear access for fetching \'e\' have a 0.25 offset, and we are\n"
"    // interested in the R and G edges:\n"
"    //\n"
"    // +---G---+-------+\n"
"    // |   x o R   x   |\n"
"    // +-------+-------+\n"
"    //\n"
"    // Then, if one of these edge is enabled:\n"
"    //   Red:   (0.75 * X + 0.25 * 1) => 0.25 or 1.0\n"
"    //   Green: (0.75 * 1 + 0.25 * X) => 0.75 or 1.0\n"
"    //\n"
"    // This function will unpack the values (mad + mul + round):\n"
"    // wolframalpha.com: round(x * abs(5 * x - 5 * 0.75)) plot 0 to 1\n"
"    e.r = e.r * abs( 5.0 * e.r - 5.0 * 0.75 );\n"
"    return round( e );\n"
"}\n"
"\n"
"vec4 SMAADecodeDiagBilinearAccess( vec4 e ) {\n"
"    e.rb = e.rb * abs( 5.0 * e.rb - 5.0 * 0.75 );\n"
"    return round( e );\n"
"}\n"
"\n"
"/**\n"
" * These functions allows to perform diagonal pattern searches.\n"
" */\n"
"vec2 SMAASearchDiag1( sampler2D edgesTex, vec2 texcoord, vec2 dir, out vec2 e ) {\n"
"    vec4 coord = vec4( texcoord, -1.0, 1.0 );\n"
"    vec3 t = vec3( SMAA_RT_METRICS.xy, 1.0 );\n"
"\n"
"    for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i++ ) {\n"
"        if ( !( coord.z < float( SMAA_MAX_SEARCH_STEPS_DIAG - 1 ) && coord.w > 0.9 ) ) {\n"
"            break;\n"
"        }\n"
"        coord.xyz = mad( t, vec3( dir, 1.0 ), coord.xyz );\n"
"        e = texture2D( edgesTex, coord.xy ).rg; // LinearSampler\n"
"        coord.w = dot( e, vec2( 0.5, 0.5 ) );\n"
"    }\n"
"    return coord.zw;\n"
"}\n"
"\n"
"vec2 SMAASearchDiag2( sampler2D edgesTex, vec2 texcoord, vec2 dir, out vec2 e ) {\n"
"    vec4 coord = vec4( texcoord, -1.0, 1.0 );\n"
"    coord.x += 0.25 * SMAA_RT_METRICS.x; // See @SearchDiag2Optimization\n"
"    vec3 t = vec3( SMAA_RT_METRICS.xy, 1.0 );\n"
"\n"
"    for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i++ ) {\n"
"        if ( !( coord.z < float( SMAA_MAX_SEARCH_STEPS_DIAG - 1 ) && coord.w > 0.9 ) ) {\n"
"            break;\n"
"        }\n"
"        coord.xyz = mad( t, vec3( dir, 1.0 ), coord.xyz );\n"
"\n"
"        // @SearchDiag2Optimization\n"
"        // Fetch both edges at once using bilinear filtering:\n"
"        e = texture2D( edgesTex, coord.xy ).rg; // LinearSampler\n"
"        e = SMAADecodeDiagBilinearAccess( e );\n"
"\n"
"        // Non-optimized version:\n"
"        // e.g = texture2D(edgesTex, coord.xy).g; // LinearSampler\n"
"        // e.r = SMAASampleLevelZeroOffset(edgesTex, coord.xy, vec2(1, 0)).r;\n"
"\n"
"        coord.w = dot( e, vec2( 0.5, 0.5 ) );\n"
"    }\n"
"    return coord.zw;\n"
"}\n"
"\n"
"/**\n"
" * Similar to SMAAArea, this calculates the area corresponding to a certain\n"
" * diagonal distance and crossing edges \'e\'.\n"
" */\n"
"vec2 SMAAAreaDiag( sampler2D areaTex, vec2 dist, vec2 e, float offset ) {\n"
"    vec2 texcoord = mad( vec2( SMAA_AREATEX_MAX_DISTANCE_DIAG, SMAA_AREATEX_MAX_DISTANCE_DIAG ), e, dist );\n"
"\n"
"    // We do a scale and bias for mapping to texel space:\n"
"    texcoord = mad( SMAA_AREATEX_PIXEL_SIZE, texcoord, 0.5 * SMAA_AREATEX_PIXEL_SIZE );\n"
"\n"
"    // Diagonal areas are on the second half of the texture:\n"
"    texcoord.x += 0.5;\n"
"\n"
"    // Move to proper place, according to the subpixel offset:\n"
"    texcoord.y += SMAA_AREATEX_SUBTEX_SIZE * offset;\n"
"\n"
"    // Do it!\n"
"    return SMAA_AREATEX_SELECT( texture2D( areaTex, texcoord ) ); // LinearSampler\n"
"}\n"
"\n"
"/**\n"
" * This searches for diagonal patterns and returns the corresponding weights.\n"
" */\n"
"vec2 SMAACalculateDiagWeights( sampler2D edgesTex, sampler2D areaTex, vec2 texcoord, vec2 e, vec4 subsampleIndices ) {\n"
"    vec2 weights = vec2( 0.0, 0.0 );\n"
"\n"
"    // Search for the line ends:\n"
"    vec4 d;\n"
"    vec2 end;\n"
"    if ( e.r > 0.0 ) {\n"
"        d.xz = SMAASearchDiag1( edgesTex, texcoord, vec2( -1.0,  1.0 ), end );\n"
"        d.x += float( end.y > 0.9 );\n"
"    } else {\n"
"        d.xz = vec2( 0.0, 0.0 );\n"
"    }\n"
"    d.yw = SMAASearchDiag1( edgesTex, texcoord, vec2( 1.0, -1.0 ), end );\n"
"\n"
"    if ( d.x + d.y > 2.0 ) { // d.x + d.y + 1 > 3\n"
"        // Fetch the crossing edges:\n"
"        vec4 coords = mad( vec4( -d.x + 0.25, d.x, d.y, -d.y - 0.25 ), SMAA_RT_METRICS.xyxy, texcoord.xyxy );\n"
"        vec4 c;\n"
"        c.xy = SMAASampleLevelZeroOffset( edgesTex, coords.xy, vec2( -1,  0 ) ).rg;\n"
"        c.zw = SMAASampleLevelZeroOffset( edgesTex, coords.zw, vec2(  1,  0 ) ).rg;\n"
"        c.yxwz = SMAADecodeDiagBilinearAccess( c.xyzw );\n"
"\n"
"        // Non-optimized version:\n"
"        // vec4 coords = mad(vec4(-d.x, d.x, d.y, -d.y), SMAA_RT_METRICS.xyxy, texcoord.xyxy);\n"
"        // vec4 c;\n"
"        // c.x = SMAASampleLevelZeroOffset(edgesTex, coords.xy, vec2(-1,  0)).g;\n"
"        // c.y = SMAASampleLevelZeroOffset(edgesTex, coords.xy, vec2( 0,  0)).r;\n"
"        // c.z = SMAASampleLevelZeroOffset(edgesTex, coords.zw, vec2( 1,  0)).g;\n"
"        // c.w = SMAASampleLevelZeroOffset(edgesTex, coords.zw, vec2( 1, -1)).r;\n"
"\n"
"        // Merge crossing edges at each side into a single value:\n"
"        vec2 cc = mad( vec2( 2.0, 2.0 ), c.xz, c.yw );\n"
"\n"
"        // Remove the crossing edge if we didn\'t found the end of the line:\n"
"        SMAAMovc( bvec2( step( 0.9, d.zw ) ), cc, vec2( 0.0, 0.0 ) );\n"
"\n"
"        // Fetch the areas for this line:\n"
"        weights += SMAAAreaDiag(areaTex, d.xy, cc, subsampleIndices.z);\n"
"    }\n"
"\n"
"    // Search for the line ends:\n"
"    d.xz = SMAASearchDiag2( edgesTex, texcoord, vec2( -1.0, -1.0 ), end );\n"
"    if ( SMAASampleLevelZeroOffset( edgesTex, texcoord, vec2( 1, 0 ) ).r > 0.0 ) {\n"
"        d.yw = SMAASearchDiag2( edgesTex, texcoord, vec2( 1.0, 1.0 ), end );\n"
"        d.y += float( end.y > 0.9 );\n"
"    } else {\n"
"        d.yw = vec2( 0.0, 0.0 );\n"
"    }\n"
"\n"
"    if ( d.x + d.y > 2.0 ) { // d.x + d.y + 1 > 3\n"
"        // Fetch the crossing edges:\n"
"        vec4 coords = mad( vec4( -d.x, -d.x, d.y, d.y ), SMAA_RT_METRICS.xyxy, texcoord.xyxy );\n"
"        vec4 c;\n"
"        c.x  = SMAASampleLevelZeroOffset( edgesTex, coords.xy, vec2( -1,  0 ) ).g;\n"
"        c.y  = SMAASampleLevelZeroOffset( edgesTex, coords.xy, vec2(  0, -1 ) ).r;\n"
"        c.zw = SMAASampleLevelZeroOffset( edgesTex, coords.zw, vec2(  1,  0 ) ).gr;\n"
"        vec2 cc = mad( vec2( 2.0, 2.0 ), c.xz, c.yw );\n"
"\n"
"        // Remove the crossing edge if we didn\'t found the end of the line:\n"
"        SMAAMovc( bvec2( step( 0.9, d.zw ) ), cc, vec2( 0.0, 0.0 ) );\n"
"\n"
"        // Fetch the areas for this line:\n"
"        weights += SMAAAreaDiag( areaTex, d.xy, cc, subsampleIndices.w ).gr;\n"
"    }\n"
"\n"
"    return weights;\n"
"}\n"
"\n"
"/**\n"
" * This allows to determine how much length should we add in the last step\n"
" * of the searches. It takes the bilinearly interpolated edge (see\n"
" * @PSEUDO_GATHER4), and adds 0, 1 or 2, depending on which edges and\n"
" * crossing edges are active.\n"
" */\n"
"float SMAASearchLength( sampler2D searchTex, vec2 e, float offset ) {\n"
"    // The texture is flipped vertically, with left and right cases taking half\n"
"    // of the space horizontally:\n"
"    vec2 scale = SMAA_SEARCHTEX_SIZE * vec2( 0.5, -1.0 );\n"
"    vec2 bias = SMAA_SEARCHTEX_SIZE * vec2( offset, 1.0 );\n"
"\n"
"    // Scale and bias to access texel centers:\n"
"    scale += vec2( -1.0,  1.0 );\n"
"    bias  += vec2(  0.5, -0.5 );\n"
"\n"
"    // Convert from pixel coordinates to texcoords:\n"
"    // (We use SMAA_SEARCHTEX_PACKED_SIZE because the texture is cropped)\n"
"    scale *= 1.0 / SMAA_SEARCHTEX_PACKED_SIZE;\n"
"    bias *= 1.0 / SMAA_SEARCHTEX_PACKED_SIZE;\n"
"\n"
"    // Lookup the search texture:\n"
"    return SMAA_SEARCHTEX_SELECT( texture2D( searchTex, mad( scale, e, bias ) ) ); // LinearSampler\n"
"}\n"
"\n"
"/**\n"
" * Horizontal/vertical search functions for the 2nd pass.\n"
" */\n"
"float SMAASearchXLeft( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n"
"    /**\n"
"      * @PSEUDO_GATHER4\n"
"      * This texcoord has been offset by (-0.25, -0.125) in the vertex shader to\n"
"      * sample between edge, thus fetching four edges in a row.\n"
"      * Sampling with different offsets in each direction allows to disambiguate\n"
"      * which edges are active from the four fetched ones.\n"
"      */\n"
"    vec2 e = vec2( 0.0, 1.0 );\n"
"    for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i++ ) {\n"
"        if ( !( texcoord.x > end && e.g > 0.8281 && e.r == 0.0 ) ) {\n"
"            break;\n"
"        }\n"
"        e = texture2D( edgesTex, texcoord ).rg; // LinearSampler\n"
"        texcoord = mad( -vec2( 2.0, 0.0 ), SMAA_RT_METRICS.xy, texcoord );\n"
"    }\n"
"\n"
"    float offset = mad( -( 255.0 / 127.0 ), SMAASearchLength( searchTex, e, 0.0 ), 3.25 );\n"
"    return mad( SMAA_RT_METRICS.x, offset, texcoord.x );\n"
"\n"
"    // Non-optimized version:\n"
"    // We correct the previous (-0.25, -0.125) offset we applied:\n"
"    // texcoord.x += 0.25 * SMAA_RT_METRICS.x;\n"
"\n"
"    // The searches are bias by 1, so adjust the coords accordingly:\n"
"    // texcoord.x += SMAA_RT_METRICS.x;\n"
"\n"
"    // Disambiguate the length added by the last step:\n"
"    // texcoord.x += 2.0 * SMAA_RT_METRICS.x; // Undo last step\n"
"    // texcoord.x -= SMAA_RT_METRICS.x * (255.0 / 127.0) * SMAASearchLength(searchTex, e, 0.0);\n"
"    // return mad(SMAA_RT_METRICS.x, offset, texcoord.x);\n"
"}\n"
"\n"
"float SMAASearchXRight( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n"
"    vec2 e = vec2( 0.0, 1.0 );\n"
"    for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i++ ) {\n"
"        if ( !( texcoord.x < end && e.g > 0.8281 && e.r == 0.0 ) ) {\n"
"            break;\n"
"        }\n"
"        e = texture2D( edgesTex, texcoord ).rg; // LinearSampler\n"
"        texcoord = mad( vec2( 2.0, 0.0 ), SMAA_RT_METRICS.xy, texcoord );\n"
"    }\n"
"    float offset = mad( -( 255.0 / 127.0 ), SMAASearchLength( searchTex, e, 0.5 ), 3.25 );\n"
"    return mad( -SMAA_RT_METRICS.x, offset, texcoord.x );\n"
"}\n"
"\n"
"float SMAASearchYUp( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n"
"    vec2 e = vec2( 1.0, 0.0 );\n"
"    for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i++ ) {\n"
"        if ( !( texcoord.y > end && e.r > 0.8281 && e.g == 0.0 ) ) {\n"
"            break;\n"
"        }\n"
"        e = texture2D( edgesTex, texcoord ).rg; // LinearSampler\n"
"        texcoord = mad( -vec2( 0.0, 2.0 ), SMAA_RT_METRICS.xy, texcoord );\n"
"    }\n"
"    float offset = mad( -( 255.0 / 127.0 ), SMAASearchLength( searchTex, e.gr, 0.0 ), 3.25 );\n"
"    return mad( SMAA_RT_METRICS.y, offset, texcoord.y );\n"
"}\n"
"\n"
"float SMAASearchYDown( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n"
"    vec2 e = vec2( 1.0, 0.0 );\n"
"    for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i++ ) {\n"
"        if ( !( texcoord.y < end && e.r > 0.8281 && e.g == 0.0 ) ) {\n"
"            break;\n"
"        }\n"
"        e = texture2D( edgesTex, texcoord ).rg; // LinearSampler\n"
"        texcoord = mad( vec2( 0.0, 2.0 ), SMAA_RT_METRICS.xy, texcoord );\n"
"    }\n"
"    float offset = mad( -( 255.0 / 127.0 ), SMAASearchLength( searchTex, e.gr, 0.5 ), 3.25 );\n"
"    return mad( -SMAA_RT_METRICS.y, offset, texcoord.y );\n"
"}\n"
"\n"
"/**\n"
" * Ok, we have the distance and both crossing edges. So, what are the areas\n"
" * at each side of current edge?\n"
" */\n"
"vec2 SMAAArea( sampler2D areaTex, vec2 dist, float e1, float e2, float offset ) {\n"
"    // Rounding prevents precision errors of bilinear filtering:\n"
"    vec2 texcoord = mad( vec2( SMAA_AREATEX_MAX_DISTANCE, SMAA_AREATEX_MAX_DISTANCE ), round( 4.0 * vec2( e1, e2 ) ), dist );\n"
"\n"
"    // We do a scale and bias for mapping to texel space:\n"
"    texcoord = mad( SMAA_AREATEX_PIXEL_SIZE, texcoord, 0.5 * SMAA_AREATEX_PIXEL_SIZE );\n"
"\n"
"    // Move to proper place, according to the subpixel offset:\n"
"    texcoord.y = mad( SMAA_AREATEX_SUBTEX_SIZE, offset, texcoord.y );\n"
"\n"
"    // Do it!\n"
"    return SMAA_AREATEX_SELECT( texture2D( areaTex, texcoord ) ); // LinearSampler\n"
"}\n"
"\n"
"// Corner Detection Functions\n"
"void SMAADetectHorizontalCornerPattern( sampler2D edgesTex, inout vec2 weights, vec4 texcoord, vec2 d ) {\n"
"#if !defined(SMAA_DISABLE_CORNER_DETECTION)\n"
"    vec2 leftRight = step( d.xy, d.yx );\n"
"    vec2 rounding = ( 1.0 - SMAA_CORNER_ROUNDING_NORM ) * leftRight;\n"
"\n"
"    rounding /= leftRight.x + leftRight.y; // Reduce blending for pixels in the center of a line.\n"
"\n"
"    vec2 factor = vec2( 1.0, 1.0 );\n"
"    factor.x -= rounding.x * SMAASampleLevelZeroOffset( edgesTex, texcoord.xy, vec2( 0,  1 ) ).r;\n"
"    factor.x -= rounding.y * SMAASampleLevelZeroOffset( edgesTex, texcoord.zw, vec2( 1,  1 ) ).r;\n"
"    factor.y -= rounding.x * SMAASampleLevelZeroOffset( edgesTex, texcoord.xy, vec2( 0, -2 ) ).r;\n"
"    factor.y -= rounding.y * SMAASampleLevelZeroOffset( edgesTex, texcoord.zw, vec2( 1, -2 ) ).r;\n"
"\n"
"    weights *= saturate( factor );\n"
"#endif\n"
"}\n"
"\n"
"void SMAADetectVerticalCornerPattern( sampler2D edgesTex, inout vec2 weights, vec4 texcoord, vec2 d ) {\n"
"#if !defined(SMAA_DISABLE_CORNER_DETECTION)\n"
"    vec2 leftRight = step( d.xy, d.yx );\n"
"    vec2 rounding = ( 1.0 - SMAA_CORNER_ROUNDING_NORM ) * leftRight;\n"
"\n"
"    rounding /= leftRight.x + leftRight.y;\n"
"\n"
"    vec2 factor = vec2( 1.0, 1.0 );\n"
"    factor.x -= rounding.x * SMAASampleLevelZeroOffset( edgesTex, texcoord.xy, vec2(  1, 0 ) ).g;\n"
"    factor.x -= rounding.y * SMAASampleLevelZeroOffset( edgesTex, texcoord.zw, vec2(  1, 1 ) ).g;\n"
"    factor.y -= rounding.x * SMAASampleLevelZeroOffset( edgesTex, texcoord.xy, vec2( -2, 0 ) ).g;\n"
"    factor.y -= rounding.y * SMAASampleLevelZeroOffset( edgesTex, texcoord.zw, vec2( -2, 1 ) ).g;\n"
"\n"
"    weights *= saturate( factor );\n"
"#endif\n"
"}\n"
"\n"
"void main() {\n"
"    vec4 subsampleIndices = vec4( 0.0 ); // Just pass zero for SMAA 1x, see @SUBSAMPLE_INDICES.\n"
"    // subsampleIndices = vec4(1.0, 1.0, 1.0, 0.0);\n"
"    vec4 weights = vec4( 0.0, 0.0, 0.0, 0.0 );\n"
"    vec2 e = texture2D( u_EdgesTexture, v_TexCoords ).rg;\n"
"\n"
"    if ( e.g > 0.0 ) { // Edge at north\n"
"#if !defined( SMAA_DISABLE_DIAG_DETECTION )\n"
"        // Diagonals have both north and west edges, so searching for them in\n"
"        // one of the boundaries is enough.\n"
"        weights.rg = SMAACalculateDiagWeights( u_EdgesTexture, u_AreaTexture, v_TexCoords, e, subsampleIndices );\n"
"\n"
"        // We give priority to diagonals, so if we find a diagonal we skip\n"
"        // horizontal/vertical processing.\n"
"        if ( weights.r == -weights.g ) // weights.r + weights.g == 0.0\n"
"#endif\n"
"        {\n"
"            vec2 d;\n"
"\n"
"            // Find the distance to the left:\n"
"            vec3 coords;\n"
"            coords.x = SMAASearchXLeft( u_EdgesTexture, u_SearchTexture, v_Offset[0].xy, v_Offset[2].x );\n"
"            coords.y = v_Offset[1].y; // v_Offset[1].y = v_TexCoords.y - 0.25 * SMAA_RT_METRICS.y (@CROSSING_OFFSET)\n"
"            d.x = coords.x;\n"
"\n"
"            // Now fetch the left crossing edges, two at a time using bilinear\n"
"            // filtering. Sampling at -0.25 (see @CROSSING_OFFSET) enables to\n"
"            // discern what value each edge has:\n"
"            float e1 = texture2D( u_EdgesTexture, coords.xy ).r; // LinearSampler\n"
"\n"
"            // Find the distance to the right:\n"
"            coords.z = SMAASearchXRight( u_EdgesTexture, u_SearchTexture, v_Offset[0].zw, v_Offset[2].y );\n"
"            d.y = coords.z;\n"
"\n"
"            // We want the distances to be in pixel units (doing this here allow to\n"
"            // better interleave arithmetic and memory accesses):\n"
"            d = abs( round( mad( SMAA_RT_METRICS.zz, d, -v_PixCoord.xx ) ) );\n"
"\n"
"            // SMAAArea below needs a sqrt, as the areas texture is compressed\n"
"            // quadratically:\n"
"            vec2 sqrt_d = sqrt( d );\n"
"\n"
"            // Fetch the right crossing edges:\n"
"            float e2 = SMAASampleLevelZeroOffset( u_EdgesTexture, coords.zy, vec2( 1, 0 ) ).r;\n"
"\n"
"            // Ok, we know how this pattern looks like, now it is time for getting\n"
"            // the actual area:\n"
"            weights.rg = SMAAArea( u_AreaTexture, sqrt_d, e1, e2, subsampleIndices.y );\n"
"\n"
"            // Fix corners:\n"
"            coords.y = v_TexCoords.y;\n"
"            SMAADetectHorizontalCornerPattern( u_EdgesTexture, weights.rg, coords.xyzy, d );\n"
"        }\n"
"#if !defined(SMAA_DISABLE_DIAG_DETECTION)\n"
"        else {\n"
"            e.r = 0.0; // Skip vertical processing.\n"
"        }\n"
"#endif\n"
"    }\n"
"\n"
"    if ( e.r > 0.0 ) { // Edge at west\n"
"        vec2 d;\n"
"\n"
"        // Find the distance to the top:\n"
"        vec3 coords;\n"
"        coords.y = SMAASearchYUp( u_EdgesTexture, searchTex, v_Offset[1].xy, v_Offset[2].z );\n"
"        coords.x = v_Offset[0].x; // v_Offset[1].x = v_TexCoords.x - 0.25 * SMAA_RT_METRICS.x;\n"
"        d.x = coords.y;\n"
"\n"
"        // Fetch the top crossing edges:\n"
"        float e1 = texture2D( u_EdgesTexture, coords.xy ).g; // LinearSampler\n"
"\n"
"        // Find the distance to the bottom:\n"
"        coords.z = SMAASearchYDown( u_EdgesTexture, u_SearchTexture, v_Offset[1].zw, v_Offset[2].w );\n"
"        d.y = coords.z;\n"
"\n"
"        // We want the distances to be in pixel units:\n"
"        d = abs( round( mad( SMAA_RT_METRICS.ww, d, -v_PixCoord.yy ) ) );\n"
"\n"
"        // SMAAArea below needs a sqrt, as the areas texture is compressed\n"
"        // quadratically:\n"
"        vec2 sqrt_d = sqrt( d );\n"
"\n"
"        // Fetch the bottom crossing edges:\n"
"        float e2 = SMAASampleLevelZeroOffset( u_EdgesTexture, coords.xz, vec2( 0, 1 ) ).g;\n"
"\n"
"        // Get the area for this direction:\n"
"        weights.ba = SMAAArea( u_AreaTexture, sqrt_d, e1, e2, subsampleIndices.x );\n"
"\n"
"        // Fix corners:\n"
"        coords.x = v_TexCoords.x;\n"
"        SMAADetectVerticalCornerPattern( u_EdgesTexture, weights.ba, coords.xyxz, d );\n"
"    }\n"
"\n"
"    a_Color = weights;\n"
"}\n"
;

const char *fallbackShader_SMAAEdges_fp =
"#if !defined(GLSL_LEGACY)\n"
"layout( location = 0 ) out vec4 a_Color;\n"
"#endif\n"
"\n"
"#if !defined(SMAA_THRESHOLD)\n"
"#define SMAA_THRESHOLD 0.1\n"
"#endif\n"
"\n"
"#if !defined(SMAA_LOCAL_CONTRAST_ADAPTATION_FACTOR)\n"
"#define SMAA_LOCAL_CONTRAST_ADAPTATION_FACTOR 2.0\n"
"#endif\n"
"\n"
"uniform sampler2D u_DiffuseMap;\n"
"\n"
"in vec2 v_TexCoords;\n"
"in vec4 v_Offset[3];\n"
"\n"
"void main() {\n"
"    vec2 threshold = vec2( SMAA_THRESHOLD );\n"
"\n"
"    // Calculate lumas:\n"
"    vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n"
"    float L = dot( texture2D( u_DiffuseMap, v_TexCoords ).rgb, weights );\n"
"\n"
"    float Lleft = dot( texture2D( u_DiffuseMap, v_Offset[0].xy ).rgb, weights );\n"
"    float Ltop  = dot( texture2D( u_DiffuseMap, v_Offset[0].zw ).rgb, weights );\n"
"\n"
"    // We do the usual threshold:\n"
"    vec4 delta;\n"
"    delta.xy = abs( L - vec2(Lleft, Ltop ) );\n"
"    vec2 edges = step( threshold, delta.xy );\n"
"\n"
"    // Then discard if there is no edge:\n"
"    if ( dot( edges, vec2( 1.0, 1.0 ) ) == 0.0 ) {\n"
"        discard;\n"
"    }\n"
"\n"
"    // Calculate right and bottom deltas:\n"
"    float Lright = dot( texture2D( u_DiffuseMap, v_Offset[1].xy ).rgb, weights );\n"
"    float Lbottom  = dot( texture2D( u_DiffuseMap, v_Offset[1].zw ).rgb, weights );\n"
"    delta.zw = abs( L - vec2( Lright, Lbottom ) );\n"
"\n"
"    // Calculate the maximum delta in the direct neighborhood:\n"
"    vec2 maxDelta = max( delta.xy, delta.zw );\n"
"\n"
"    // Calculate left-left and top-top deltas:\n"
"    float Lleftleft = dot( texture2D( u_DiffuseMap, v_Offset[2].xy ).rgb, weights );\n"
"    float Ltoptop = dot( texture2D( u_DiffuseMap, v_Offset[2].zw ).rgb, weights );\n"
"    delta.zw = abs( vec2( Lleft, Ltop ) - vec2( Lleftleft, Ltoptop ) );\n"
"\n"
"    // Calculate the final maximum delta:\n"
"    maxDelta = max( maxDelta.xy, delta.zw );\n"
"    float finalDelta = max( maxDelta.x, maxDelta.y );\n"
"\n"
"    // Local contrast adaptation:\n"
"    edges.xy *= step( finalDelta, SMAA_LOCAL_CONTRAST_ADAPTATION_FACTOR * delta.xy );\n"
"\n"
"    a_Color = vec4( edges, 0.0 1.0 );\n"
"}\n"
;

const char *fallbackShader_ssao_fp =
"#if !defined(GLSL_LEGACY)\n"
"out vec4 a_Color;\n"
"#endif\n"
"\n"
"uniform sampler2D u_ScreenDepthMap;\n"
"uniform vec4 u_ViewInfo; // zfar / znear, zfar, 1/width, 1/height\n"
"\n"
"in vec2 v_ScreenTex;\n"
"\n"
"#if 0\n"
"vec2 poissonDisc[9] = vec2[9](\n"
"vec2(-0.7055767, 0.196515),    vec2(0.3524343, -0.7791386),\n"
"vec2(0.2391056, 0.9189604),    vec2(-0.07580382, -0.09224417),\n"
"vec2(0.5784913, -0.002528916), vec2(0.192888, 0.4064181),\n"
"vec2(-0.6335801, -0.5247476),  vec2(-0.5579782, 0.7491854),\n"
"vec2(0.7320465, 0.6317794)\n"
");\n"
"#endif\n"
"\n"
"#define NUM_SAMPLES 3\n"
"\n"
"// Input: It uses texture coords as the random number seed.\n"
"// Output: Random number: [0,1), that is between 0.0 and 0.999999... inclusive.\n"
"// Author: Michael Pohoreski\n"
"// Copyright: Copyleft 2012 :-)\n"
"// Source: http://stackoverflow.com/questions/5149544/can-i-generate-a-random-number-inside-a-pixel-shader\n"
"\n"
"float random( const vec2 p )\n"
"{\n"
"  // We need irrationals for pseudo randomness.\n"
"  // Most (all?) known transcendental numbers will (generally) work.\n"
"  const vec2 r = vec2(\n"
"    23.1406926327792690,  // e^pi (Gelfond\'s constant)\n"
"     2.6651441426902251); // 2^sqrt(2) (Gelfond-Schneider constant)\n"
"  //return fract( cos( mod( 123456789., 1e-7 + 256. * dot(p,r) ) ) );\n"
"  return mod( 123456789., 1e-7 + 256. * dot(p,r) );\n"
"}\n"
"\n"
"mat2 randomRotation( const vec2 p )\n"
"{\n"
"	float r = random(p);\n"
"	float sinr = sin(r);\n"
"	float cosr = cos(r);\n"
"	return mat2(cosr, sinr, -sinr, cosr);\n"
"}\n"
"\n"
"float getLinearDepth(sampler2D depthMap, const vec2 tex, const float zFarDivZNear)\n"
"{\n"
"	float sampleZDivW = texture2D(depthMap, tex).r;\n"
"	return 1.0 / mix(zFarDivZNear, 1.0, sampleZDivW);\n"
"}\n"
"\n"
"float ambientOcclusion(sampler2D depthMap, const vec2 tex, const float zFarDivZNear, const float zFar, const vec2 scale)\n"
"{\n"
"	vec2 poissonDisc[9];\n"
"\n"
"	poissonDisc[0] = vec2(-0.7055767, 0.196515);\n"
"	poissonDisc[1] = vec2(0.3524343, -0.7791386);\n"
"	poissonDisc[2] = vec2(0.2391056, 0.9189604);\n"
"	poissonDisc[3] = vec2(-0.07580382, -0.09224417);\n"
"	poissonDisc[4] = vec2(0.5784913, -0.002528916);\n"
"	poissonDisc[5] = vec2(0.192888, 0.4064181);\n"
"	poissonDisc[6] = vec2(-0.6335801, -0.5247476);\n"
"	poissonDisc[7] = vec2(-0.5579782, 0.7491854);\n"
"	poissonDisc[8] = vec2(0.7320465, 0.6317794);\n"
"\n"
"	float result = 0.0;\n"
"\n"
"	float sampleZ = getLinearDepth(depthMap, tex, zFarDivZNear);\n"
"	float scaleZ = zFarDivZNear * sampleZ;\n"
"\n"
"	vec2 slope = vec2(dFdx(sampleZ), dFdy(sampleZ)) / vec2(dFdx(tex.x), dFdy(tex.y));\n"
"\n"
"	if (length(slope) * zFar > 5000.0)\n"
"		return 1.0;\n"
"\n"
"	vec2 offsetScale = vec2(scale * 1024.0 / scaleZ);\n"
"\n"
"	mat2 rmat = randomRotation(tex);\n"
"\n"
"	float invZFar = 1.0 / zFar;\n"
"	float zLimit = 20.0 * invZFar;\n"
"	int i;\n"
"	for (i = 0; i < NUM_SAMPLES; i++)\n"
"	{\n"
"		vec2 offset = rmat * poissonDisc[i] * offsetScale;\n"
"		float sampleDiff = getLinearDepth(depthMap, tex + offset, zFarDivZNear) - sampleZ;\n"
"\n"
"		bool s1 = abs(sampleDiff) > zLimit;\n"
"		bool s2 = sampleDiff + invZFar > dot(slope, offset);\n"
"		result += float(s1 || s2);\n"
"	}\n"
"\n"
"	result *= 1.0 / float(NUM_SAMPLES);\n"
"\n"
"	return result;\n"
"}\n"
"\n"
"void main() {\n"
"	float result = ambientOcclusion(u_ScreenDepthMap, v_ScreenTex, u_ViewInfo.x, u_ViewInfo.y, u_ViewInfo.wz);\n"
"\n"
"    a_Color = vec4(vec3(result), 1.0);\n"
"}\n"
;

const char *fallbackShader_SMAABlend_vp =
"#define mad( a, b, c ) ( a * b + c )\n"
"\n"
"in vec3 a_Position;\n"
"\n"
"uniform vec2 u_ScreenSize;\n"
"\n"
"out vec2 v_TexCoords;\n"
"out vec4 v_Offset;\n"
"\n"
"void main() {\n"
"    vec4 SMAA_RT_METRICS = vec4( 1.0 / u_ScreenSize.x, 1.0 / u_ScreenSize.y, u_ScreenSize.x, u_ScreenSize.y );\n"
"\n"
"    v_TexCoords = vec2( ( a_Position + 1.0 ) / 2.0 );\n"
"    v_Offset = mad( SMAA_RT_METRICS.xyxy, vec4( 1.0, 0.0, 0.0, 1.0 ), v_TexCoords.xyxy );\n"
"\n"
"    gl_Position = vec4( a_Position, 0.0, 1.0 );\n"
"}\n"
;
