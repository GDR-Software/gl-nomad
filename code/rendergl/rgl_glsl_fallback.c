
const char *fallbackShader_texturecolor_fp =
"#if !defined(GLSL_LEGACY)\n"
"out vec4 a_Color;\n"
"#endif\n"
"\n"
"uniform sampler2D u_DiffuseMap;\n"
"uniform vec4 u_Color;\n"
"\n"
"in vec2 v_TexCoords;\n"
"\n"
"\n"
"void main() {\n"
"	a_Color = texture2D( u_DiffuseMap, v_TexCoords ) * u_Color;\n"
"}\n"
;

const char *fallbackShader_generic_fp =
"#if !defined(GLSL_LEGACY)\n"
"layout( location = 0 ) out vec4 a_Color;\n"
"#if defined(USE_BLOOM) && defined(USE_HDR)\n"
"layout( location = 1 ) out vec4 a_BrightColor;\n"
"#endif\n"
"#endif\n"
"\n"
"in vec2 v_TexCoords;\n"
"in vec3 v_FragPos;\n"
"in vec4 v_Color;\n"
"\n"
"uniform sampler2D u_DiffuseMap;\n"
"uniform float u_GammaAmount;\n"
"\n"
"#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"uniform vec4 u_SpecularScale;\n"
"uniform vec4 u_NormalScale;\n"
"uniform int u_NumLights;\n"
"\n"
"uniform vec3 u_AmbientColor;\n"
"uniform float u_AmbientIntensity;\n"
"\n"
"struct Light {\n"
"    vec4 color;\n"
"    uvec2 origin;\n"
"    float brightness;\n"
"    float range;\n"
"    float linear;\n"
"    float quadratic;\n"
"    float constant;\n"
"    int type;\n"
"};\n"
"layout( std140 ) uniform u_LightBuffer {\n"
"    Light u_LightData[MAX_MAP_LIGHTS];\n"
"};\n"
"#endif\n"
"\n"
"#if defined(USE_HDR) && defined(USE_EXPOSURE_TONE_MAPPING)\n"
"uniform float u_Exposure;\n"
"#endif\n"
"\n"
"#if defined(USE_NORMALMAP)\n"
"uniform sampler2D u_NormalMap;\n"
"#endif\n"
"\n"
"#if defined(USE_SPECULARMAP)\n"
"uniform sampler2D u_SpecularMap;\n"
"#endif\n"
"\n"
"#if defined(USE_SHADOWMAP)\n"
"uniform sampler2D u_ShadowMap;\n"
"#endif\n"
"\n"
"uniform int u_AlphaTest;\n"
"\n"
"float CalcLightAttenuation(float point, float normDist)\n"
"{\n"
"	// zero light at 1.0, approximating q3 style\n"
"	// also don't attenuate directional light\n"
"	float attenuation = (0.5 * normDist - 1.5) * point + 1.0;\n"
"\n"
"	// clamp attenuation\n"
"#if defined(NO_LIGHT_CLAMP)\n"
"	attenuation = max(attenuation, 0.0);\n"
"#else\n"
"	attenuation = clamp(attenuation, 0.0, 1.0);\n"
"#endif\n"
"\n"
"	return attenuation;\n"
"}\n"
"\n"
"#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"//\n"
"// CalcPointLight: don't modify, straight from Valden\n"
"//\n"
"vec3 CalcPointLight( Light light ) {\n"
"    vec3 diffuse = a_Color.rgb;\n"
"    float dist = distance( v_WorldPos, vec3( light.origin, v_WorldPos.z ) );\n"
"    float diff = 0.0;\n"
"    float range = light.range;\n"
"    if ( dist <= light.range ) {\n"
"        diff = 1.0 - abs( dist / range );\n"
"    }\n"
"    diff += light.brightness;\n"
"    diffuse = min( diff * ( diffuse + vec3( light.color ) ), diffuse );\n"
"\n"
"    vec3 lightDir = vec3( 0.0 );\n"
"    vec3 viewDir = normalize( v_WorldPos - vec3( light.origin, 0.0 ) );\n"
"    vec3 halfwayDir = normalize( lightDir + viewDir );\n"
"\n"
"    vec3 reflectDir = reflect( -lightDir, v_WorldPos );\n"
"    float spec = pow( max( dot( v_WorldPos, reflectDir ), 0.0 ), 1.0 );\n"
"\n"
"#if defined(USE_SPECULARMAP)\n"
"    vec3 specular = spec * texture( u_SpecularMap, v_TexCoords ).rgb;\n"
"#else\n"
"    vec3 specular = vec3( 0.0 );\n"
"#endif\n"
"\n"
"    range = light.range + light.brightness;\n"
"    float attenuation = ( light.constant + light.linear * range\n"
"        + light.quadratic * ( range * range ) );\n"
"\n"
"    diffuse *= attenuation;\n"
"    specular *= attenuation;\n"
"\n"
"    return diffuse + specular;\n"
"}\n"
"#endif\n"
"\n"
"vec3 CalcDiffuse(vec3 diffuseAlbedo, float NH, float EH, float roughness)\n"
"{\n"
"#if defined(USE_BURLEY)\n"
"	// modified from https://disney-animation.s3.amazonaws.com/library/s2012_pbs_disney_brdf_notes_v2.pdf\n"
"	float fd90 = -0.5 + EH * EH * roughness;\n"
"	float burley = 1.0 + fd90 * 0.04 / NH;\n"
"	burley *= burley;\n"
"	return diffuseAlbedo * burley;\n"
"#else\n"
"	return diffuseAlbedo;\n"
"#endif\n"
"}\n"
"\n"
"void CalcNormal() {\n"
"#if defined(USE_NORMALMAP)\n"
"    vec3 normal = texture( u_NormalMap, v_TexCoords ).rgb;\n"
"    normal = normalize( normal * 2.0 - 1.0 );\n"
"    a_Color.rgb *= normal * 0.5 + 0.5;\n"
"#endif\n"
"}\n"
"\n"
"void ApplyLighting() {\n"
"    a_Color = texture( u_DiffuseMap, v_TexCoords );\n"
"    CalcNormal();\n"
"#if defined(USE_SPECULARMAP)\n"
"    if ( u_NumLights == 0 ) {\n"
"        a_Color.rgb += texture( u_SpecularMap, v_TexCoords ).rgb;\n"
"    }\n"
"#endif\n"
"#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"    for ( int i = 0; i < u_NumLights; i++ ) {\n"
"        switch ( lights[i].type ) {\n"
"        case POINT_LIGHT:\n"
"            a_Color.rgb += CalcPointLight( u_LightData[i] );\n"
"            break;\n"
"        case DIRECTION_LIGHT:\n"
"            break;\n"
"        };\n"
"    }\n"
"#endif\n"
"    a_Color.rgb += texture( u_DiffuseMap, v_TexCoords ).rgb;\n"
"}\n"
"\n"
"// -- Sharpening --\n"
"uniform float u_SharpenAmount;\n"
"uniform vec2 u_ScreenSize;\n"
"\n"
"#define sharp_clamp 0.000  //[0.000 to 1.000] Limits maximum amount of sharpening a pixel recieves - Default is 0.035\n"
"\n"
"// -- Advanced sharpening settings --\n"
"\n"
"#define offset_bias 6.0  //[0.0 to 6.0] Offset bias adjusts the radius of the sampling pattern.\n"
"                         //I designed the pattern for offset_bias 1.0, but feel free to experiment.\n"
"\n"
"//#define CoefLuma vec3( 0.2126, 0.7152, 0.0722 )      // BT.709 & sRBG luma coefficient (Monitors and HD Television)\n"
"//#define CoefLuma vec3( 0.299, 0.587, 0.114 )       // BT.601 luma coefficient (SD Television)\n"
"#define CoefLuma vec3( 1.0/3.0, 1.0/3.0, 1.0/3.0 ) // Equal weight coefficient\n"
"\n"
"vec4 sharpenImage( sampler2D tex, vec2 pos )\n"
"{\n"
"	vec4 colorInput = texture2D(tex, pos);\n"
"\n"
"	vec3 ori = colorInput.rgb;\n"
"\n"
"	// -- Combining the strength and luma multipliers --\n"
"	vec3 sharp_strength_luma = (CoefLuma * u_SharpenAmount); //I'll be combining even more multipliers with it later on\n"
"\n"
"	// -- Gaussian filter --\n"
"	//   [ .25, .50, .25]     [ 1 , 2 , 1 ]\n"
"	//   [ .50,   1, .50]  =  [ 2 , 4 , 2 ]\n"
" 	//   [ .25, .50, .25]     [ 1 , 2 , 1 ]\n"
"\n"
"\n"
"    float px = 1.0/u_ScreenSize[0];\n"
"	float py = 1.0/u_ScreenSize[1];\n"
"\n"
"	vec3 blur_ori = texture2D(tex, pos + vec2(px,-py) * 0.5 * offset_bias).rgb; // South East\n"
"	blur_ori += texture2D(tex, pos + vec2(-px,-py) * 0.5 * offset_bias).rgb;  // South West\n"
"	blur_ori += texture2D(tex, pos + vec2(px,py) * 0.5 * offset_bias).rgb; // North East\n"
"	blur_ori += texture2D(tex, pos + vec2(-px,py) * 0.5 * offset_bias).rgb; // North West\n"
"\n"
"	blur_ori *= 0.25;  // ( /= 4) Divide by the number of texture fetches\n"
"\n"
"\n"
"\n"
"	// -- Calculate the sharpening --\n"
"	vec3 sharp = ori - blur_ori;  //Subtracting the blurred image from the original image\n"
"\n"
"	// -- Adjust strength of the sharpening and clamp it--\n"
"	vec4 sharp_strength_luma_clamp = vec4(sharp_strength_luma * (0.5 / sharp_clamp),0.5); //Roll part of the clamp into the dot\n"
"\n"
"	float sharp_luma = clamp((dot(vec4(sharp,1.0), sharp_strength_luma_clamp)), 0.0,1.0 ); //Calculate the luma, adjust the strength, scale up and clamp\n"
"	sharp_luma = (sharp_clamp * 2.0) * sharp_luma - sharp_clamp; //scale down\n"
"\n"
"\n"
"	// -- Combining the values to get the final sharpened pixel	--\n"
"\n"
"	colorInput.rgb = colorInput.rgb + sharp_luma;    // Add the sharpening to the input color.\n"
"	return clamp(colorInput, 0.0,1.0);\n"
"}\n"
"\n"
"void main() {\n"
"    a_Color = sharpenImage( u_DiffuseMap, v_TexCoords );\n"
"    ApplyLighting();\n"
"\n"
"#if defined(USE_HDR)\n"
"#if !defined(USE_EXPOSURE_TONE_MAPPING)\n"
"	// reinhard tone mapping\n"
"	a_Color.rgb = a_Color.rgb / ( a_Color.rgb + vec3( 1.0 ) );\n"
"#else\n"
"	// exposure tone mapping\n"
"	a_Color.rgb = vec3( 1.0 ) - exp( -a_Color.rgb * u_Exposure );\n"
"#endif\n"
"\n"
"#if defined(USE_BLOOM)\n"
"	// check whether fragment output is higher than threshold, if so output as brightness color\n"
"	float brightness = dot( a_Color.rgb, vec3( 0.2126, 0.7152, 0.0722 ) );\n"
"	if ( brightness > 1.0 ) {\n"
"		a_BrightColor = vec4( a_Color.rgb, 1.0 );\n"
"	} else {\n"
"		a_BrightColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n"
"	}\n"
"#endif\n"
"#endif\n"
"	a_Color.rgb = pow( a_Color.rgb, vec3( 1.0 / u_GammaAmount ) );\n"
"}\n"
;

const char *fallbackShader_lightall_vp =
"in vec4 a_TexCoords;\n"
"#if defined(USE_LIGHTMAP) || defined(USE_TCGEN)\n"
"in vec4 a_LightCoords;\n"
"#endif\n"
"in vec4 a_Color;\n"
"\n"
"in vec3 a_Position;\n"
"in vec3 a_Normal;\n"
"in vec4 a_Tangent;\n"
"\n"
"#if defined(USE_LIGHT) && !defined(USE_LIGHT_VECTOR)\n"
"//in vec3 a_LightDirection;\n"
"#endif\n"
"\n"
"#if defined(USE_DELUXEMAP)\n"
"uniform vec4   u_EnableTextures; // x = normal, y = deluxe, z = specular, w = cube\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"uniform vec3   u_ViewOrigin;\n"
"#endif\n"
"\n"
"#if defined(USE_TCGEN)\n"
"uniform int    u_TCGen0;\n"
"uniform vec3   u_TCGen0Vector0;\n"
"uniform vec3   u_TCGen0Vector1;\n"
"uniform vec3   u_LocalViewOrigin;\n"
"#endif\n"
"\n"
"#if defined(USE_TCMOD)\n"
"uniform vec4   u_DiffuseTexMatrix;\n"
"uniform vec4   u_DiffuseTexOffTurb;\n"
"#endif\n"
"\n"
"uniform mat4   u_ModelViewProjectionMatrix;\n"
"uniform vec4   u_BaseColor;\n"
"uniform vec4   u_VertColor;\n"
"\n"
"#if defined(USE_MODELMATRIX)\n"
"uniform mat4   u_ModelMatrix;\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHT_VECTOR)\n"
"uniform vec4   u_LightOrigin;\n"
"uniform float  u_LightRadius;\n"
"uniform vec3   u_DirectedLight;\n"
"uniform vec3   u_AmbientLight;\n"
"#endif\n"
"\n"
"#if defined(USE_PRIMARY_LIGHT) || defined(USE_SHADOWMAP)\n"
"uniform vec4  u_PrimaryLightOrigin;\n"
"uniform float u_PrimaryLightRadius;\n"
"#endif\n"
"\n"
"out vec4   v_TexCoords;\n"
"\n"
"out vec4   v_Color;\n"
"#if defined(USE_LIGHT_VECTOR) && !defined(USE_FAST_LIGHT)\n"
"out vec4   v_ColorAmbient;\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"out vec4   v_Normal;\n"
"out vec4   v_Tangent;\n"
"out vec4   v_Bitangent;\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"out vec4   v_LightDir;\n"
"#endif\n"
"\n"
"#if defined(USE_PRIMARY_LIGHT) || defined(USE_SHADOWMAP)\n"
"out vec4   v_PrimaryLightDir;\n"
"#endif\n"
"\n"
"#if defined(USE_TCGEN)\n"
"vec2 GenTexCoords(int TCGen, vec3 position, vec3 normal, vec3 TCGenVector0, vec3 TCGenVector1)\n"
"{\n"
"	vec2 tex = a_TexCoords.st;\n"
"\n"
"	if (TCGen == TCGEN_LIGHTMAP)\n"
"	{\n"
"		tex = a_LightCoords.st;\n"
"	}\n"
"	else if (TCGen == TCGEN_ENVIRONMENT_MAPPED)\n"
"	{\n"
"		vec3 viewer = normalize(u_LocalViewOrigin - position);\n"
"		vec2 ref = reflect(viewer, normal).yz;\n"
"		tex.s = ref.x * -0.5 + 0.5;\n"
"		tex.t = ref.y *  0.5 + 0.5;\n"
"	}\n"
"	else if (TCGen == TCGEN_VECTOR)\n"
"	{\n"
"		tex = vec2(dot(position, TCGenVector0), dot(position, TCGenVector1));\n"
"	}\n"
"\n"
"	return tex;\n"
"}\n"
"#endif\n"
"\n"
"#if defined(USE_TCMOD)\n"
"vec2 ModTexCoords(vec2 st, vec3 position, vec4 texMatrix, vec4 offTurb)\n"
"{\n"
"	float amplitude = offTurb.z;\n"
"	float phase = offTurb.w * 2.0 * M_PI;\n"
"	vec2 st2;\n"
"	st2.x = st.x * texMatrix.x + (st.y * texMatrix.z + offTurb.x);\n"
"	st2.y = st.x * texMatrix.y + (st.y * texMatrix.w + offTurb.y);\n"
"\n"
"	vec2 offsetPos = vec2(position.x + position.z, position.y);\n"
"\n"
"	vec2 texOffset = sin(offsetPos * (2.0 * M_PI / 1024.0) + vec2(phase));\n"
"\n"
"	return st2 + texOffset * amplitude;\n"
"}\n"
"#endif\n"
"\n"
"\n"
"float CalcLightAttenuation(float point, float normDist)\n"
"{\n"
"	// zero light at 1.0, approximating q3 style\n"
"	// also don't attenuate directional light\n"
"	float attenuation = (0.5 * normDist - 1.5) * point + 1.0;\n"
"\n"
"	// clamp attenuation\n"
"	#if defined(NO_LIGHT_CLAMP)\n"
"	attenuation = max(attenuation, 0.0);\n"
"	#else\n"
"	attenuation = clamp(attenuation, 0.0, 1.0);\n"
"	#endif\n"
"\n"
"	return attenuation;\n"
"}\n"
"\n"
"\n"
"void main()\n"
"{\n"
"	vec3 position  = a_Position;\n"
"	vec3 normal    = a_Normal;\n"
"#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"	vec3 tangent   = a_Tangent.xyz;\n"
"#endif\n"
"\n"
"#if defined(USE_TCGEN)\n"
"	vec2 texCoords = GenTexCoords(u_TCGen0, position, normal, u_TCGen0Vector0, u_TCGen0Vector1);\n"
"#else\n"
"	vec2 texCoords = a_TexCoords.st;\n"
"#endif\n"
"\n"
"#if defined(USE_TCMOD)\n"
"	v_TexCoords.xy = ModTexCoords(texCoords, position, u_DiffuseTexMatrix, u_DiffuseTexOffTurb);\n"
"#else\n"
"	v_TexCoords.xy = texCoords;\n"
"#endif\n"
"\n"
"	gl_Position = u_ModelViewProjectionMatrix * vec4(position, 1.0);\n"
"\n"
"#if defined(USE_MODELMATRIX)\n"
"	position  = (u_ModelMatrix * vec4(position, 1.0)).xyz;\n"
"	normal    = (u_ModelMatrix * vec4(normal,   0.0)).xyz;\n"
"  #if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"	tangent   = (u_ModelMatrix * vec4(tangent,  0.0)).xyz;\n"
"  #endif\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"	vec3 bitangent = cross(normal, tangent) * a_Tangent.w;\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHT_VECTOR)\n"
"	vec3 L = u_LightOrigin.xyz - (position * u_LightOrigin.w);\n"
"#elif defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"//	vec3 L = a_LightDirection;\n"
"	vec3 L = vec3( 0.0 );\n"
"  #if defined(USE_MODELMATRIX)\n"
"	L = (u_ModelMatrix * vec4(L, 0.0)).xyz;\n"
"  #endif\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHTMAP)\n"
"	v_TexCoords.zw = a_LightCoords.st;\n"
"#endif\n"
"\n"
"	v_Color = u_VertColor * a_Color + u_BaseColor;\n"
"\n"
"#if defined(USE_LIGHT_VECTOR)\n"
"  #if defined(USE_FAST_LIGHT)\n"
"	float sqrLightDist = dot(L, L);\n"
"	float NL = clamp(dot(normalize(normal), L) / sqrt(sqrLightDist), 0.0, 1.0);\n"
"	float attenuation = CalcLightAttenuation(u_LightOrigin.w, u_LightRadius * u_LightRadius / sqrLightDist);\n"
"\n"
"	v_Color.rgb *= u_DirectedLight * (attenuation * NL) + u_AmbientLight;\n"
"  #else\n"
"	v_ColorAmbient.rgb = u_AmbientLight * v_Color.rgb;\n"
"	v_Color.rgb *= u_DirectedLight;\n"
"    #if defined(USE_PBR)\n"
"	v_ColorAmbient.rgb *= v_ColorAmbient.rgb;\n"
"    #endif\n"
"  #endif\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT) && defined(USE_PBR)\n"
"	v_Color.rgb *= v_Color.rgb;\n"
"#endif\n"
"\n"
"#if defined(USE_PRIMARY_LIGHT) || defined(USE_SHADOWMAP)\n"
"	v_PrimaryLightDir.xyz = u_PrimaryLightOrigin.xyz - (position * u_PrimaryLightOrigin.w);\n"
"	v_PrimaryLightDir.w = u_PrimaryLightRadius * u_PrimaryLightRadius;\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"  #if defined(USE_LIGHT_VECTOR)\n"
"	v_LightDir = vec4(L, u_LightRadius * u_LightRadius);\n"
"  #else\n"
"	v_LightDir = vec4(L, 0.0);\n"
"  #endif\n"
"  #if defined(USE_DELUXEMAP)\n"
"	v_LightDir -= u_EnableTextures.y * v_LightDir;\n"
"  #endif\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"	vec3 viewDir = u_ViewOrigin - position;\n"
"	// store view direction in tangent space to save on outs\n"
"	v_Normal    = vec4(normal,    viewDir.x);\n"
"	v_Tangent   = vec4(tangent,   viewDir.y);\n"
"	v_Bitangent = vec4(bitangent, viewDir.z);\n"
"#endif\n"
"}\n"
;

const char *fallbackShader_imgui_fp =
"#if !defined(GLSL_LEGACY)\n"
"layout( location = 0 ) out vec4 a_Color;\n"
"#endif\n"
"\n"
"#if defined(USE_FXAA)\n"
"#if !defined(FXAA_PRESET)\n"
"    #define FXAA_PRESET 5\n"
"#endif\n"
"#if FXAA_PRESET == 3\n"
"    #define FXAA_EDGE_THRESHOLD      ( 1.0 / 8.0 )\n"
"    #define FXAA_EDGE_THRESHOLD_MIN  ( 1.0 / 16.0 )\n"
"    #define FXAA_SEARCH_STEPS        16\n"
"    #define FXAA_SEARCH_THRESHOLD    ( 1.0 / 4.0 )\n"
"    #define FXAA_SUBPIX_CAP          ( 3.0 / 4.0 )\n"
"    #define FXAA_SUBPIX_TRIM         ( 1.0 / 4.0 )\n"
"#elif FXAA_PRESET == 4\n"
"    #define FXAA_EDGE_THRESHOLD      ( 1.0 / 8.0 )\n"
"    #define FXAA_EDGE_THRESHOLD_MIN  ( 1.0 / 24.0 )\n"
"    #define FXAA_SEARCH_STEPS        24\n"
"    #define FXAA_SEARCH_THRESHOLD    ( 1.0 / 4.0 )\n"
"    #define FXAA_SUBPIX_CAP          ( 3.0 / 4.0 )\n"
"    #define FXAA_SUBPIX_TRIM         ( 1.0 / 4.0 )\n"
"#elif FXAA_PRESET == 5\n"
"    #define FXAA_EDGE_THRESHOLD      ( 1.0 / 8.0 )\n"
"    #define FXAA_EDGE_THRESHOLD_MIN  ( 1.0 / 24.0 )\n"
"    #define FXAA_SEARCH_STEPS        32\n"
"    #define FXAA_SEARCH_THRESHOLD    ( 1.0 / 4.0 )\n"
"    #define FXAA_SUBPIX_CAP          ( 3.0 / 4.0 )\n"
"    #define FXAA_SUBPIX_TRIM         ( 1.0 / 4.0 )\n"
"#endif\n"
"\n"
"#define FXAA_SUBPIX_TRIM_SCALE ( 1.0 / ( 1.0 - FXAA_SUBPIX_TRIM ) )\n"
"\n"
"#if !defined(FXAA_REDUCE_MIN)\n"
"    #define FXAA_REDUCE_MIN   (1.0/ 128.0)\n"
"#endif\n"
"#if !defined(FXAA_REDUCE_MUL)\n"
"    #define FXAA_REDUCE_MUL   (1.0 / 8.0)\n"
"#endif\n"
"#if !defined(FXAA_SPAN_MAX)\n"
"    #define FXAA_SPAN_MAX     8.0\n"
"#endif\n"
"#endif\n"
"\n"
"in vec2 v_TexCoords;\n"
"in vec4 v_Color;\n"
"\n"
"uniform sampler2D u_DiffuseMap;\n"
"uniform float u_GammaAmount;\n"
"\n"
"uniform vec2 u_ScreenSize;\n"
"\n"
"#if defined(USE_FXAA)\n"
"vec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 resolution,\n"
"            vec2 v_rgbNW, vec2 v_rgbNE,\n"
"            vec2 v_rgbSW, vec2 v_rgbSE,\n"
"            vec2 v_rgbM) {\n"
"    vec4 color;\n"
"    mediump vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);\n"
"    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\n"
"    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\n"
"    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\n"
"    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\n"
"    vec4 texColor = texture2D(tex, v_rgbM);\n"
"    vec3 rgbM  = texColor.xyz;\n"
"    vec3 luma = vec3(0.299, 0.587, 0.114);\n"
"    float lumaNW = dot(rgbNW, luma);\n"
"    float lumaNE = dot(rgbNE, luma);\n"
"    float lumaSW = dot(rgbSW, luma);\n"
"    float lumaSE = dot(rgbSE, luma);\n"
"    float lumaM  = dot(rgbM,  luma);\n"
"    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n"
"    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n"
"\n"
"    mediump vec2 dir;\n"
"    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n"
"    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n"
"\n"
"    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n"
"                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n"
"\n"
"    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n"
"    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n"
"              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n"
"              dir * rcpDirMin)) * inverseVP;\n"
"\n"
"    vec3 rgbA = 0.5 * (\n"
"        texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\n"
"        texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n"
"    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n"
"        texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\n"
"        texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n"
"\n"
"    float lumaB = dot(rgbB, luma);\n"
"    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n"
"        color = vec4(rgbA, texColor.a);\n"
"    else\n"
"        color = vec4(rgbB, texColor.a);\n"
"    return color;\n"
"}\n"
"\n"
"void texcoords(vec2 fragCoord, vec2 resolution,\n"
"			out vec2 v_rgbNW, out vec2 v_rgbNE,\n"
"			out vec2 v_rgbSW, out vec2 v_rgbSE,\n"
"			out vec2 v_rgbM) {\n"
"	vec2 inverseVP = 1.0 / resolution.xy;\n"
"	v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n"
"	v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n"
"	v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n"
"	v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n"
"	v_rgbM = vec2(fragCoord * inverseVP);\n"
"}\n"
"#endif\n"
"\n"
"#if 0\n"
"\n"
"#define SHARPEN_FACTOR 4.0\n"
"\n"
"vec4 sharpenMask (sampler2D tex, vec2 fragCoord)\n"
"{\n"
"    // Sharpen detection matrix [0,1,0],[1,-4,1],[0,1,0]\n"
"    // Colors\n"
"    vec4 up = texture (tex, (fragCoord + vec2 (0, 1))/u_ScreenSize.xy);\n"
"    vec4 left = texture (tex, (fragCoord + vec2 (-1, 0))/u_ScreenSize.xy);\n"
"    vec4 center = texture (tex, fragCoord/u_ScreenSize.xy);\n"
"    vec4 right = texture (tex, (fragCoord + vec2 (1, 0))/u_ScreenSize.xy);\n"
"    vec4 down = texture (tex, (fragCoord + vec2 (0, -1))/u_ScreenSize.xy);\n"
"\n"
"    // Return edge detection\n"
"    return (1.0 + 4.0*SHARPEN_FACTOR)*center -SHARPEN_FACTOR*(up + left + right + down);\n"
"}\n"
"\n"
"vec4 sharpen( sampler2D tex, in vec2 coords ) {\n"
"    float dx = 1.0 / u_ScreenSize.x;\n"
"    float dy = 1.0 / u_ScreenSize.y;\n"
"    vec4 sum = vec4(0.0);\n"
"    sum += -1. * texture2D(tex, coords + vec2( -1.0 * dx , 0.0 * dy));\n"
"    sum += -1. * texture2D(tex, coords + vec2( 0.0 * dx , -1.0 * dy));\n"
"    sum += 5. * texture2D(tex, coords + vec2( 0.0 * dx , 0.0 * dy));\n"
"    sum += -1. * texture2D(tex, coords + vec2( 0.0 * dx , 1.0 * dy));\n"
"    sum += -1. * texture2D(tex, coords + vec2( 1.0 * dx , 0.0 * dy));\n"
"    return sum;\n"
"}\n"
"#endif\n"
"\n"
"// -- Sharpening --\n"
"uniform float u_SharpenAmount;\n"
"\n"
"#define sharp_clamp 0.000  //[0.000 to 1.000] Limits maximum amount of sharpening a pixel recieves - Default is 0.035\n"
"\n"
"// -- Advanced sharpening settings --\n"
"\n"
"#define offset_bias 6.0  //[0.0 to 6.0] Offset bias adjusts the radius of the sampling pattern.\n"
"                         //I designed the pattern for offset_bias 1.0, but feel free to experiment.\n"
"\n"
"//#define CoefLuma vec3( 0.2126, 0.7152, 0.0722 )      // BT.709 & sRBG luma coefficient (Monitors and HD Television)\n"
"//#define CoefLuma vec3( 0.299, 0.587, 0.114 )       // BT.601 luma coefficient (SD Television)\n"
"#define CoefLuma vec3( 1.0/3.0, 1.0/3.0, 1.0/3.0 ) // Equal weight coefficient\n"
"\n"
"vec4 sharpenImage( sampler2D tex, vec2 pos )\n"
"{\n"
"	vec4 colorInput = texture2D(tex, pos);\n"
"\n"
"	vec3 ori = colorInput.rgb;\n"
"\n"
"	// -- Combining the strength and luma multipliers --\n"
"	vec3 sharp_strength_luma = (CoefLuma * u_SharpenAmount); //I'll be combining even more multipliers with it later on\n"
"\n"
"	// -- Gaussian filter --\n"
"	//   [ .25, .50, .25]     [ 1 , 2 , 1 ]\n"
"	//   [ .50,   1, .50]  =  [ 2 , 4 , 2 ]\n"
" 	//   [ .25, .50, .25]     [ 1 , 2 , 1 ]\n"
"\n"
"\n"
"    float px = 1.0/u_ScreenSize[0];\n"
"	float py = 1.0/u_ScreenSize[1];\n"
"\n"
"	vec3 blur_ori = texture2D(tex, pos + vec2(px,-py) * 0.5 * offset_bias).rgb; // South East\n"
"	blur_ori += texture2D(tex, pos + vec2(-px,-py) * 0.5 * offset_bias).rgb;  // South West\n"
"	blur_ori += texture2D(tex, pos + vec2(px,py) * 0.5 * offset_bias).rgb; // North East\n"
"	blur_ori += texture2D(tex, pos + vec2(-px,py) * 0.5 * offset_bias).rgb; // North West\n"
"\n"
"	blur_ori *= 0.25;  // ( /= 4) Divide by the number of texture fetches\n"
"\n"
"\n"
"\n"
"	// -- Calculate the sharpening --\n"
"	vec3 sharp = ori - blur_ori;  //Subtracting the blurred image from the original image\n"
"\n"
"	// -- Adjust strength of the sharpening and clamp it--\n"
"	vec4 sharp_strength_luma_clamp = vec4(sharp_strength_luma * (0.5 / sharp_clamp),0.5); //Roll part of the clamp into the dot\n"
"\n"
"	float sharp_luma = clamp((dot(vec4(sharp,1.0), sharp_strength_luma_clamp)), 0.0,1.0 ); //Calculate the luma, adjust the strength, scale up and clamp\n"
"	sharp_luma = (sharp_clamp * 2.0) * sharp_luma - sharp_clamp; //scale down\n"
"\n"
"\n"
"	// -- Combining the values to get the final sharpened pixel	--\n"
"\n"
"	colorInput.rgb = colorInput.rgb + sharp_luma;    // Add the sharpening to the input color.\n"
"	return clamp(colorInput, 0.0,1.0);\n"
"}\n"
"\n"
"void main() {\n"
"#if defined(USE_FXAA)\n"
"	vec2 rgbNW, rgbNE, rgbSW, rgbSE, rgbM;\n"
"\n"
"	texcoords( v_TexCoords, u_ScreenSize, rgbNW,rgbNE, rgbSW, rgbSE, rgbM );\n"
"	a_Color = v_Color * fxaa( u_DiffuseMap, v_TexCoords, u_ScreenSize, rgbNW, rgbNE, rgbSW, rgbSE, rgbM );\n"
"#else\n"
"    a_Color = v_Color * sharpenImage( u_DiffuseMap, v_TexCoords );\n"
"//	a_Color = v_Color * texture2D( u_DiffuseMap, v_TexCoords );\n"
"#endif\n"
"\n"
"    a_Color.rgb = pow( a_Color.rgb, vec3( 1.0 / u_GammaAmount ) );\n"
"}\n"
;

const char *fallbackShader_bokeh_vp =
"in vec3 a_Position;\n"
"in vec4 a_LightCoords;\n"
"\n"
"uniform mat4 u_ModelViewProjection;\n"
"\n"
"out vec2 v_TexCoords;\n"
"\n"
"void main() {\n"
"	gl_Position = u_ModelViewProjection * vec4( a_Position, 1.0 );\n"
"	v_TexCoords = a_LightCoords.st;\n"
"}\n"
;

const char *fallbackShader_depthblur_fp =
"#if !defined(GLSL_LEGACY)\n"
"out vec4 a_Color;\n"
"#endif\n"
"\n"
"uniform sampler2D u_ScreenImageMap;\n"
"uniform sampler2D u_ScreenDepthMap;\n"
"\n"
"uniform vec4 u_ViewInfo; // zfar / znear, zfar, 1/width, 1/height\n"
"in vec2 v_ScreenTex;\n"
"\n"
"//float gauss[8] = float[8](0.17, 0.17, 0.16, 0.14, 0.12, 0.1, 0.08, 0.06);\n"
"//float gauss[5] = float[5](0.30, 0.23, 0.097, 0.024, 0.0033);\n"
"//float gauss[4] = float[4](0.40, 0.24, 0.054, 0.0044);\n"
"//float gauss[3] = float[3](0.60, 0.19, 0.0066);\n"
"#define BLUR_SIZE 4\n"
"\n"
"#if !defined(USE_DEPTH)\n"
"//#define USE_GAUSS\n"
"#endif\n"
"\n"
"float getLinearDepth(sampler2D depthMap, const vec2 tex, const float zFarDivZNear) {\n"
"	float sampleZDivW = texture2D(depthMap, tex).r;\n"
"	return 1.0 / mix(zFarDivZNear, 1.0, sampleZDivW);\n"
"}\n"
"\n"
"vec4 depthGaussian1D(sampler2D imageMap, sampler2D depthMap, vec2 tex, float zFarDivZNear, float zFar, vec2 scale)\n"
"{\n"
"	float gauss[4];\n"
"\n"
"	gauss[0] = 0.40;\n"
"	gauss[1] = 0.24;\n"
"	gauss[2] = 0.054;\n"
"	gauss[3] = 0.0044;\n"
"\n"
"#if defined(USE_DEPTH)\n"
"	float depthCenter = getLinearDepth(depthMap, tex, zFarDivZNear);\n"
"	vec2 slope = vec2(dFdx(depthCenter), dFdy(depthCenter)) / vec2(dFdx(tex.x), dFdy(tex.y));\n"
"	scale /= clamp(zFarDivZNear * depthCenter / 32.0, 1.0, 2.0);\n"
"#endif\n"
"\n"
"#if defined(USE_HORIZONTAL_BLUR)\n"
"	vec2 direction = vec2(scale.x * 2.0, 0.0);\n"
"	vec2 nudge = vec2(0.0, scale.y * 0.5);\n"
"#else // if defined(USE_VERTICAL_BLUR)\n"
"	vec2 direction = vec2(0.0, scale.y * 2.0);\n"
"	vec2 nudge = vec2(-scale.x * 0.5, 0.0);\n"
"#endif\n"
"\n"
"#if defined(USE_GAUSS)\n"
"	vec4 result = texture2D(imageMap, tex) * gauss[0];\n"
"	float total = gauss[0];\n"
"#else\n"
"	vec4 result = texture2D(imageMap, tex);\n"
"	float total = 1.0;\n"
"#endif\n"
"\n"
"	float zLimit = 5.0 / zFar;\n"
"	int i, j;\n"
"	for (i = 0; i < 2; i++)\n"
"	{\n"
"		for (j = 1; j < BLUR_SIZE; j++)\n"
"		{\n"
"			vec2 offset = direction * (float(j) - 0.25) + nudge;\n"
"#if defined(USE_DEPTH)\n"
"			float depthSample = getLinearDepth(depthMap, tex + offset, zFarDivZNear);\n"
"			float depthExpected = depthCenter + dot(slope, offset);\n"
"			float useSample = float(abs(depthSample - depthExpected) < zLimit);\n"
"#else\n"
"			float useSample = 1.0;\n"
"#endif\n"
"#if defined(USE_GAUSS)\n"
"			result += texture2D(imageMap, tex + offset) * (gauss[j] * useSample);\n"
"			total += gauss[j] * useSample;\n"
"#else\n"
"			result += texture2D(imageMap, tex + offset) * useSample;\n"
"			total += useSample;\n"
"#endif\n"
"			nudge = -nudge;\n"
"		}\n"
"\n"
"		direction = -direction;\n"
"		nudge = -nudge;\n"
"	}\n"
"\n"
"	return result / total;\n"
"}\n"
"\n"
"void main() {\n"
"	a_Color = depthGaussian1D(u_ScreenImageMap, u_ScreenDepthMap, v_ScreenTex, u_ViewInfo.x, u_ViewInfo.y, u_ViewInfo.zw);\n"
"}\n"
;

const char *fallbackShader_bokeh_fp =
"#if !defined(GLSL_LEGACY)\n"
"out vec4 a_Color;\n"
"#endif\n"
"\n"
"uniform sampler2D u_TextureMap;\n"
"\n"
"uniform vec4 u_Color;\n"
"uniform vec2 u_InvTexRes;\n"
"\n"
"in vec2 v_TexCoords;\n"
"\n"
"void main()\n"
"{\n"
"	vec4 color;\n"
"	vec2 tc;\n"
"\n"
"#if 0\n"
"	float c[7];\n"
"\n"
"	c[0] = 1.0;\n"
"	c[1] = 0.9659258263;\n"
"	c[2] = 0.8660254038;\n"
"	c[3] = 0.7071067812;\n"
"	c[4] = 0.5;\n"
"	c[5] = 0.2588190451;\n"
"	c[6] = 0.0;\n"
"\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[0],  c[6]);  color =  texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[1],  c[5]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[2],  c[4]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[3],  c[3]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[4],  c[2]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[5],  c[1]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[6],  c[0]);  color += texture2D(u_TextureMap, tc);\n"
"\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[1], -c[5]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[2], -c[4]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[3], -c[3]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[4], -c[2]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[5], -c[1]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[6], -c[0]);  color += texture2D(u_TextureMap, tc);\n"
"\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( -c[0],  c[6]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( -c[1],  c[5]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( -c[2],  c[4]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( -c[3],  c[3]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( -c[4],  c[2]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( -c[5],  c[1]);  color += texture2D(u_TextureMap, tc);\n"
"\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( -c[1], -c[5]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( -c[2], -c[4]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( -c[3], -c[3]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( -c[4], -c[2]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( -c[5], -c[1]);  color += texture2D(u_TextureMap, tc);\n"
"\n"
"	a_Color = color * 0.04166667 * u_Color;\n"
"#endif\n"
"\n"
"	float c[5];\n"
"\n"
"	c[0] = 1.0;\n"
"	c[1] = 0.9238795325;\n"
"	c[2] = 0.7071067812;\n"
"	c[3] = 0.3826834324;\n"
"	c[4] = 0.0;\n"
"\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[0],  c[4]);  color =  texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[1],  c[3]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[2],  c[2]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[3],  c[1]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[4],  c[0]);  color += texture2D(u_TextureMap, tc);\n"
"\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[1], -c[3]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[2], -c[2]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[3], -c[1]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[4], -c[0]);  color += texture2D(u_TextureMap, tc);\n"
"\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( -c[0],  c[4]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( -c[1],  c[3]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( -c[2],  c[2]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( -c[3],  c[1]);  color += texture2D(u_TextureMap, tc);\n"
"\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( -c[1], -c[3]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( -c[2], -c[2]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( -c[3], -c[1]);  color += texture2D(u_TextureMap, tc);\n"
"\n"
"	a_Color = color * 0.0625 * u_Color;\n"
"}\n"
;

const char *fallbackShader_calclevels4x_fp =
"#if !defined(GLSL_LEGACY)\n"
"out vec4 a_Color;\n"
"#endif\n"
"\n"
"uniform sampler2D u_TextureMap;\n"
"\n"
"uniform vec4 u_Color;\n"
"uniform vec2 u_InvTexRes;\n"
"\n"
"in vec2 v_TexCoords;\n"
"\n"
"const vec3 LUMINANCE_VECTOR = vec3(0.2125, 0.7154, 0.0721); //vec3(0.299, 0.587, 0.114);\n"
"\n"
"vec3 GetValues( vec2 offset, vec3 current )\n"
"{\n"
"	vec2 tc = v_TexCoords + u_InvTexRes * offset;\n"
"	vec3 minAvgMax = texture2D( u_TextureMap, tc ).rgb;\n"
"\n"
"#ifdef FIRST_PASS\n"
"  #if defined(USE_PBR)\n"
"	minAvgMax *= minAvgMax;\n"
"  #endif\n"
"\n"
"	float lumi = max(dot(LUMINANCE_VECTOR, minAvgMax), 0.000001);\n"
"	float loglumi = clamp(log2(lumi), -10.0, 10.0);\n"
"	minAvgMax = vec3(loglumi * 0.05 + 0.5);\n"
"#endif\n"
"\n"
"	return vec3(min(current.x, minAvgMax.x), current.y + minAvgMax.y, max(current.z, minAvgMax.z));\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"	vec3 current = vec3(1.0, 0.0, 0.0);\n"
"\n"
"#ifdef FIRST_PASS\n"
"	current = GetValues(vec2( 0.0,  0.0), current);\n"
"#else\n"
"	current = GetValues(vec2(-1.5, -1.5), current);\n"
"	current = GetValues(vec2(-0.5, -1.5), current);\n"
"	current = GetValues(vec2( 0.5, -1.5), current);\n"
"	current = GetValues(vec2( 1.5, -1.5), current);\n"
"\n"
"	current = GetValues(vec2(-1.5, -0.5), current);\n"
"	current = GetValues(vec2(-0.5, -0.5), current);\n"
"	current = GetValues(vec2( 0.5, -0.5), current);\n"
"	current = GetValues(vec2( 1.5, -0.5), current);\n"
"\n"
"	current = GetValues(vec2(-1.5,  0.5), current);\n"
"	current = GetValues(vec2(-0.5,  0.5), current);\n"
"	current = GetValues(vec2( 0.5,  0.5), current);\n"
"	current = GetValues(vec2( 1.5,  0.5), current);\n"
"\n"
"	current = GetValues(vec2(-1.5,  1.5), current);\n"
"	current = GetValues(vec2(-0.5,  1.5), current);\n"
"	current = GetValues(vec2( 0.5,  1.5), current);\n"
"	current = GetValues(vec2( 1.5,  1.5), current);\n"
"\n"
"	current.y *= 0.0625;\n"
"#endif\n"
"\n"
"	a_Color = vec4(current, 1.0);\n"
"}\n"
;

const char *fallbackShader_lightall_fp =
"#if !defined(GLSL_LEGACY)\n"
"out vec4 a_Color;\n"
"#endif\n"
"\n"
"uniform sampler2D u_DiffuseMap;\n"
"\n"
"#if defined(USE_LIGHTMAP)\n"
"uniform sampler2D u_LightMap;\n"
"#endif\n"
"\n"
"#if defined(USE_NORMALMAP)\n"
"uniform sampler2D u_NormalMap;\n"
"#endif\n"
"\n"
"#if defined(USE_DELUXEMAP)\n"
"uniform sampler2D u_DeluxeMap;\n"
"#endif\n"
"\n"
"#if defined(USE_SPECULARMAP)\n"
"uniform sampler2D u_SpecularMap;\n"
"#endif\n"
"\n"
"#if defined(USE_SHADOWMAP)\n"
"uniform sampler2D u_ShadowMap;\n"
"#endif\n"
"\n"
"#if defined(USE_CUBEMAP)\n"
"uniform samplerCube u_CubeMap;\n"
"#endif\n"
"\n"
"#if defined(USE_NORMALMAP) || defined(USE_DELUXEMAP) || defined(USE_SPECULARMAP) || defined(USE_CUBEMAP)\n"
"// y = deluxe, w = cube\n"
"uniform vec4      u_EnableTextures;\n"
"#endif\n"
"\n"
"#if defined(USE_PRIMARY_LIGHT) || defined(USE_SHADOWMAP)\n"
"uniform vec3  u_PrimaryLightColor;\n"
"uniform vec3  u_PrimaryLightAmbient;\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"uniform vec4      u_NormalScale;\n"
"uniform vec4      u_SpecularScale;\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"#if defined(USE_CUBEMAP)\n"
"uniform vec4      u_CubeMapInfo;\n"
"#endif\n"
"#endif\n"
"\n"
"uniform int       u_AlphaTest;\n"
"\n"
"in vec4      v_TexCoords;\n"
"\n"
"in vec4      v_Color;\n"
"#if (defined(USE_LIGHT) && !defined(USE_FAST_LIGHT))\n"
"in vec4      v_ColorAmbient;\n"
"#endif\n"
"\n"
"#if (defined(USE_LIGHT) && !defined(USE_FAST_LIGHT))\n"
"in vec4   v_Normal;\n"
"in vec4   v_Tangent;\n"
"in vec4   v_Bitangent;\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"in vec4      v_LightDir;\n"
"#endif\n"
"\n"
"#if defined(USE_PRIMARY_LIGHT) || defined(USE_SHADOWMAP)\n"
"in vec4      v_PrimaryLightDir;\n"
"#endif\n"
"\n"
"\n"
"#define EPSILON 0.00000001\n"
"\n"
"#if defined(USE_PARALLAXMAP)\n"
"float SampleDepth(sampler2D normalMap, vec2 t)\n"
"{\n"
"  #if defined(SWIZZLE_NORMALMAP)\n"
"	return 1.0 - texture2D(normalMap, t).r;\n"
"  #else\n"
"	return 1.0 - texture2D(normalMap, t).a;\n"
"  #endif\n"
"}\n"
"\n"
"float RayIntersectDisplaceMap(vec2 dp, vec2 ds, sampler2D normalMap)\n"
"{\n"
"	const int linearSearchSteps = 16;\n"
"	const int binarySearchSteps = 6;\n"
"\n"
"	// current size of search window\n"
"	float size = 1.0 / float(linearSearchSteps);\n"
"\n"
"	// adjust position if offset above surface\n"
"	dp -= ds * r_parallaxMapOffset;\n"
"	// current depth position\n"
"	float depth = 0.0;\n"
"\n"
"	// best match found (starts with last position 1.0)\n"
"	float bestDepth = 1.0;\n"
"\n"
"	// texture depth at best depth\n"
"	float texDepth = 0.0;\n"
"\n"
"	float prevT = SampleDepth(normalMap, dp);\n"
"	float prevTexDepth = prevT;\n"
"\n"
"	// search front to back for first point inside object\n"
"	for(int i = 0; i < linearSearchSteps - 1; ++i)\n"
"	{\n"
"		depth += size;\n"
"\n"
"		float t = SampleDepth(normalMap, dp + ds * depth);\n"
"\n"
"		if(bestDepth > 0.996)		// if no depth found yet\n"
"			if(depth >= t)\n"
"			{\n"
"				bestDepth = depth;	// store best depth\n"
"				texDepth = t;\n"
"				prevTexDepth = prevT;\n"
"			}\n"
"		prevT = t;\n"
"	}\n"
"\n"
"	depth = bestDepth;\n"
"\n"
"#if !defined (USE_RELIEFMAP)\n"
"	float div = 1.0 / (1.0 + (prevTexDepth - texDepth) * float(linearSearchSteps));\n"
"	bestDepth -= (depth - size - prevTexDepth) * div;\n"
"#else\n"
"	// recurse around first point (depth) for closest match\n"
"	for(int i = 0; i < binarySearchSteps; ++i)\n"
"	{\n"
"		size *= 0.5;\n"
"\n"
"		float t = SampleDepth(normalMap, dp + ds * depth);\n"
"\n"
"		if(depth >= t)\n"
"		{\n"
"			bestDepth = depth;\n"
"			depth -= 2.0 * size;\n"
"		}\n"
"\n"
"		depth += size;\n"
"	}\n"
"#endif\n"
"\n"
"	return bestDepth - r_parallaxMapOffset;\n"
"}\n"
"\n"
"float LightRay(vec2 dp, vec2 ds, sampler2D normalMap)\n"
"{\n"
"	const int linearSearchSteps = 16;\n"
"\n"
"	// current height from initial texel depth\n"
"	float height = 0.0;\n"
"\n"
"	float startDepth = SampleDepth(normalMap, dp);\n"
"\n"
"	// size of search window\n"
"	float size = startDepth / float(linearSearchSteps);\n"
"\n"
"	// find a collision or escape\n"
"	for(int i = 0; i < linearSearchSteps - 1; ++i)\n"
"	{\n"
"		height += size;\n"
"\n"
"		float t = SampleDepth(normalMap, dp + ds * height);\n"
"\n"
"		if (startDepth > t + height)\n"
"			return 0.0;\n"
"	}\n"
"\n"
"	return 1.0;\n"
"}\n"
"#endif\n"
"\n"
"vec3 CalcDiffuse(vec3 diffuseAlbedo, float NH, float EH, float roughness)\n"
"{\n"
"#if defined(USE_BURLEY)\n"
"	// modified from https://disney-animation.s3.amazonaws.com/library/s2012_pbs_disney_brdf_notes_v2.pdf\n"
"	float fd90 = -0.5 + EH * EH * roughness;\n"
"	float burley = 1.0 + fd90 * 0.04 / NH;\n"
"	burley *= burley;\n"
"	return diffuseAlbedo * burley;\n"
"#else\n"
"	return diffuseAlbedo;\n"
"#endif\n"
"}\n"
"\n"
"vec3 EnvironmentBRDF(float roughness, float NE, vec3 specular)\n"
"{\n"
"	// from http://community.arm.com/servlet/JiveServlet/download/96891546-19496/siggraph2015-mmg-renaldas-slides.pdf\n"
"	float v = 1.0 - max(roughness, NE);\n"
"	v *= v * v;\n"
"	return vec3(v) + specular;\n"
"}\n"
"\n"
"vec3 CalcSpecular(vec3 specular, float NH, float EH, float roughness)\n"
"{\n"
"	// from http://community.arm.com/servlet/JiveServlet/download/96891546-19496/siggraph2015-mmg-renaldas-slides.pdf\n"
"	float rr = roughness*roughness;\n"
"	float rrrr = rr*rr;\n"
"	float d = (NH * NH) * (rrrr - 1.0) + 1.0;\n"
"	float v = (EH * EH) * (roughness + 0.5) + EPSILON;\n"
"	return specular * (rrrr / (4.0 * d * d * v));\n"
"}\n"
"\n"
"\n"
"float CalcLightAttenuation(float point, float normDist)\n"
"{\n"
"	// zero light at 1.0, approximating q3 style\n"
"	// also don't attenuate directional light\n"
"	float attenuation = (0.5 * normDist - 1.5) * point + 1.0;\n"
"\n"
"	// clamp attenuation\n"
"	#if defined(NO_LIGHT_CLAMP)\n"
"	attenuation = max(attenuation, 0.0);\n"
"	#else\n"
"	attenuation = clamp(attenuation, 0.0, 1.0);\n"
"	#endif\n"
"\n"
"	return attenuation;\n"
"}\n"
"\n"
"#if defined(USE_BOX_CUBEMAP_PARALLAX)\n"
"vec4 hitCube(vec3 ray, vec3 pos, vec3 invSize, float lod, samplerCube tex)\n"
"{\n"
"	// find any hits on cubemap faces facing the camera\n"
"	vec3 scale = (sign(ray) - pos) / ray;\n"
"\n"
"	// find the nearest hit\n"
"	float minScale = min(min(scale.x, scale.y), scale.z);\n"
"\n"
"	// if the nearest hit is behind the camera, ignore\n"
"	// should not be necessary as long as pos is inside the cube\n"
"	//if (minScale < 0.0)\n"
"		//return vec4(0.0);\n"
"\n"
"	// calculate the hit position, that's our texture coordinates\n"
"	vec3 tc = pos + ray * minScale;\n"
"\n"
"	// if the texture coordinates are outside the cube, ignore\n"
"	// necessary since we're not fading out outside the cube\n"
"	if (any(greaterThan(abs(tc), vec3(1.00001))))\n"
"		return vec4(0.0);\n"
"\n"
"	// fade out when approaching the cubemap edges\n"
"	//vec3 fade3 = abs(pos);\n"
"	//float fade = max(max(fade3.x, fade3.y), fade3.z);\n"
"	//fade = clamp(1.0 - fade, 0.0, 1.0);\n"
"\n"
"	//return vec4(textureCubeLod(tex, tc, lod).rgb * fade, fade);\n"
"	return vec4(textureCubeLod(tex, tc, lod).rgb, 1.0);\n"
"}\n"
"#endif\n"
"\n"
"void main()\n"
"{\n"
"	vec3 viewDir, lightColor, ambientColor, reflectance;\n"
"	vec3 L, N, E, H;\n"
"	float NL, NH, NE, EH, attenuation;\n"
"\n"
"#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"	mat3 tangentToWorld = mat3(v_Tangent.xyz, v_Bitangent.xyz, v_Normal.xyz);\n"
"	viewDir = vec3(v_Normal.w, v_Tangent.w, v_Bitangent.w);\n"
"	E = normalize(viewDir);\n"
"#endif\n"
"\n"
"	lightColor = v_Color.rgb;\n"
"\n"
"#if defined(USE_LIGHTMAP)\n"
"	vec4 lightmapColor = texture2D(u_LightMap, v_TexCoords.zw);\n"
"  #if defined(RGBM_LIGHTMAP)\n"
"	lightmapColor.rgb *= lightmapColor.a;\n"
"  #endif\n"
"  #if defined(USE_PBR) && !defined(USE_FAST_LIGHT)\n"
"	lightmapColor.rgb *= lightmapColor.rgb;\n"
"  #endif\n"
"	lightColor *= lightmapColor.rgb;\n"
"#endif\n"
"\n"
"	vec2 texCoords = v_TexCoords.xy;\n"
"\n"
"#if defined(USE_PARALLAXMAP)\n"
"	vec3 offsetDir = E * tangentToWorld;\n"
"\n"
"	offsetDir.xy *= -u_NormalScale.a / offsetDir.z;\n"
"\n"
"	texCoords += offsetDir.xy * RayIntersectDisplaceMap(texCoords, offsetDir.xy, u_NormalMap);\n"
"#endif\n"
"\n"
"	vec4 diffuse = texture2D(u_DiffuseMap, texCoords);\n"
"\n"
"	float alpha = diffuse.a * v_Color.a;\n"
"	if (u_AlphaTest == 1)\n"
"	{\n"
"		if (alpha == 0.0)\n"
"			discard;\n"
"	}\n"
"	else if (u_AlphaTest == 2)\n"
"	{\n"
"		if (alpha >= 0.5)\n"
"			discard;\n"
"	}\n"
"	else if (u_AlphaTest == 3)\n"
"	{\n"
"		if (alpha < 0.5)\n"
"			discard;\n"
"	}\n"
"\n"
"#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"	L = v_LightDir.xyz;\n"
"  #if defined(USE_DELUXEMAP)\n"
"	L += (texture2D(u_DeluxeMap, v_TexCoords.zw).xyz - vec3(0.5)) * u_EnableTextures.y;\n"
"  #endif\n"
"	float sqrLightDist = dot(L, L);\n"
"	L /= sqrt(sqrLightDist);\n"
"\n"
"  #if defined(USE_LIGHT_VECTOR)\n"
"	attenuation  = CalcLightAttenuation(float(v_LightDir.w > 0.0), v_LightDir.w / sqrLightDist);\n"
"  #else\n"
"	attenuation  = 1.0;\n"
"  #endif\n"
"\n"
"  #if defined(USE_NORMALMAP)\n"
"    #if defined(SWIZZLE_NORMALMAP)\n"
"	N.xy = texture2D(u_NormalMap, texCoords).ag - vec2(0.5);\n"
"    #else\n"
"	N.xy = texture2D(u_NormalMap, texCoords).rg - vec2(0.5);\n"
"    #endif\n"
"	N.xy *= u_NormalScale.xy;\n"
"	N.z = sqrt(clamp((0.25 - N.x * N.x) - N.y * N.y, 0.0, 1.0));\n"
"	N = tangentToWorld * N;\n"
"  #else\n"
"	N = v_Normal.xyz;\n"
"  #endif\n"
"\n"
"	N = normalize(N);\n"
"\n"
"  #if defined(USE_SHADOWMAP)\n"
"	vec2 shadowTex = gl_FragCoord.xy * r_FBufScale;\n"
"	float shadowValue = texture2D(u_ShadowMap, shadowTex).r;\n"
"\n"
"	// surfaces not facing the light are always shadowed\n"
"	shadowValue *= clamp(dot(N, v_PrimaryLightDir.xyz), 0.0, 1.0);\n"
"\n"
"    #if defined(SHADOWMAP_MODULATE)\n"
"	lightColor *= shadowValue * (1.0 - u_PrimaryLightAmbient.r) + u_PrimaryLightAmbient.r;\n"
"    #endif\n"
"  #endif\n"
"\n"
"  #if defined(USE_PARALLAXMAP) && defined(USE_PARALLAXMAP_SHADOWS)\n"
"	offsetDir = L * tangentToWorld;\n"
"	offsetDir.xy *= u_NormalScale.a / offsetDir.z;\n"
"	lightColor *= LightRay(texCoords, offsetDir.xy, u_NormalMap);\n"
"  #endif\n"
"\n"
"\n"
"  #if !defined(USE_LIGHT_VECTOR)\n"
"	ambientColor = lightColor;\n"
"	float surfNL = clamp(dot(v_Normal.xyz, L), 0.0, 1.0);\n"
"\n"
"	// reserve 25% ambient to avoid black areas on normalmaps\n"
"	lightColor *= 0.75;\n"
"\n"
"	// Scale the incoming light to compensate for the baked-in light angle\n"
"	// attenuation.\n"
"	lightColor /= max(surfNL, 0.25);\n"
"\n"
"	// Recover any unused light as ambient, in case attenuation is over 4x or\n"
"	// light is below the surface\n"
"	ambientColor = max(ambientColor - lightColor * surfNL, vec3(0.0));\n"
"  #else\n"
"	ambientColor = v_ColorAmbient.rgb;\n"
"  #endif\n"
"\n"
"	NL = clamp(dot(N, L), 0.0, 1.0);\n"
"	NE = clamp(dot(N, E), 0.0, 1.0);\n"
"	H = normalize(L + E);\n"
"	EH = clamp(dot(E, H), 0.0, 1.0);\n"
"	NH = clamp(dot(N, H), 0.0, 1.0);\n"
"\n"
"  #if defined(USE_SPECULARMAP)\n"
"	vec4 specular = texture2D(u_SpecularMap, texCoords);\n"
"  #else\n"
"	vec4 specular = vec4(1.0);\n"
"  #endif\n"
"	specular *= u_SpecularScale;\n"
"\n"
"  #if defined(USE_PBR)\n"
"	diffuse.rgb *= diffuse.rgb;\n"
"  #endif\n"
"\n"
"  #if defined(USE_PBR)\n"
"	// diffuse rgb is base color\n"
"	// specular red is gloss\n"
"	// specular green is metallicness\n"
"	float gloss = specular.r;\n"
"	float metal = specular.g;\n"
"	specular.rgb = metal * diffuse.rgb + vec3(0.04 - 0.04 * metal);\n"
"	diffuse.rgb *= 1.0 - metal;\n"
"  #else\n"
"	// diffuse rgb is diffuse\n"
"	// specular rgb is specular reflectance at normal incidence\n"
"	// specular alpha is gloss\n"
"	float gloss = specular.a;\n"
"\n"
"	// adjust diffuse by specular reflectance, to maintain energy conservation\n"
"	diffuse.rgb *= vec3(1.0) - specular.rgb;\n"
"  #endif\n"
"\n"
"  #if defined(GLOSS_IS_GLOSS)\n"
"	float roughness = exp2(-3.0 * gloss);\n"
"  #elif defined(GLOSS_IS_SMOOTHNESS)\n"
"	float roughness = 1.0 - gloss;\n"
"  #elif defined(GLOSS_IS_ROUGHNESS)\n"
"	float roughness = gloss;\n"
"  #elif defined(GLOSS_IS_SHININESS)\n"
"	float roughness = pow(2.0 / (8190.0 * gloss + 2.0), 0.25);\n"
"  #endif\n"
"\n"
"	reflectance  = CalcDiffuse(diffuse.rgb, NH, EH, roughness);\n"
"\n"
"  #if defined(r_deluxeSpecular)\n"
"    #if defined(USE_LIGHT_VECTOR)\n"
"	reflectance += CalcSpecular(specular.rgb, NH, EH, roughness) * r_deluxeSpecular;\n"
"    #else\n"
"	reflectance += CalcSpecular(specular.rgb, NH, EH, pow(roughness, r_deluxeSpecular));\n"
"    #endif\n"
"  #endif\n"
"\n"
"	a_Color.rgb  = lightColor   * reflectance * (attenuation * NL);\n"
"	a_Color.rgb += ambientColor * diffuse.rgb;\n"
"\n"
"  #if defined(USE_CUBEMAP)\n"
"	reflectance = EnvironmentBRDF(roughness, NE, specular.rgb);\n"
"\n"
"	vec3 R = reflect(E, N);\n"
"\n"
"	// parallax corrected cubemap (cheaper trick)\n"
"	// from http://seblagarde.wordpress.com/2012/09/29/image-based-lighting-approaches-and-parallax-corrected-cubemap/\n"
"	vec3 parallax = u_CubeMapInfo.xyz + u_CubeMapInfo.w * viewDir;\n"
"\n"
"  #if defined(USE_BOX_CUBEMAP_PARALLAX)\n"
"	vec3 cubeLightColor = hitCube(R * u_CubeMapInfo.w, parallax, u_CubeMapInfo.www, ROUGHNESS_MIPS * roughness, u_CubeMap).rgb * u_EnableTextures.w;\n"
"  #else\n"
"	vec3 cubeLightColor = textureCubeLod(u_CubeMap, R + parallax, ROUGHNESS_MIPS * roughness).rgb * u_EnableTextures.w;\n"
"  #endif\n"
"\n"
"	// normalize cubemap based on last roughness mip (~diffuse)\n"
"	// multiplying cubemap values by lighting below depends on either this or the cubemap being normalized at generation\n"
"	//vec3 cubeLightDiffuse = max(textureCubeLod(u_CubeMap, N, ROUGHNESS_MIPS).rgb, 0.5 / 255.0);\n"
"	//cubeLightColor /= dot(cubeLightDiffuse, vec3(0.2125, 0.7154, 0.0721));\n"
"\n"
"    #if defined(USE_PBR)\n"
"	cubeLightColor *= cubeLightColor;\n"
"    #endif\n"
"\n"
"	// multiply cubemap values by lighting\n"
"	// not technically correct, but helps make reflections look less unnatural\n"
"	//cubeLightColor *= lightColor * (attenuation * NL) + ambientColor;\n"
"\n"
"	a_Color.rgb += cubeLightColor * reflectance;\n"
"  #endif\n"
"\n"
"  #if defined(USE_PRIMARY_LIGHT) || defined(SHADOWMAP_MODULATE)\n"
"	vec3 L2, H2;\n"
"	float NL2, EH2, NH2;\n"
"\n"
"	L2 = v_PrimaryLightDir.xyz;\n"
"\n"
"	// enable when point lights are supported as primary lights\n"
"	//sqrLightDist = dot(L2, L2);\n"
"	//L2 /= sqrt(sqrLightDist);\n"
"\n"
"	NL2 = clamp(dot(N, L2), 0.0, 1.0);\n"
"	H2 = normalize(L2 + E);\n"
"	EH2 = clamp(dot(E, H2), 0.0, 1.0);\n"
"	NH2 = clamp(dot(N, H2), 0.0, 1.0);\n"
"\n"
"	reflectance  = CalcSpecular(specular.rgb, NH2, EH2, roughness);\n"
"\n"
"	// bit of a hack, with modulated shadowmaps, ignore diffuse\n"
"    #if !defined(SHADOWMAP_MODULATE)\n"
"	reflectance += CalcDiffuse(diffuse.rgb, NH2, EH2, roughness);\n"
"    #endif\n"
"\n"
"	lightColor = u_PrimaryLightColor;\n"
"\n"
"    #if defined(USE_SHADOWMAP)\n"
"	lightColor *= shadowValue;\n"
"    #endif\n"
"\n"
"	// enable when point lights are supported as primary lights\n"
"	//lightColor *= CalcLightAttenuation(float(u_PrimaryLightDir.w > 0.0), u_PrimaryLightDir.w / sqrLightDist);\n"
"\n"
"  #if defined(USE_PARALLAXMAP) && defined(USE_PARALLAXMAP_SHADOWS)\n"
"	offsetDir = L2 * tangentToWorld;\n"
"	offsetDir.xy *= u_NormalScale.a / offsetDir.z;\n"
"	lightColor *= LightRay(texCoords, offsetDir.xy, u_NormalMap);\n"
"  #endif\n"
"\n"
"	a_Color.rgb += lightColor * reflectance * NL2;\n"
"  #endif\n"
"\n"
"  #if defined(USE_PBR)\n"
"	a_Color.rgb = sqrt(a_Color.rgb);\n"
"  #endif\n"
"\n"
"#else\n"
"\n"
"	a_Color.rgb = diffuse.rgb * lightColor;\n"
"\n"
"#endif\n"
"\n"
"	a_Color.a = alpha;\n"
"}\n"
;

const char *fallbackShader_tile_vp =
"in vec3 a_Position;\n"
"in vec2 a_TexCoords;\n"
"in vec4 a_Color;\n"
"in vec3 a_WorldPos;\n"
"\n"
"out vec2 v_TexCoords;\n"
"out vec3 v_FragPos;\n"
"out vec4 v_Color;\n"
"out vec3 v_WorldPos;\n"
"\n"
"uniform mat4 u_ModelViewProjection;\n"
"uniform vec4 u_BaseColor;\n"
"uniform vec4 u_VertColor;\n"
"\n"
"uniform mat4 u_ModelMatrix;\n"
"\n"
"#if defined(USE_RGBAGEN)\n"
"uniform int u_ColorGen;\n"
"uniform int u_AlphaGen;\n"
"uniform vec3 u_DirectedLight;\n"
"#endif\n"
"\n"
"#if defined(USE_TCGEN)\n"
"uniform vec4 u_DiffuseTexMatrix;\n"
"uniform vec4 u_DiffuseTexOffTurb;\n"
"#endif\n"
"\n"
"#if defined(USE_TCGEN)\n"
"uniform int u_TCGen0;\n"
"uniform vec3 u_TCGen0Vector0;\n"
"uniform vec3 u_TCGen0Vector1;\n"
"uniform vec3 u_WorldPos;\n"
"#endif\n"
"\n"
"#if defined(USE_RGBAGEN)\n"
"vec4 CalcColor(vec3 position, vec3 normal)\n"
"{\n"
"	vec4 color = u_VertColor * a_Color + u_BaseColor;\n"
"\n"
"	if (u_ColorGen == CGEN_LIGHTING_DIFFUSE)\n"
"	{\n"
"		float incoming = clamp(dot(normal, u_ModelLightDir), 0.0, 1.0);\n"
"\n"
"//		color.rgb = clamp(u_DirectedLight * incoming + u_AmbientLight, 0.0, 1.0);\n"
"	}\n"
"\n"
"	vec3 viewer = u_LocalViewOrigin - position;\n"
"\n"
"	if (u_AlphaGen == AGEN_LIGHTING_SPECULAR)\n"
"	{\n"
"		vec3 lightDir = normalize(vec3(-960.0, 1980.0, 96.0) - position);\n"
"		vec3 reflected = -reflect(lightDir, normal);\n"
"\n"
"		color.a = clamp(dot(reflected, normalize(viewer)), 0.0, 1.0);\n"
"		color.a *= color.a;\n"
"		color.a *= color.a;\n"
"	}\n"
"	else if (u_AlphaGen == AGEN_PORTAL)\n"
"	{\n"
"		color.a = clamp(length(viewer) / u_PortalRange, 0.0, 1.0);\n"
"	}\n"
"\n"
"	return color;\n"
"}\n"
"#endif\n"
"\n"
"#if defined(USE_TCMOD)\n"
"vec2 ModTexCoords( vec2 st, vec3 position, vec4 texMatrix, vec4 offTurb )\n"
"{\n"
"	float amplitude = offTurb.z;\n"
"	float phase = offTurb.w * 2.0 * M_PI;\n"
"	vec2 st2;\n"
"\n"
"	st2.x = st.x * texMatrix.x + ( st.y * texMatrix.z + offTurb.x );\n"
"	st2.y = st.x * texMatrix.y + ( st.y * texMatrix.w + offTurb.y );\n"
"\n"
"	vec2 offsetPos = vec2( position.x + position.z, position.y );\n"
"\n"
"	vec2 texOffset = sin( offsetPos * ( 2.0 * M_PI / 1024.0 ) + vec2( phase ) );\n"
"\n"
"	return st2 + texOffset * amplitude;\n"
"}\n"
"#endif\n"
"\n"
"float CalcLightAttenuation( float point, float normDist )\n"
"{\n"
"	// zero light at 1.0, approximating q3 style\n"
"	// also don't attenuate directional light\n"
"	float attenuation = ( 0.5 * normDist - 1.5 ) * point + 1.0;\n"
"\n"
"	// clamp attenuation\n"
"#if defined(NO_LIGHT_CLAMP)\n"
"	attenuation = max( attenuation, 0.0 );\n"
"#else\n"
"	attenuation = clamp( attenuation, 0.0, 1.0 );\n"
"#endif\n"
"\n"
"	return attenuation;\n"
"}\n"
"\n"
"#if defined(USE_TCGEN)\n"
"vec2 GenTexCoords( int TCGen, vec3 position, vec3 normal, vec3 TCGenVector0, vec3 TCGenVector1 )\n"
"{\n"
"	vec2 tex = a_TexCoords;\n"
"\n"
"	if ( TCGen == TCGEN_LIGHTMAP ) {\n"
"		tex = a_TexCoords.st;\n"
"	}\n"
"	else if ( TCGen == TCGEN_ENVIRONMENT_MAPPED ) {\n"
"		vec3 viewer = normalize( u_WorldPos - position );\n"
"		vec2 ref = reflect( viewer, normal ).yz;\n"
"		tex.s = ref.x * -0.5 + 0.5;\n"
"		tex.t = ref.y *  0.5 + 0.5;\n"
"	}\n"
"	else if ( TCGen == TCGEN_VECTOR ) {\n"
"		tex = vec2( dot( position, TCGenVector0 ), dot( position, TCGenVector1 ) );\n"
"	}\n"
"\n"
"	return tex;\n"
"}\n"
"#endif\n"
"\n"
"void main()\n"
"{\n"
"\n"
"#if defined(USE_TCGEN)\n"
"	vec2 texCoords = GenTexCoords( u_TCGen0, a_Position, vec3( 0.0 ), u_TCGen0Vector0, u_TCGen0Vector1 );\n"
"#else\n"
"	vec2 texCoords = a_TexCoords;\n"
"#endif\n"
"\n"
"#if defined(USE_TCMOD)\n"
"	v_TexCoords = ModTexCoords( texCoords, a_Position, u_DiffuseTexMatrix, u_DiffuseTexOffTurb );\n"
"#else\n"
"	v_TexCoords = texCoords;\n"
"#endif\n"
"    v_Color = a_Color;\n"
"	v_WorldPos = a_WorldPos;\n"
"\n"
"	v_FragPos = vec4( u_ModelViewProjection * vec4( a_Position, 1.0 ) ).xyz;\n"
"\n"
"    gl_Position = u_ModelViewProjection * vec4( a_Position, 1.0 );\n"
"}\n"
;

const char *fallbackShader_down4x_vp =
"in vec3 a_Position;\n"
"in vec4 a_LightCoords;\n"
"\n"
"uniform mat4 u_ModelViewProjection;\n"
"\n"
"out vec2 v_TexCoords;\n"
"\n"
"void main() {\n"
"	gl_Position = u_ModelViewProjection * vec4(a_Position, 1.0);\n"
"	v_TexCoords = a_LightCoords.st;\n"
"}\n"
;

const char *fallbackShader_tonemap_vp =
"in vec3 a_Position;\n"
"in vec4 a_LightCoords;\n"
"\n"
"uniform mat4 u_ModelViewProjection;\n"
"uniform vec3 u_ToneMinAvgMaxLinear;\n"
"\n"
"out vec2 v_TexCoords;\n"
"out float v_InvWhite;\n"
"\n"
"float FilmicTonemap(float x)\n"
"{\n"
"	const float SS  = 0.22; // Shoulder Strength\n"
"	const float LS  = 0.30; // Linear Strength\n"
"	const float LA  = 0.10; // Linear Angle\n"
"	const float TS  = 0.20; // Toe Strength\n"
"	const float TAN = 0.01; // Toe Angle Numerator\n"
"	const float TAD = 0.30; // Toe Angle Denominator\n"
"\n"
"	return ((x*(SS*x+LA*LS)+TS*TAN)/(x*(SS*x+LS)+TS*TAD)) - TAN/TAD;\n"
"}\n"
"\n"
"void main() {\n"
"	gl_Position = u_ModelViewProjection * vec4(a_Position, 1.0);\n"
"	v_TexCoords = a_LightCoords.st;\n"
"	v_InvWhite = 1.0 / FilmicTonemap(u_ToneMinAvgMaxLinear.z - u_ToneMinAvgMaxLinear.x);\n"
"}\n"
;

const char *fallbackShader_ssao_vp =
"in vec4 a_Position;\n"
"in vec4 a_LightCoords;\n"
"\n"
"out vec2 v_ScreenTex;\n"
"\n"
"void main() {\n"
"	gl_Position = a_Position;\n"
"	v_ScreenTex = a_TexCoords.xy;\n"
"	//vec2 screenCoords = gl_Position.xy / gl_Position.w;\n"
"	//var_ScreenTex = screenCoords * 0.5 + 0.5;\n"
"}\n"
;

const char *fallbackShader_down4x_fp =
"#if !defined(GLSL_LEGACY)\n"
"out vec4 a_Color;\n"
"#endif\n"
"\n"
"uniform sampler2D u_TextureMap;\n"
"\n"
"uniform vec2 u_InvTexRes;\n"
"in vec2 v_TexCoords;\n"
"\n"
"void main()\n"
"{\n"
"	vec4 color;\n"
"	vec2 tc;\n"
"\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(-1.5, -1.5);  color  = texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(-0.5, -1.5);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( 0.5, -1.5);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( 1.5, -1.5);  color += texture2D(u_TextureMap, tc);\n"
"\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(-1.5, -0.5); color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(-0.5, -0.5); color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( 0.5, -0.5); color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( 1.5, -0.5); color += texture2D(u_TextureMap, tc);\n"
"\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(-1.5,  0.5); color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(-0.5,  0.5); color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( 0.5,  0.5); color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( 1.5,  0.5); color += texture2D(u_TextureMap, tc);\n"
"\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(-1.5,  1.5);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(-0.5,  1.5);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( 0.5,  1.5);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( 1.5,  1.5);  color += texture2D(u_TextureMap, tc);\n"
"\n"
"	color *= 0.0625;\n"
"\n"
"	a_Color = color;\n"
"}\n"
;

const char *fallbackShader_texturecolor_vp =
"in vec3 a_Position;\n"
"in vec4 a_LightCoords;\n"
"\n"
"uniform mat4 u_ModelViewProjection;\n"
"\n"
"out vec2 v_TexCoords;\n"
"\n"
"\n"
"void main() {\n"
"	gl_Position = u_ModelViewProjection * vec4( a_Position, 1.0 );\n"
"	v_TexCoords = a_LightCoords.st;\n"
"}\n"
;

const char *fallbackShader_generic_vp =
"in vec3 a_Position;\n"
"in vec2 a_TexCoords;\n"
"in vec4 a_Color;\n"
"\n"
"out vec2 v_TexCoords;\n"
"out vec3 v_FragPos;\n"
"out vec4 v_Color;\n"
"\n"
"uniform mat4 u_ModelViewProjection;\n"
"uniform vec4 u_BaseColor;\n"
"uniform vec4 u_VertColor;\n"
"\n"
"uniform mat4 u_ModelMatrix;\n"
"\n"
"#if defined(USE_RGBAGEN)\n"
"uniform int u_ColorGen;\n"
"uniform int u_AlphaGen;\n"
"uniform vec3 u_DirectedLight;\n"
"#endif\n"
"\n"
"#if defined(USE_TCGEN)\n"
"uniform vec4 u_DiffuseTexMatrix;\n"
"uniform vec4 u_DiffuseTexOffTurb;\n"
"#endif\n"
"\n"
"#if defined(USE_TCGEN)\n"
"uniform int u_TCGen0;\n"
"uniform vec3 u_TCGen0Vector0;\n"
"uniform vec3 u_TCGen0Vector1;\n"
"uniform vec3 u_WorldPos;\n"
"#endif\n"
"\n"
"#if defined(USE_RGBAGEN)\n"
"vec4 CalcColor(vec3 position, vec3 normal)\n"
"{\n"
"	vec4 color = u_VertColor * a_Color + u_BaseColor;\n"
"\n"
"	if (u_ColorGen == CGEN_LIGHTING_DIFFUSE)\n"
"	{\n"
"		float incoming = clamp(dot(normal, u_ModelLightDir), 0.0, 1.0);\n"
"\n"
"		color.rgb = clamp(u_DirectedLight * incoming + u_AmbientLight, 0.0, 1.0);\n"
"	}\n"
"\n"
"	vec3 viewer = u_LocalViewOrigin - position;\n"
"\n"
"	if ( u_AlphaGen == AGEN_LIGHTING_SPECULAR ) {\n"
"		vec3 lightDir = normalize(vec3(-960.0, 1980.0, 96.0) - position);\n"
"		vec3 reflected = -reflect(lightDir, normal);\n"
"\n"
"		color.a = clamp(dot(reflected, normalize(viewer)), 0.0, 1.0);\n"
"		color.a *= color.a;\n"
"		color.a *= color.a;\n"
"	}\n"
"\n"
"	return color;\n"
"}\n"
"#endif\n"
"\n"
"#if defined(USE_TCMOD)\n"
"vec2 ModTexCoords( vec2 st, vec3 position, vec4 texMatrix, vec4 offTurb )\n"
"{\n"
"	float amplitude = offTurb.z;\n"
"	float phase = offTurb.w * 2.0 * M_PI;\n"
"	vec2 st2;\n"
"\n"
"	st2.x = st.x * texMatrix.x + ( st.y * texMatrix.z + offTurb.x );\n"
"	st2.y = st.x * texMatrix.y + ( st.y * texMatrix.w + offTurb.y );\n"
"\n"
"	vec2 offsetPos = vec2( position.x + position.z, position.y );\n"
"\n"
"	vec2 texOffset = sin( offsetPos * ( 2.0 * M_PI / 1024.0 ) + vec2( phase ) );\n"
"\n"
"	return st2 + texOffset * amplitude;\n"
"}\n"
"#endif\n"
"\n"
"float CalcLightAttenuation( float point, float normDist )\n"
"{\n"
"	// zero light at 1.0, approximating q3 style\n"
"	// also don't attenuate directional light\n"
"	float attenuation = ( 0.5 * normDist - 1.5 ) * point + 1.0;\n"
"\n"
"	// clamp attenuation\n"
"#if defined(NO_LIGHT_CLAMP)\n"
"	attenuation = max( attenuation, 0.0 );\n"
"#else\n"
"	attenuation = clamp( attenuation, 0.0, 1.0 );\n"
"#endif\n"
"\n"
"	return attenuation;\n"
"}\n"
"\n"
"#if defined(USE_TCGEN)\n"
"vec2 GenTexCoords( int TCGen, vec3 position, vec3 normal, vec3 TCGenVector0, vec3 TCGenVector1 )\n"
"{\n"
"	vec2 tex = a_TexCoords;\n"
"\n"
"	if ( TCGen == TCGEN_LIGHTMAP ) {\n"
"		tex = a_TexCoords.st;\n"
"	}\n"
"	else if ( TCGen == TCGEN_ENVIRONMENT_MAPPED ) {\n"
"		vec3 viewer = normalize( vec3( 0.0 ) - position );\n"
"		vec2 ref = reflect( viewer, normal ).yz;\n"
"		tex.s = ref.x * -0.5 + 0.5;\n"
"		tex.t = ref.y *  0.5 + 0.5;\n"
"	}\n"
"	else if ( TCGen == TCGEN_VECTOR ) {\n"
"		tex = vec2( dot( position, TCGenVector0 ), dot( position, TCGenVector1 ) );\n"
"	}\n"
"\n"
"	return tex;\n"
"}\n"
"#endif\n"
"\n"
"void main()\n"
"{\n"
"	v_Color = u_VertColor * a_Color + u_BaseColor;\n"
"\n"
"#if defined(USE_TCGEN)\n"
"	vec2 texCoords = GenTexCoords( u_TCGen0, a_Position, vec3( 0.0 ), u_TCGen0Vector0, u_TCGen0Vector1 );\n"
"#else\n"
"	vec2 texCoords = a_TexCoords;\n"
"#endif\n"
"\n"
"#if defined(USE_TCMOD)\n"
"	v_TexCoords = ModTexCoords( texCoords, a_Position, u_DiffuseTexMatrix, u_DiffuseTexOffTurb );\n"
"#else\n"
"	v_TexCoords = texCoords;\n"
"#endif\n"
"\n"
"	v_FragPos = vec4( u_ModelViewProjection * vec4( a_Position, 1.0 ) ).xyz;\n"
"\n"
"    gl_Position = u_ModelViewProjection * vec4( a_Position, 1.0 );\n"
"}\n"
;

const char *fallbackShader_imgui_vp =
"in vec3 a_Position;\n"
"in vec2 a_TexCoords;\n"
"in vec4 a_Color;\n"
"\n"
"uniform mat4 u_ModelViewProjection;\n"
"\n"
"out vec2 v_TexCoords;\n"
"out vec4 v_Color;\n"
"\n"
"void main()\n"
"{\n"
"	v_TexCoords = a_TexCoords;\n"
"    v_Color = a_Color;\n"
"    gl_Position = u_ModelViewProjection * vec4( a_Position.xy, 0, 1 );\n"
"}\n"
;

const char *fallbackShader_tile_fp =
"#if !defined(GLSL_LEGACY)\n"
"layout( location = 0 ) out vec4 a_Color;\n"
"#if defined(USE_HDR) && defined(USE_BLOOM)\n"
"layout( location = 1 ) out vec4 a_BrightColor;\n"
"#endif\n"
"#endif\n"
"\n"
"#if defined(USE_FXAA)\n"
"#if !defined(FXAA_PRESET)\n"
"    #define FXAA_PRESET 5\n"
"#endif\n"
"#if FXAA_PRESET == 3\n"
"    #define FXAA_EDGE_THRESHOLD      ( 1.0 / 8.0 )\n"
"    #define FXAA_EDGE_THRESHOLD_MIN  ( 1.0 / 16.0 )\n"
"    #define FXAA_SEARCH_STEPS        16\n"
"    #define FXAA_SEARCH_THRESHOLD    ( 1.0 / 4.0 )\n"
"    #define FXAA_SUBPIX_CAP          ( 3.0 / 4.0 )\n"
"    #define FXAA_SUBPIX_TRIM         ( 1.0 / 4.0 )\n"
"#elif FXAA_PRESET == 4\n"
"    #define FXAA_EDGE_THRESHOLD      ( 1.0 / 8.0 )\n"
"    #define FXAA_EDGE_THRESHOLD_MIN  ( 1.0 / 24.0 )\n"
"    #define FXAA_SEARCH_STEPS        24\n"
"    #define FXAA_SEARCH_THRESHOLD    ( 1.0 / 4.0 )\n"
"    #define FXAA_SUBPIX_CAP          ( 3.0 / 4.0 )\n"
"    #define FXAA_SUBPIX_TRIM         ( 1.0 / 4.0 )\n"
"#elif FXAA_PRESET == 5\n"
"    #define FXAA_EDGE_THRESHOLD      ( 1.0 / 8.0 )\n"
"    #define FXAA_EDGE_THRESHOLD_MIN  ( 1.0 / 24.0 )\n"
"    #define FXAA_SEARCH_STEPS        32\n"
"    #define FXAA_SEARCH_THRESHOLD    ( 1.0 / 4.0 )\n"
"    #define FXAA_SUBPIX_CAP          ( 3.0 / 4.0 )\n"
"    #define FXAA_SUBPIX_TRIM         ( 1.0 / 4.0 )\n"
"#endif\n"
"\n"
"#define FXAA_SUBPIX_TRIM_SCALE ( 1.0 / ( 1.0 - FXAA_SUBPIX_TRIM ) )\n"
"#endif\n"
"\n"
"in vec2 v_TexCoords;\n"
"in vec3 v_FragPos;\n"
"in vec4 v_Color;\n"
"in vec3 v_WorldPos;\n"
"\n"
"uniform sampler2D u_DiffuseMap;\n"
"uniform float u_GammaAmount;\n"
"\n"
"#if defined(USE_LIGHT)\n"
"uniform vec3 u_AmbientColor;\n"
"uniform float u_AmbientIntensity;\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"uniform vec4 u_SpecularScale;\n"
"uniform vec4 u_NormalScale;\n"
"uniform int u_NumLights;\n"
"\n"
"struct Light {\n"
"    vec4 color;\n"
"    uvec2 origin;\n"
"    float brightness;\n"
"    float range;\n"
"    float linear;\n"
"    float quadratic;\n"
"    float constant;\n"
"    int type;\n"
"};\n"
"layout( std140 ) uniform u_LightBuffer {\n"
"    Light u_LightData[MAX_MAP_LIGHTS];\n"
"};\n"
"#endif\n"
"#endif\n"
"\n"
"#if defined(USE_EXPOSURE_TONE_MAPPING)\n"
"uniform float u_CameraExposure;\n"
"#endif\n"
"\n"
"#if defined(USE_NORMALMAP)\n"
"uniform sampler2D u_NormalMap;\n"
"#endif\n"
"\n"
"#if defined(USE_SPECULARMAP)\n"
"uniform sampler2D u_SpecularMap;\n"
"#endif\n"
"\n"
"#if defined(USE_SHADOWMAP)\n"
"uniform sampler2D u_ShadowMap;\n"
"#endif\n"
"\n"
"#if defined(USE_FXAA)\n"
"uniform vec2 u_ScreenSize;\n"
"#endif\n"
"\n"
"uniform int u_AlphaTest;\n"
"\n"
"#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"//\n"
"// CalcPointLight: don't modify, straight from Valden\n"
"//\n"
"vec3 CalcPointLight( Light light ) {\n"
"    vec3 diffuse = a_Color.rgb;\n"
"    float dist = distance( v_WorldPos, vec3( light.origin, v_WorldPos.z ) );\n"
"    float diff = 0.0;\n"
"    float range = light.range;\n"
"    if ( dist <= light.range ) {\n"
"        diff = 1.0 - abs( dist / range );\n"
"    }\n"
"    diff += light.brightness;\n"
"    diffuse = min( diff * ( diffuse + vec3( light.color ) ), diffuse );\n"
"\n"
"    vec3 lightDir = vec3( 0.0 );\n"
"    vec3 viewDir = normalize( v_WorldPos - vec3( light.origin, 0.0 ) );\n"
"    vec3 halfwayDir = normalize( lightDir + viewDir );\n"
"\n"
"    vec3 reflectDir = reflect( -lightDir, v_WorldPos );\n"
"    float spec = pow( max( dot( v_WorldPos, reflectDir ), 0.0 ), 1.0 );\n"
"\n"
"#if defined(USE_SPECULARMAP)\n"
"    vec3 specular = spec * texture( u_SpecularMap, v_TexCoords ).rgb;\n"
"#else\n"
"    vec3 specular = vec3( 0.0 );\n"
"#endif\n"
"\n"
"    range = light.range + light.brightness;\n"
"    float attenuation = ( light.constant + light.linear * range\n"
"        + light.quadratic * ( range * range ) );\n"
"\n"
"    diffuse *= attenuation;\n"
"    specular *= attenuation;\n"
"\n"
"    return diffuse + specular;\n"
"}\n"
"#endif\n"
"\n"
"float CalcLightAttenuation(float point, float normDist)\n"
"{\n"
"	// zero light at 1.0, approximating q3 style\n"
"	// also don't attenuate directional light\n"
"	float attenuation = (0.5 * normDist - 1.5) * point + 1.0;\n"
"\n"
"	// clamp attenuation\n"
"	#if defined(NO_LIGHT_CLAMP)\n"
"	attenuation = max(attenuation, 0.0);\n"
"	#else\n"
"	attenuation = clamp(attenuation, 0.0, 1.0);\n"
"	#endif\n"
"\n"
"	return attenuation;\n"
"}\n"
"\n"
"vec3 CalcDiffuse(vec3 diffuseAlbedo, float NH, float EH, float roughness)\n"
"{\n"
"#if defined(USE_BURLEY)\n"
"	// modified from https://disney-animation.s3.amazonaws.com/library/s2012_pbs_disney_brdf_notes_v2.pdf\n"
"	float fd90 = -0.5 + EH * EH * roughness;\n"
"	float burley = 1.0 + fd90 * 0.04 / NH;\n"
"	burley *= burley;\n"
"	return diffuseAlbedo * burley;\n"
"#else\n"
"	return diffuseAlbedo;\n"
"#endif\n"
"}\n"
"\n"
"void CalcNormal() {\n"
"#if defined(USE_NORMALMAP)\n"
"    vec3 normal = texture( u_NormalMap, v_TexCoords ).rgb;\n"
"    normal = normalize( normal * 2.0 - 1.0 );\n"
"    a_Color.rgb *= normal * 0.5 + 0.5;\n"
"#endif\n"
"}\n"
"\n"
"void ApplyLighting() {\n"
"    a_Color = texture( u_DiffuseMap, v_TexCoords );\n"
"    CalcNormal();\n"
"#if defined(USE_SPECULARMAP)\n"
"    if ( u_NumLights == 0 ) {\n"
"        a_Color.rgb += texture( u_SpecularMap, v_TexCoords ).rgb;\n"
"    }\n"
"#endif\n"
"#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"    for ( int i = 0; i < u_NumLights; i++ ) {\n"
"        switch ( lights[i].type ) {\n"
"        case POINT_LIGHT:\n"
"            a_Color.rgb += CalcPointLight( u_LightData[i] );\n"
"            break;\n"
"        case DIRECTION_LIGHT:\n"
"            break;\n"
"        };\n"
"    }\n"
"#endif\n"
"    a_Color.rgb += texture( u_DiffuseMap, v_TexCoords ).rgb;\n"
"}\n"
"\n"
"#if defined(USE_FXAA)\n"
"float FxaaLuma( vec3 rgb ) {\n"
"    return rgb.y * ( 0.587 / 0.299 ) + rgb.x;\n"
"}\n"
"\n"
"vec3 FxaaLerp3( vec3 a, vec3 b, float amountOfA ) {\n"
"    return ( vec3( -amountOfA ) * b ) + ( ( a * vec3( amountOfA ) ) + b );\n"
"}\n"
"\n"
"vec4 FxaaTexOffset( sampler2D texture, vec2 texCoords, ivec2 offset, vec2 rcpFrame ) {\n"
"	float x = texCoords.x + float( offset.x ) + rcpFrame.x;\n"
"	float y = texCoords.y + float( offset.y ) + rcpFrame.y;\n"
"	return texture2D( texture, vec2( x, y ) );\n"
"}\n"
"\n"
"// pos is the output of FxaaVertexShader interpolated across screen.\n"
"// xy -> actual texture position {0.0 to 1.0}\n"
"// rcpFrame should be a uniform equal to  {1.0/frameWidth, 1.0/frameHeight}\n"
"vec3 FxaaPixelShader(vec2 pos, sampler2D texture, vec2 rcpFrame)\n"
"{\n"
"    vec3 rgbN = FxaaTexOffset(texture, pos.xy, ivec2( 0,-1), rcpFrame).xyz;\n"
"    vec3 rgbW = FxaaTexOffset(texture, pos.xy, ivec2(-1, 0), rcpFrame).xyz;\n"
"    vec3 rgbM = FxaaTexOffset(texture, pos.xy, ivec2( 0, 0), rcpFrame).xyz;\n"
"    vec3 rgbE = FxaaTexOffset(texture, pos.xy, ivec2( 1, 0), rcpFrame).xyz;\n"
"    vec3 rgbS = FxaaTexOffset(texture, pos.xy, ivec2( 0, 1), rcpFrame).xyz;\n"
"\n"
"    float lumaN = FxaaLuma(rgbN);\n"
"    float lumaW = FxaaLuma(rgbW);\n"
"    float lumaM = FxaaLuma(rgbM);\n"
"    float lumaE = FxaaLuma(rgbE);\n"
"    float lumaS = FxaaLuma(rgbS);\n"
"    float rangeMin = min(lumaM, min(min(lumaN, lumaW), min(lumaS, lumaE)));\n"
"    float rangeMax = max(lumaM, max(max(lumaN, lumaW), max(lumaS, lumaE)));\n"
"\n"
"    float range = rangeMax - rangeMin;\n"
"    if(range < max(FXAA_EDGE_THRESHOLD_MIN, rangeMax * FXAA_EDGE_THRESHOLD)) {\n"
"        return rgbM;\n"
"    }\n"
"\n"
"    vec3 rgbL = rgbN + rgbW + rgbM + rgbE + rgbS;\n"
"\n"
"    float lumaL = (lumaN + lumaW + lumaE + lumaS) * 0.25;\n"
"    float rangeL = abs(lumaL - lumaM);\n"
"    float blendL = max(0.0, (rangeL / range) - FXAA_SUBPIX_TRIM) * FXAA_SUBPIX_TRIM_SCALE;\n"
"    blendL = min(FXAA_SUBPIX_CAP, blendL);\n"
"\n"
"    vec3 rgbNW = FxaaTexOffset(texture, pos.xy, ivec2(-1,-1), rcpFrame).xyz;\n"
"    vec3 rgbNE = FxaaTexOffset(texture, pos.xy, ivec2( 1,-1), rcpFrame).xyz;\n"
"    vec3 rgbSW = FxaaTexOffset(texture, pos.xy, ivec2(-1, 1), rcpFrame).xyz;\n"
"    vec3 rgbSE = FxaaTexOffset(texture, pos.xy, ivec2( 1, 1), rcpFrame).xyz;\n"
"    rgbL += (rgbNW + rgbNE + rgbSW + rgbSE);\n"
"    rgbL *= vec3(1.0/9.0);\n"
"\n"
"    float lumaNW = FxaaLuma(rgbNW);\n"
"    float lumaNE = FxaaLuma(rgbNE);\n"
"    float lumaSW = FxaaLuma(rgbSW);\n"
"    float lumaSE = FxaaLuma(rgbSE);\n"
"\n"
"    float edgeVert =\n"
"        abs((0.25 * lumaNW) + (-0.5 * lumaN) + (0.25 * lumaNE)) +\n"
"        abs((0.50 * lumaW ) + (-1.0 * lumaM) + (0.50 * lumaE )) +\n"
"        abs((0.25 * lumaSW) + (-0.5 * lumaS) + (0.25 * lumaSE));\n"
"    float edgeHorz =\n"
"        abs((0.25 * lumaNW) + (-0.5 * lumaW) + (0.25 * lumaSW)) +\n"
"        abs((0.50 * lumaN ) + (-1.0 * lumaM) + (0.50 * lumaS )) +\n"
"        abs((0.25 * lumaNE) + (-0.5 * lumaE) + (0.25 * lumaSE));\n"
"\n"
"    bool horzSpan = edgeHorz >= edgeVert;\n"
"    float lengthSign = horzSpan ? -rcpFrame.y : -rcpFrame.x;\n"
"\n"
"    if(!horzSpan) {\n"
"        lumaN = lumaW;\n"
"        lumaS = lumaE;\n"
"    }\n"
"\n"
"    float gradientN = abs(lumaN - lumaM);\n"
"    float gradientS = abs(lumaS - lumaM);\n"
"    lumaN = (lumaN + lumaM) * 0.5;\n"
"    lumaS = (lumaS + lumaM) * 0.5;\n"
"\n"
"    if (gradientN < gradientS) {\n"
"        lumaN = lumaS;\n"
"        lumaN = lumaS;\n"
"        gradientN = gradientS;\n"
"        lengthSign *= -1.0;\n"
"    }\n"
"\n"
"    vec2 posN;\n"
"    posN.x = pos.x + (horzSpan ? 0.0 : lengthSign * 0.5);\n"
"    posN.y = pos.y + (horzSpan ? lengthSign * 0.5 : 0.0);\n"
"\n"
"    gradientN *= FXAA_SEARCH_THRESHOLD;\n"
"\n"
"    vec2 posP = posN;\n"
"    vec2 offNP = horzSpan ? vec2(rcpFrame.x, 0.0) : vec2(0.0, rcpFrame.y);\n"
"    float lumaEndN = lumaN;\n"
"    float lumaEndP = lumaN;\n"
"    bool doneN = false;\n"
"    bool doneP = false;\n"
"    posN += offNP * vec2(-1.0, -1.0);\n"
"    posP += offNP * vec2( 1.0,  1.0);\n"
"\n"
"    for(int i = 0; i < FXAA_SEARCH_STEPS; i++) {\n"
"        if(!doneN) {\n"
"            lumaEndN = FxaaLuma(texture2D(texture, posN.xy).xyz);\n"
"        }\n"
"        if(!doneP) {\n"
"            lumaEndP = FxaaLuma(texture2D(texture, posP.xy).xyz);\n"
"        }\n"
"\n"
"        doneN = doneN || (abs(lumaEndN - lumaN) >= gradientN);\n"
"        doneP = doneP || (abs(lumaEndP - lumaN) >= gradientN);\n"
"\n"
"        if(doneN && doneP) {\n"
"            break;\n"
"        }\n"
"        if(!doneN) {\n"
"            posN -= offNP;\n"
"        }\n"
"        if(!doneP) {\n"
"            posP += offNP;\n"
"        }\n"
"    }\n"
"\n"
"    float dstN = horzSpan ? pos.x - posN.x : pos.y - posN.y;\n"
"    float dstP = horzSpan ? posP.x - pos.x : posP.y - pos.y;\n"
"    bool directionN = dstN < dstP;\n"
"    lumaEndN = directionN ? lumaEndN : lumaEndP;\n"
"\n"
"    if( ( ( lumaM - lumaN ) < 0.0 ) == ( ( lumaEndN - lumaN ) < 0.0 ) ) {\n"
"        lengthSign = 0.0;\n"
"    }\n"
"\n"
"\n"
"    float spanLength = ( dstP + dstN );\n"
"    dstN = directionN ? dstN : dstP;\n"
"    float subPixelOffset = ( 0.5 + ( dstN * ( -1.0/spanLength ) ) ) * lengthSign;\n"
"    vec3 rgbF = texture2D( texture, vec2(\n"
"        pos.x + ( horzSpan ? 0.0 : subPixelOffset ),\n"
"        pos.y + ( horzSpan ? subPixelOffset : 0.0 ) ) ).xyz;\n"
"    return FxaaLerp3( rgbL, rgbF, blendL );\n"
"}\n"
"#endif\n"
"\n"
"// -- Sharpening --\n"
"uniform float u_SharpenAmount;\n"
"uniform vec2 u_ScreenSize;\n"
"\n"
"#define sharp_clamp 0.000  //[0.000 to 1.000] Limits maximum amount of sharpening a pixel recieves - Default is 0.035\n"
"\n"
"// -- Advanced sharpening settings --\n"
"\n"
"#define offset_bias 6.0  //[0.0 to 6.0] Offset bias adjusts the radius of the sampling pattern.\n"
"                         //I designed the pattern for offset_bias 1.0, but feel free to experiment.\n"
"\n"
"//#define CoefLuma vec3( 0.2126, 0.7152, 0.0722 )      // BT.709 & sRBG luma coefficient (Monitors and HD Television)\n"
"//#define CoefLuma vec3( 0.299, 0.587, 0.114 )       // BT.601 luma coefficient (SD Television)\n"
"#define CoefLuma vec3( 1.0/3.0, 1.0/3.0, 1.0/3.0 ) // Equal weight coefficient\n"
"\n"
"vec4 sharpenImage( sampler2D tex, vec2 pos )\n"
"{\n"
"	vec4 colorInput = texture2D(tex, pos);\n"
"\n"
"	vec3 ori = colorInput.rgb;\n"
"\n"
"	// -- Combining the strength and luma multipliers --\n"
"	vec3 sharp_strength_luma = (CoefLuma * u_SharpenAmount); //I'll be combining even more multipliers with it later on\n"
"\n"
"	// -- Gaussian filter --\n"
"	//   [ .25, .50, .25]     [ 1 , 2 , 1 ]\n"
"	//   [ .50,   1, .50]  =  [ 2 , 4 , 2 ]\n"
" 	//   [ .25, .50, .25]     [ 1 , 2 , 1 ]\n"
"\n"
"\n"
"    float px = 1.0/u_ScreenSize[0];\n"
"	float py = 1.0/u_ScreenSize[1];\n"
"\n"
"	vec3 blur_ori = texture2D(tex, pos + vec2(px,-py) * 0.5 * offset_bias).rgb; // South East\n"
"	blur_ori += texture2D(tex, pos + vec2(-px,-py) * 0.5 * offset_bias).rgb;  // South West\n"
"	blur_ori += texture2D(tex, pos + vec2(px,py) * 0.5 * offset_bias).rgb; // North East\n"
"	blur_ori += texture2D(tex, pos + vec2(-px,py) * 0.5 * offset_bias).rgb; // North West\n"
"\n"
"	blur_ori *= 0.25;  // ( /= 4) Divide by the number of texture fetches\n"
"\n"
"\n"
"\n"
"	// -- Calculate the sharpening --\n"
"	vec3 sharp = ori - blur_ori;  //Subtracting the blurred image from the original image\n"
"\n"
"	// -- Adjust strength of the sharpening and clamp it--\n"
"	vec4 sharp_strength_luma_clamp = vec4(sharp_strength_luma * (0.5 / sharp_clamp),0.5); //Roll part of the clamp into the dot\n"
"\n"
"	float sharp_luma = clamp((dot(vec4(sharp,1.0), sharp_strength_luma_clamp)), 0.0,1.0 ); //Calculate the luma, adjust the strength, scale up and clamp\n"
"	sharp_luma = (sharp_clamp * 2.0) * sharp_luma - sharp_clamp; //scale down\n"
"\n"
"\n"
"	// -- Combining the values to get the final sharpened pixel	--\n"
"\n"
"	colorInput.rgb = colorInput.rgb + sharp_luma;    // Add the sharpening to the input color.\n"
"	return clamp(colorInput, 0.0,1.0);\n"
"}\n"
"\n"
"void main() {\n"
"    a_Color = sharpenImage( u_DiffuseMap, v_TexCoords );\n"
"\n"
"    applyLighting();\n"
"\n"
"#if defined(USE_BLOOM) && !defined(USE_FAST_LIGHT)\n"
"	const float brightness = dot( a_Color.rgb, vec3( 0.2126, 0.7152, 0.0722 ) );\n"
"	if ( brightness > 1.0 ) {\n"
"		a_BrightColor = vec4( a_Color.rgb, 1.0 );\n"
"	} else {\n"
"		a_BrightColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n"
"	}\n"
"#endif\n"
"#if defined(USE_HDR)\n"
"#if !defined(USE_EXPOSURE_TONE_MAPPING)\n"
"	// reinhard tone mapping\n"
"	a_Color.rgb = a_Color.rgb / ( a_Color.rgb + vec3( 1.0 ) );\n"
"#else\n"
"	// exposure tone mapping\n"
"	a_Color.rgb = vec3( 1.0 ) - exp( -a_Color.rgb * u_CameraExposure );\n"
"#endif\n"
"\n"
"#if defined(USE_BLOOM)\n"
"	// check whether fragment output is higher than threshold, if so output as brightness color\n"
"	float brightness = dot( a_Color.rgb, vec3( 0.2126, 0.7152, 0.0722 ) );\n"
"	if ( brightness > 1.0 ) {\n"
"		a_BrightColor = vec4( a_Color.rgb, 1.0 );\n"
"	} else {\n"
"		a_BrightColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n"
"	}\n"
"#endif\n"
"#endif\n"
"    a_Color.rgb = pow( a_Color.rgb, vec3( 1.0 / u_GammaAmount ) );\n"
"}\n"
;

const char *fallbackShader_tonemap_fp =
"#if !defined(GLSL_LEGACY)\n"
"out vec4 a_Color;\n"
"#endif\n"
"\n"
"uniform sampler2D u_TextureMap;\n"
"uniform sampler2D u_LevelsMap;\n"
"\n"
"uniform vec4 u_Color;\n"
"\n"
"\n"
"uniform vec2 u_AutoExposureMinMax;\n"
"uniform vec3 u_ToneMinAvgMaxLinear;\n"
"\n"
"in vec2 v_TexCoords;\n"
"in float v_InvWhite;\n"
"\n"
"const vec3  LUMINANCE_VECTOR =   vec3(0.2125, 0.7154, 0.0721); //vec3(0.299, 0.587, 0.114);\n"
"\n"
"float FilmicTonemap(float x)\n"
"{\n"
"	const float SS  = 0.22; // Shoulder Strength\n"
"	const float LS  = 0.30; // Linear Strength\n"
"	const float LA  = 0.10; // Linear Angle\n"
"	const float TS  = 0.20; // Toe Strength\n"
"	const float TAN = 0.01; // Toe Angle Numerator\n"
"	const float TAD = 0.30; // Toe Angle Denominator\n"
"\n"
"	return ((x*(SS*x+LA*LS)+TS*TAN)/(x*(SS*x+LS)+TS*TAD)) - TAN/TAD;\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"	vec4 color = texture2D(u_TextureMap, v_TexCoords) * u_Color;\n"
"\n"
"#if defined(USE_PBR)\n"
"	color.rgb *= color.rgb;\n"
"#endif\n"
"\n"
"	vec3 minAvgMax = texture2D(u_LevelsMap, v_TexCoords).rgb;\n"
"	vec3 logMinAvgMaxLum = clamp(minAvgMax * 20.0 - 10.0, -u_AutoExposureMinMax.y, -u_AutoExposureMinMax.x);\n"
"\n"
"	float invAvgLum = u_ToneMinAvgMaxLinear.y * exp2(-logMinAvgMaxLum.y);\n"
"\n"
"	color.rgb = color.rgb * invAvgLum - u_ToneMinAvgMaxLinear.xxx;\n"
"	color.rgb = max(vec3(0.0), color.rgb);\n"
"\n"
"	color.r = FilmicTonemap(color.r);\n"
"	color.g = FilmicTonemap(color.g);\n"
"	color.b = FilmicTonemap(color.b);\n"
"\n"
"	color.rgb = clamp(color.rgb * v_InvWhite, 0.0, 1.0);\n"
"\n"
"#if defined(USE_PBR)\n"
"	color.rgb = sqrt(color.rgb);\n"
"#endif\n"
"\n"
"	// add a bit of dither to reduce banding\n"
"	color.rgb += vec3(1.0/510.0 * mod(gl_FragCoord.x + gl_FragCoord.y, 2.0) - 1.0/1020.0);\n"
"\n"
"	a_Color = color;\n"
"}\n"
;

const char *fallbackShader_calclevels4x_vp =
"in vec3 a_Position;\n"
"in vec4 a_LightCoords;\n"
"\n"
"uniform mat4 u_ModelViewProjection;\n"
"\n"
"out vec2 v_TexCoords;\n"
"\n"
"void main() {\n"
"	gl_Position = u_ModelViewProjection * vec4( a_Position, 1.0 );\n"
"	v_TexCoords = a_LightCoords.st;\n"
"}\n"
;

const char *fallbackShader_depthblur_vp =
"in vec4 a_Position;\n"
"in vec4 a_LightCoords;\n"
"\n"
"uniform vec4 u_ViewInfo; // zfar / znear, zfar, 1/width, 1/height\n"
"\n"
"out vec2 v_ScreenTex;\n"
"\n"
"void main() {\n"
"	gl_Position = a_Position;\n"
"	vec2 wh = vec2( 1.0 ) / u_ViewInfo.zw - vec2( 1.0 );\n"
"	v_ScreenTex = ( floor( a_LightCoords.xy * wh ) + vec2( 0.5 ) ) * u_ViewInfo.zw;\n"
"\n"
"	//vec2 screenCoords = gl_Position.xy / gl_Position.w;\n"
"	//var_ScreenTex = screenCoords * 0.5 + 0.5;\n"
"}\n"
;

const char *fallbackShader_ssao_fp =
"#if !defined(GLSL_LEGACY)\n"
"out vec4 a_Color;\n"
"#endif\n"
"\n"
"uniform sampler2D u_ScreenDepthMap;\n"
"uniform vec4 u_ViewInfo; // zfar / znear, zfar, 1/width, 1/height\n"
"\n"
"in vec2 v_ScreenTex;\n"
"\n"
"#if 0\n"
"vec2 poissonDisc[9] = vec2[9](\n"
"vec2(-0.7055767, 0.196515),    vec2(0.3524343, -0.7791386),\n"
"vec2(0.2391056, 0.9189604),    vec2(-0.07580382, -0.09224417),\n"
"vec2(0.5784913, -0.002528916), vec2(0.192888, 0.4064181),\n"
"vec2(-0.6335801, -0.5247476),  vec2(-0.5579782, 0.7491854),\n"
"vec2(0.7320465, 0.6317794)\n"
");\n"
"#endif\n"
"\n"
"#define NUM_SAMPLES 3\n"
"\n"
"// Input: It uses texture coords as the random number seed.\n"
"// Output: Random number: [0,1), that is between 0.0 and 0.999999... inclusive.\n"
"// Author: Michael Pohoreski\n"
"// Copyright: Copyleft 2012 :-)\n"
"// Source: http://stackoverflow.com/questions/5149544/can-i-generate-a-random-number-inside-a-pixel-shader\n"
"\n"
"float random( const vec2 p )\n"
"{\n"
"  // We need irrationals for pseudo randomness.\n"
"  // Most (all?) known transcendental numbers will (generally) work.\n"
"  const vec2 r = vec2(\n"
"    23.1406926327792690,  // e^pi (Gelfond's constant)\n"
"     2.6651441426902251); // 2^sqrt(2) (Gelfond-Schneider constant)\n"
"  //return fract( cos( mod( 123456789., 1e-7 + 256. * dot(p,r) ) ) );\n"
"  return mod( 123456789., 1e-7 + 256. * dot(p,r) );\n"
"}\n"
"\n"
"mat2 randomRotation( const vec2 p )\n"
"{\n"
"	float r = random(p);\n"
"	float sinr = sin(r);\n"
"	float cosr = cos(r);\n"
"	return mat2(cosr, sinr, -sinr, cosr);\n"
"}\n"
"\n"
"float getLinearDepth(sampler2D depthMap, const vec2 tex, const float zFarDivZNear)\n"
"{\n"
"	float sampleZDivW = texture2D(depthMap, tex).r;\n"
"	return 1.0 / mix(zFarDivZNear, 1.0, sampleZDivW);\n"
"}\n"
"\n"
"float ambientOcclusion(sampler2D depthMap, const vec2 tex, const float zFarDivZNear, const float zFar, const vec2 scale)\n"
"{\n"
"	vec2 poissonDisc[9];\n"
"\n"
"	poissonDisc[0] = vec2(-0.7055767, 0.196515);\n"
"	poissonDisc[1] = vec2(0.3524343, -0.7791386);\n"
"	poissonDisc[2] = vec2(0.2391056, 0.9189604);\n"
"	poissonDisc[3] = vec2(-0.07580382, -0.09224417);\n"
"	poissonDisc[4] = vec2(0.5784913, -0.002528916);\n"
"	poissonDisc[5] = vec2(0.192888, 0.4064181);\n"
"	poissonDisc[6] = vec2(-0.6335801, -0.5247476);\n"
"	poissonDisc[7] = vec2(-0.5579782, 0.7491854);\n"
"	poissonDisc[8] = vec2(0.7320465, 0.6317794);\n"
"\n"
"	float result = 0.0;\n"
"\n"
"	float sampleZ = getLinearDepth(depthMap, tex, zFarDivZNear);\n"
"	float scaleZ = zFarDivZNear * sampleZ;\n"
"\n"
"	vec2 slope = vec2(dFdx(sampleZ), dFdy(sampleZ)) / vec2(dFdx(tex.x), dFdy(tex.y));\n"
"\n"
"	if (length(slope) * zFar > 5000.0)\n"
"		return 1.0;\n"
"\n"
"	vec2 offsetScale = vec2(scale * 1024.0 / scaleZ);\n"
"\n"
"	mat2 rmat = randomRotation(tex);\n"
"\n"
"	float invZFar = 1.0 / zFar;\n"
"	float zLimit = 20.0 * invZFar;\n"
"	int i;\n"
"	for (i = 0; i < NUM_SAMPLES; i++)\n"
"	{\n"
"		vec2 offset = rmat * poissonDisc[i] * offsetScale;\n"
"		float sampleDiff = getLinearDepth(depthMap, tex + offset, zFarDivZNear) - sampleZ;\n"
"\n"
"		bool s1 = abs(sampleDiff) > zLimit;\n"
"		bool s2 = sampleDiff + invZFar > dot(slope, offset);\n"
"		result += float(s1 || s2);\n"
"	}\n"
"\n"
"	result *= 1.0 / float(NUM_SAMPLES);\n"
"\n"
"	return result;\n"
"}\n"
"\n"
"void main() {\n"
"	float result = ambientOcclusion(u_ScreenDepthMap, v_ScreenTex, u_ViewInfo.x, u_ViewInfo.y, u_ViewInfo.wz);\n"
"\n"
"    a_Color = vec4(vec3(result), 1.0);\n"
"}\n"
;
