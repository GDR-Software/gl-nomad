
const char *fallbackShader_texturecolor_fp =
"#if !defined(GLSL_LEGACY)\n"
"layout( location = 0 ) out vec4 a_Color;\n"
"#endif\n"
"\n"
"TEXTURE2D u_DiffuseMap;\n"
"uniform vec4 u_Color;\n"
"uniform int u_AntiAliasing;\n"
"uniform int u_AntiAliasingQuality;\n"
"uniform float u_GammaAmount;\n"
"uniform bool u_FinalPass;\n"
"\n"
"in vec2 v_TexCoords;\n"
"\n"
"#include \"image_sharpen.glsl\"\n"
"#include \"fxaa.glsl\"\n"
"\n"
"void main() {\n"
"//	if ( u_FinalPass ) {\n"
"//		if ( u_AntiAliasing == AntiAlias_FXAA ) {\n"
"//			a_Color = ApplyFXAA( u_DiffuseMap, v_TexCoords );\n"
"//		}\n"
"//		a_Color *= sharpenImage( u_DiffuseMap, v_TexCoords );\n"
"//	} else {\n"
"		a_Color = texture2D( u_DiffuseMap, v_TexCoords );\n"
"//	}\n"
"}\n"
;

const char *fallbackShader_fxaa =
"// not my work, from https://github.com/libretro/glsl-shaders/blob/master/anti-aliasing/shaders/fxaa.glsl\n"
"\n"
"#if 1\n"
"/*\n"
"FXAA_PRESET - Choose compile-in knob preset 0-5.\n"
"------------------------------------------------------------------------------\n"
"FXAA_EDGE_THRESHOLD - The minimum amount of local contrast required\n"
"                      to apply algorithm.\n"
"                      1.0/3.0  - too little\n"
"                      1.0/4.0  - good start\n"
"                      1.0/8.0  - applies to more edges\n"
"                      1.0/16.0 - overkill\n"
"------------------------------------------------------------------------------\n"
"FXAA_EDGE_THRESHOLD_MIN - Trims the algorithm from processing darks.\n"
"                          Perf optimization.\n"
"                          1.0/32.0 - visible limit (smaller isn\'t visible)\n"
"                          1.0/16.0 - good compromise\n"
"                          1.0/12.0 - upper limit (seeing artifacts)\n"
"------------------------------------------------------------------------------\n"
"FXAA_SEARCH_STEPS - Maximum number of search steps for end of span.\n"
"------------------------------------------------------------------------------\n"
"FXAA_SEARCH_THRESHOLD - Controls when to stop searching.\n"
"                        1.0/4.0 - seems to be the best quality wise\n"
"------------------------------------------------------------------------------\n"
"FXAA_SUBPIX_TRIM - Controls sub-pixel aliasing removal.\n"
"                   1.0/2.0 - low removal\n"
"                   1.0/3.0 - medium removal\n"
"                   1.0/4.0 - default removal\n"
"                   1.0/8.0 - high removal\n"
"                   0.0 - complete removal\n"
"------------------------------------------------------------------------------\n"
"FXAA_SUBPIX_CAP - Insures fine detail is not completely removed.\n"
"                  This is important for the transition of sub-pixel detail,\n"
"                  like fences and wires.\n"
"                  3.0/4.0 - default (medium amount of filtering)\n"
"                  7.0/8.0 - high amount of filtering\n"
"                  1.0 - no capping of sub-pixel aliasing removal\n"
"*/\n"
"\n"
"// Return the luma, the estimation of luminance from rgb inputs.\n"
"// This approximates luma using one FMA instruction,\n"
"// skipping normalization and tossing out blue.\n"
"// FxaaLuma() will range 0.0 to 2.963210702.\n"
"float FxaaLuma( vec3 rgb ) {\n"
"    return rgb.y * ( 0.587 / 0.299 ) + rgb.x;\n"
"}\n"
"\n"
"vec3 FxaaLerp3( vec3 a, vec3 b, float amountOfA ) {\n"
"    return ( vec3( -amountOfA ) * b) + ( ( a * vec3( amountOfA ) ) + b );\n"
"}\n"
"\n"
"vec4 FxaaTexOff( sampler2D tex, vec2 pos, ivec2 off, vec2 rcpFrame ) {\n"
"    float x = pos.x + float( off.x ) * rcpFrame.x;\n"
"    float y = pos.y + float( off.y ) * rcpFrame.y;\n"
"    return texture( tex, vec2( x, y ) );\n"
"}\n"
"\n"
"// pos is the output of FxaaVertexShader interpolated across screen.\n"
"// xy -> actual texture position {0.0 to 1.0}\n"
"// rcpFrame should be a uniform equal to  {1.0/frameWidth, 1.0/frameHeight}\n"
"vec4 ApplyFXAA( sampler2D tex, vec2 pos ) {\n"
"	const vec2 rcpFrame = vec2( 1.0 / u_ScreenSize.x, 1.0 / u_ScreenSize.y );\n"
"\n"
"	float FXAA_EDGE_THRESHOLD = 0.0;\n"
"	float FXAA_EDGE_THRESHOLD_MIN = 0.0;\n"
"	int FXAA_SEARCH_STEPS = 0;\n"
"	float FXAA_SEARCH_THRESHOLD = 0.0;\n"
"	float FXAA_SUBPIX_CAP = 0.0;\n"
"	float FXAA_SUBPIX_TRIM = 0.0;\n"
"\n"
"	switch ( u_AntiAliasingQuality ) {\n"
"	case QUALITY_LOW:\n"
"		FXAA_EDGE_THRESHOLD		= 1.0 / 8.0;\n"
"		FXAA_EDGE_THRESHOLD_MIN	= 1.0 / 16.0;\n"
"		FXAA_SEARCH_STEPS		= 16;\n"
"		FXAA_SEARCH_THRESHOLD	= ( 1.0 / 4.0 );\n"
"		FXAA_SUBPIX_CAP			= ( 3.0 / 4.0 );\n"
"		FXAA_SUBPIX_TRIM		= ( 1.0 / 4.0 );\n"
"		break;\n"
"	case QUALITY_NORMAL:\n"
"		FXAA_EDGE_THRESHOLD		= 1.0 / 8.0;\n"
"		FXAA_EDGE_THRESHOLD_MIN	= 1.0 / 24.0;\n"
"		FXAA_SEARCH_STEPS		= 24;\n"
"		FXAA_SEARCH_THRESHOLD	= ( 1.0 / 4.0 );\n"
"		FXAA_SUBPIX_CAP			= ( 3.0 / 4.0 );\n"
"		FXAA_SUBPIX_TRIM		= ( 1.0 / 4.0 );\n"
"		break;\n"
"	case QUALITY_HIGH:\n"
"		FXAA_EDGE_THRESHOLD		= 1.0 / 8.0;\n"
"		FXAA_EDGE_THRESHOLD_MIN	= 1.0 / 24.0;\n"
"		FXAA_SEARCH_STEPS		= 32;\n"
"		FXAA_SEARCH_THRESHOLD	= ( 1.0 / 4.0 );\n"
"		FXAA_SUBPIX_CAP			= ( 3.0 / 4.0 );\n"
"		FXAA_SUBPIX_TRIM		= ( 1.0 / 4.0 );\n"
"		break;\n"
"	};\n"
"\n"
"	const float FXAA_SUBPIX_TRIM_SCALE = ( 1.0 / ( 1.0 - FXAA_SUBPIX_TRIM ) );\n"
"\n"
"    vec3 rgbN = FxaaTexOff( tex, pos.xy, ivec2(  0,-1 ), rcpFrame ).xyz;\n"
"    vec3 rgbW = FxaaTexOff( tex, pos.xy, ivec2( -1, 0 ), rcpFrame ).xyz;\n"
"    vec3 rgbM = FxaaTexOff( tex, pos.xy, ivec2(  0, 0 ), rcpFrame ).xyz;\n"
"    vec3 rgbE = FxaaTexOff( tex, pos.xy, ivec2(  1, 0 ), rcpFrame ).xyz;\n"
"    vec3 rgbS = FxaaTexOff( tex, pos.xy, ivec2(  0, 1 ), rcpFrame ).xyz;\n"
"\n"
"    float lumaN = FxaaLuma( rgbN );\n"
"    float lumaW = FxaaLuma( rgbW );\n"
"    float lumaM = FxaaLuma( rgbM );\n"
"    float lumaE = FxaaLuma( rgbE );\n"
"    float lumaS = FxaaLuma( rgbS );\n"
"    float rangeMin = min( lumaM, min( min( lumaN, lumaW ), min( lumaS, lumaE ) ) );\n"
"    float rangeMax = max( lumaM, max( max( lumaN, lumaW ), max( lumaS, lumaE ) ) );\n"
"\n"
"    float range = rangeMax - rangeMin;\n"
"    if ( range < max( FXAA_EDGE_THRESHOLD_MIN, rangeMax * FXAA_EDGE_THRESHOLD ) ) {\n"
"        return vec4( rgbM, 1.0 );\n"
"    }\n"
"\n"
"    vec3 rgbL = rgbN + rgbW + rgbM + rgbE + rgbS;\n"
"\n"
"    float lumaL = ( lumaN + lumaW + lumaE + lumaS ) * 0.25;\n"
"    float rangeL = abs(lumaL - lumaM);\n"
"    float blendL = max(0.0, (rangeL / range) - FXAA_SUBPIX_TRIM) * FXAA_SUBPIX_TRIM_SCALE;\n"
"    blendL = min(FXAA_SUBPIX_CAP, blendL);\n"
"\n"
"    vec3 rgbNW = FxaaTexOff(tex, pos.xy, ivec2(-1,-1), rcpFrame).xyz;\n"
"    vec3 rgbNE = FxaaTexOff(tex, pos.xy, ivec2( 1,-1), rcpFrame).xyz;\n"
"    vec3 rgbSW = FxaaTexOff(tex, pos.xy, ivec2(-1, 1), rcpFrame).xyz;\n"
"    vec3 rgbSE = FxaaTexOff(tex, pos.xy, ivec2( 1, 1), rcpFrame).xyz;\n"
"    rgbL += (rgbNW + rgbNE + rgbSW + rgbSE);\n"
"    rgbL *= vec3(1.0/9.0);\n"
"\n"
"    float lumaNW = FxaaLuma(rgbNW);\n"
"    float lumaNE = FxaaLuma(rgbNE);\n"
"    float lumaSW = FxaaLuma(rgbSW);\n"
"    float lumaSE = FxaaLuma(rgbSE);\n"
"\n"
"    float edgeVert =\n"
"        abs((0.25 * lumaNW) + (-0.5 * lumaN) + (0.25 * lumaNE)) +\n"
"        abs((0.50 * lumaW ) + (-1.0 * lumaM) + (0.50 * lumaE )) +\n"
"        abs((0.25 * lumaSW) + (-0.5 * lumaS) + (0.25 * lumaSE));\n"
"    float edgeHorz =\n"
"        abs((0.25 * lumaNW) + (-0.5 * lumaW) + (0.25 * lumaSW)) +\n"
"        abs((0.50 * lumaN ) + (-1.0 * lumaM) + (0.50 * lumaS )) +\n"
"        abs((0.25 * lumaNE) + (-0.5 * lumaE) + (0.25 * lumaSE));\n"
"\n"
"    bool horzSpan = edgeHorz >= edgeVert;\n"
"    float lengthSign = horzSpan ? -rcpFrame.y : -rcpFrame.x;\n"
"\n"
"    if(!horzSpan)\n"
"    {\n"
"        lumaN = lumaW;\n"
"        lumaS = lumaE;\n"
"    }\n"
"\n"
"    float gradientN = abs(lumaN - lumaM);\n"
"    float gradientS = abs(lumaS - lumaM);\n"
"    lumaN = (lumaN + lumaM) * 0.5;\n"
"    lumaS = (lumaS + lumaM) * 0.5;\n"
"\n"
"    if (gradientN < gradientS)\n"
"    {\n"
"        lumaN = lumaS;\n"
"        lumaN = lumaS;\n"
"        gradientN = gradientS;\n"
"        lengthSign *= -1.0;\n"
"    }\n"
"\n"
"    vec2 posN;\n"
"    posN.x = pos.x + (horzSpan ? 0.0 : lengthSign * 0.5);\n"
"    posN.y = pos.y + (horzSpan ? lengthSign * 0.5 : 0.0);\n"
"\n"
"    gradientN *= FXAA_SEARCH_THRESHOLD;\n"
"\n"
"    vec2 posP = posN;\n"
"    vec2 offNP = horzSpan ? vec2(rcpFrame.x, 0.0) : vec2(0.0, rcpFrame.y);\n"
"    float lumaEndN = lumaN;\n"
"    float lumaEndP = lumaN;\n"
"    bool doneN = false;\n"
"    bool doneP = false;\n"
"    posN += offNP * vec2(-1.0, -1.0);\n"
"    posP += offNP * vec2( 1.0,  1.0);\n"
"\n"
"    for(int i = 0; i < FXAA_SEARCH_STEPS; i++) {\n"
"        if(!doneN)\n"
"        {\n"
"            lumaEndN = FxaaLuma(texture(tex, posN.xy).xyz);\n"
"        }\n"
"        if(!doneP)\n"
"        {\n"
"            lumaEndP = FxaaLuma(texture(tex, posP.xy).xyz);\n"
"        }\n"
"\n"
"        doneN = doneN || (abs(lumaEndN - lumaN) >= gradientN);\n"
"        doneP = doneP || (abs(lumaEndP - lumaN) >= gradientN);\n"
"\n"
"        if(doneN && doneP)\n"
"        {\n"
"            break;\n"
"        }\n"
"        if(!doneN)\n"
"        {\n"
"            posN -= offNP;\n"
"        }\n"
"        if(!doneP)\n"
"        {\n"
"            posP += offNP;\n"
"        }\n"
"    }\n"
"\n"
"    float dstN = horzSpan ? pos.x - posN.x : pos.y - posN.y;\n"
"    float dstP = horzSpan ? posP.x - pos.x : posP.y - pos.y;\n"
"    bool directionN = dstN < dstP;\n"
"    lumaEndN = directionN ? lumaEndN : lumaEndP;\n"
"\n"
"    if(((lumaM - lumaN) < 0.0) == ((lumaEndN - lumaN) < 0.0))\n"
"    {\n"
"        lengthSign = 0.0;\n"
"    }\n"
"\n"
"\n"
"    float spanLength = (dstP + dstN);\n"
"    dstN = directionN ? dstN : dstP;\n"
"    float subPixelOffset = (0.5 + (dstN * (-1.0/spanLength))) * lengthSign;\n"
"    vec3 rgbF = texture(tex, vec2(\n"
"        pos.x + (horzSpan ? 0.0 : subPixelOffset),\n"
"        pos.y + (horzSpan ? subPixelOffset : 0.0))).xyz;\n"
"\n"
"	return vec4( FxaaLerp3( rgbL, rgbF, blendL ), 1.0 );\n"
"}\n"
"#else\n"
"#if !defined(FXAA_PRESET)\n"
"	#define FXAA_PRESET 5\n"
"#endif\n"
"#if FXAA_PRESET == 3\n"
"	#define FXAA_EDGE_THRESHOLD      ( 1.0 / 8.0 )\n"
"	#define FXAA_EDGE_THRESHOLD_MIN  ( 1.0 / 16.0 )\n"
"	#define FXAA_SEARCH_STEPS        16\n"
"	#define FXAA_SEARCH_THRESHOLD    ( 1.0 / 4.0 )\n"
"	#define FXAA_SUBPIX_CAP          ( 3.0 / 4.0 )\n"
"	#define FXAA_SUBPIX_TRIM         ( 1.0 / 4.0 )\n"
"#elif FXAA_PRESET == 4\n"
"	#define FXAA_EDGE_THRESHOLD      ( 1.0 / 8.0 )\n"
"	#define FXAA_EDGE_THRESHOLD_MIN  ( 1.0 / 24.0 )\n"
"	#define FXAA_SEARCH_STEPS        24\n"
"	#define FXAA_SEARCH_THRESHOLD    ( 1.0 / 4.0 )\n"
"	#define FXAA_SUBPIX_CAP          ( 3.0 / 4.0 )\n"
"	#define FXAA_SUBPIX_TRIM         ( 1.0 / 4.0 )\n"
"#elif FXAA_PRESET == 5\n"
"	#define FXAA_EDGE_THRESHOLD      ( 1.0 / 8.0 )\n"
"	#define FXAA_EDGE_THRESHOLD_MIN  ( 1.0 / 24.0 )\n"
"	#define FXAA_SEARCH_STEPS        32\n"
"	#define FXAA_SEARCH_THRESHOLD    ( 1.0 / 4.0 )\n"
"	#define FXAA_SUBPIX_CAP          ( 3.0 / 4.0 )\n"
"	#define FXAA_SUBPIX_TRIM         ( 1.0 / 4.0 )\n"
"#endif\n"
"\n"
"#define FXAA_SUBPIX_TRIM_SCALE ( 1.0 / ( 1.0 - FXAA_SUBPIX_TRIM ) )\n"
"\n"
"void texcoords( vec2 fragCoord, vec2 resolution, out vec2 v_rgbNW, out vec2 v_rgbNE, out vec2 v_rgbSW,\n"
"	out vec2 v_rgbSE, out vec2 v_rgbM )\n"
"{\n"
"	vec2 inverseVP = 1.0 / resolution.xy;\n"
"	v_rgbNW = ( fragCoord + vec2( -1.0, -1.0 ) ) * inverseVP;\n"
"	v_rgbNE = ( fragCoord + vec2( 1.0, -1.0 ) ) * inverseVP;\n"
"	v_rgbSW = ( fragCoord + vec2( -1.0, 1.0 ) ) * inverseVP;\n"
"	v_rgbSE = ( fragCoord + vec2( 1.0, 1.0 ) ) * inverseVP;\n"
"	v_rgbM = vec2( fragCoord * inverseVP );\n"
"}\n"
"\n"
"#ifndef FXAA_REDUCE_MIN\n"
"	#define FXAA_REDUCE_MIN   (1.0/ 128.0)\n"
"#endif\n"
"#ifndef FXAA_REDUCE_MUL\n"
"	#define FXAA_REDUCE_MUL   (1.0 / 8.0)\n"
"#endif\n"
"#ifndef FXAA_SPAN_MAX\n"
"	#define FXAA_SPAN_MAX     8.0\n"
"#endif\n"
"\n"
"//optimized version for mobile, where dependent\n"
"//texture reads can be a bottleneck\n"
"vec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 resolution,\n"
"			vec2 v_rgbNW, vec2 v_rgbNE,\n"
"			vec2 v_rgbSW, vec2 v_rgbSE,\n"
"			vec2 v_rgbM) {\n"
"	vec4 color;\n"
"	vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);\n"
"	vec3 rgbNW = texture(tex, v_rgbNW).xyz;\n"
"	vec3 rgbNE = texture(tex, v_rgbNE).xyz;\n"
"	vec3 rgbSW = texture(tex, v_rgbSW).xyz;\n"
"	vec3 rgbSE = texture(tex, v_rgbSE).xyz;\n"
"	vec4 texColor = texture(tex, v_rgbM);\n"
"	vec3 rgbM  = texColor.xyz;\n"
"	vec3 luma = vec3(0.299, 0.587, 0.114);\n"
"	float lumaNW = dot(rgbNW, luma);\n"
"	float lumaNE = dot(rgbNE, luma);\n"
"	float lumaSW = dot(rgbSW, luma);\n"
"	float lumaSE = dot(rgbSE, luma);\n"
"	float lumaM  = dot(rgbM,  luma);\n"
"	float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n"
"	float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n"
"\n"
"	vec2 dir;\n"
"	dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n"
"	dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n"
"\n"
"	float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n"
"						  (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n"
"\n"
"	float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n"
"	dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n"
"			  max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n"
"			  dir * rcpDirMin)) * inverseVP;\n"
"\n"
"	vec3 rgbA = 0.5 * (\n"
"		texture(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\n"
"		texture(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n"
"	vec3 rgbB = rgbA * 0.5 + 0.25 * (\n"
"		texture(tex, fragCoord * inverseVP + dir * -0.5).xyz +\n"
"		texture(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n"
"\n"
"	float lumaB = dot(rgbB, luma);\n"
"	if ((lumaB < lumaMin) || (lumaB > lumaMax))\n"
"		color = vec4(rgbA, texColor.a);\n"
"	else\n"
"		color = vec4(rgbB, texColor.a);\n"
"	return color;\n"
"}\n"
"\n"
"vec4 ApplyFXAA( sampler2D tex, vec2 fragCoord ) {\n"
"	const vec2 resolution = u_ScreenSize;\n"
"	vec2 v_rgbNW;\n"
"	vec2 v_rgbNE;\n"
"	vec2 v_rgbSW;\n"
"	vec2 v_rgbSE;\n"
"	vec2 v_rgbM;\n"
"\n"
"	texcoords( fragCoord, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM );\n"
"\n"
"	return fxaa( tex, fragCoord, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM );\n"
"}\n"
"#endif\n"
;

const char *fallbackShader_generic_fp =
"#if !defined(GLSL_LEGACY)\n"
"layout( location = 0 ) out vec4 a_Color;\n"
"layout( location = 1 ) out vec4 a_BrightColor;\n"
"#endif\n"
"\n"
"in vec2 v_TexCoords;\n"
"in vec4 v_Color;\n"
"\n"
"TEXTURE2D u_DiffuseMap;\n"
"\n"
"uniform float u_GammaAmount;\n"
"uniform bool u_GamePaused;\n"
"uniform bool u_HardwareGamma;\n"
"uniform int u_AntiAliasing;\n"
"uniform int u_AntiAliasingQuality;\n"
"\n"
"uniform bool u_WorldDrawing;\n"
"uniform float u_CameraExposure;\n"
"uniform bool u_HDR;\n"
"uniform bool u_PBR;\n"
"uniform bool u_Bloom;\n"
"uniform int u_ToneMap;\n"
"\n"
"uniform int u_AlphaTest;\n"
"\n"
"#include \"image_sharpen.glsl\"\n"
"#include \"fxaa.glsl\"\n"
"\n"
"void main() {\n"
"	if ( u_AntiAliasing == AntiAlias_FXAA ) {\n"
"		vec2 fragCoord = v_TexCoords * u_ScreenSize;\n"
"		a_Color = ApplyFXAA( u_DiffuseMap, v_TexCoords );\n"
"	} else {\n"
"		a_Color = sharpenImage( u_DiffuseMap, v_TexCoords );\n"
"	}\n"
"	if ( a_Color.a == 0.0 ) {\n"
"		discard;\n"
"	}\n"
"\n"
"	if ( u_Bloom && u_HDR ) {\n"
"		float brightness = dot( a_Color.rgb, vec3( 0.1, 0.1, 0.1 ) );\n"
"		if ( brightness > 0.5 ) {\n"
"			a_BrightColor = vec4( a_Color.rgb, 1.0 );\n"
"		} else {\n"
"			a_BrightColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n"
"		}\n"
"	} else {\n"
"		a_Color.rgb = pow( a_Color.rgb, vec3( 1.0 / u_GammaAmount ) );\n"
"	}\n"
"	a_Color.rgb *= v_Color.rgb;\n"
"\n"
"	if ( u_GamePaused ) {\n"
"		a_Color.rgb = vec3( a_Color.rg * 0.2, 0.5 );\n"
"	}\n"
"}\n"
;

const char *fallbackShader_imgui_fp =
"layout( location = 0 ) out vec4 a_Color;\n"
"layout( location = 1 ) out vec4 a_BrightColor;\n"
"\n"
"in vec2 v_TexCoords;\n"
"in vec4 v_Color;\n"
"\n"
"TEXTURE2D u_DiffuseMap;\n"
"uniform float u_GammaAmount;\n"
"uniform float u_CameraExposure;\n"
"uniform bool u_HardwareGamma;\n"
"uniform bool u_GamePaused;\n"
"uniform int u_AntiAliasing;\n"
"uniform int u_AntiAliasingQuality;\n"
"uniform bool u_HDR;\n"
"uniform bool u_Bloom;\n"
"uniform bool u_PostProcess;\n"
"\n"
"#include \"image_sharpen.glsl\"\n"
"#include \"fxaa.glsl\"\n"
"\n"
"void main() {\n"
"	if ( !u_PostProcess ) {\n"
"		if ( u_AntiAliasing == AntiAlias_FXAA ) {\n"
"			vec2 fragCoord = v_TexCoords * u_ScreenSize;\n"
"			a_Color = v_Color * ApplyFXAA( u_DiffuseMap, fragCoord );\n"
"		} else {\n"
"			a_Color = v_Color * sharpenImage( u_DiffuseMap, v_TexCoords );\n"
"		}\n"
"	} else {\n"
"		a_Color = v_Color * texture2D( u_DiffuseMap, v_TexCoords );\n"
"	}\n"
"\n"
"	if ( u_Bloom && u_HDR ) {\n"
"		// check whether fragment output is higher than threshold, if so output as brightness color\n"
"		float brightness = dot( a_Color.rgb, vec3( 0.1, 0.1, 0.1 ) );\n"
"		if ( brightness > 0.5 ) {\n"
"			a_BrightColor = vec4( a_Color.rgb, 1.0 );\n"
"		} else {\n"
"			a_BrightColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n"
"		}\n"
"	}\n"
"	else {\n"
"		a_Color.rgb = pow( a_Color.rgb, vec3( 1.0 / u_GammaAmount ) );\n"
"	}\n"
"}\n"
;

const char *fallbackShader_tile_vp =
"in vec2 a_Position;\n"
"in vec2 a_TexCoords;\n"
"in uvec2 a_WorldPos;\n"
"in vec4 a_Color;\n"
"\n"
"out vec2 v_TexCoords;\n"
"out vec4 v_Color;\n"
"out uvec2 v_WorldPos;\n"
"out vec3 v_LightingColor;\n"
"\n"
"uniform mat4 u_ModelViewProjection;\n"
"uniform vec4 u_BaseColor;\n"
"uniform vec4 u_VertColor;\n"
"uniform int u_ColorGen;\n"
"\n"
"uniform int u_LightingQuality;\n"
"uniform vec3 u_AmbientColor;\n"
"uniform int u_NumLights;\n"
"\n"
"TEXTURE2D u_DiffuseMap;\n"
"\n"
"struct Light {\n"
"	vec4 color;\n"
"	uvec2 origin;\n"
"	float brightness;\n"
"	float range;\n"
"	float linear;\n"
"	float quadratic;\n"
"	float constant;\n"
"	int type;\n"
"};\n"
"\n"
"layout( std140, binding = 0 ) readonly buffer u_LightBuffer {\n"
"	Light u_LightData[];\n"
"};\n"
"\n"
"vec3 CalcPointLight( Light light ) {\n"
"	vec3 diffuse = v_LightingColor.rgb;\n"
"	float dist = distance( v_WorldPos, light.origin );\n"
"	float diff = 0.0;\n"
"	float range = light.range;\n"
"	float attenuation = 1.0;\n"
"\n"
"	if ( dist <= light.range ) {\n"
"		diff = 1.0 - abs( dist / light.range );\n"
"	}\n"
"	diff += light.brightness;\n"
"	diffuse = min( diff * ( diffuse + vec3( light.color ) ), diffuse );\n"
"\n"
"	range = light.range * light.brightness;\n"
"\n"
"	attenuation = ( light.constant + light.linear + light.quadratic * ( light.range * light.range ) );\n"
"\n"
"	return ( diffuse * attenuation );\n"
"}\n"
"\n"
"void main() {\n"
"//	if ( u_ColorGen == CGEN_VERTEX ) {\n"
"		v_Color = vec4( 1.0 );\n"
"//	} else {\n"
"//		v_Color = u_VertColor * a_Color + u_BaseColor;\n"
"//	}\n"
"	v_WorldPos = a_WorldPos;\n"
"	v_TexCoords = a_TexCoords;\n"
"\n"
"//	if ( u_LightingQuality == QUALITY_LOW ) {\n"
"		v_LightingColor = vec3( 1.0 );\n"
"		for ( int i = 0; i < u_NumLights; i++ ) {\n"
"			v_LightingColor += CalcPointLight( u_LightData[ i ] );\n"
"		}\n"
"		v_LightingColor *= u_AmbientColor;\n"
"//	}\n"
"\n"
"    gl_Position = u_ModelViewProjection * vec4( a_Position, 0.0, 1.0 );\n"
"}\n"
;

const char *fallbackShader_bloom_vp =
"in vec2 a_Position;\n"
"in vec2 a_TexCoords;\n"
"\n"
"out vec2 v_TexCoords;\n"
"\n"
"void main() {\n"
"    v_TexCoords = a_TexCoords;\n"
"    gl_Position = vec4( a_Position, 0.0, 1.0 );\n"
"}\n"
;

const char *fallbackShader_texturecolor_vp =
"in vec2 a_Position;\n"
"in vec2 a_TexCoords;\n"
"\n"
"uniform mat4 u_ModelViewProjection;\n"
"\n"
"out vec2 v_TexCoords;\n"
"\n"
"void main() {\n"
"	gl_Position = vec4( a_Position, 0.0, 1.0 );\n"
"	v_TexCoords = a_TexCoords;\n"
"}\n"
;

const char *fallbackShader_bloom_fp =
"layout( location = 0 ) out vec4 a_Color;\n"
"\n"
"in vec2 v_TexCoords;\n"
"\n"
"TEXTURE2D u_DiffuseMap;\n"
"TEXTURE2D u_BrightMap;\n"
"\n"
"uniform int u_AntiAliasing;\n"
"uniform int u_AntiAliasingQuality;\n"
"uniform bool u_Bloom;\n"
"uniform bool u_HDR;\n"
"uniform float u_GammaAmount;\n"
"uniform float u_CameraExposure;\n"
"\n"
"#include \"image_sharpen.glsl\"\n"
"#include \"fxaa.glsl\"\n"
"\n"
"void main() {\n"
"	vec3 color;\n"
"\n"
"	if ( u_AntiAliasing == AntiAlias_FXAA ) {\n"
"		vec2 fragCoord = v_TexCoords * u_ScreenSize;\n"
"		a_Color = ApplyFXAA( u_DiffuseMap, fragCoord );\n"
"	} else {\n"
"		a_Color = texture( u_DiffuseMap, v_TexCoords );\n"
"	}\n"
"	a_Color.rgb *= sharpenImage( u_DiffuseMap, v_TexCoords ).rgb;\n"
"\n"
"	if ( u_Bloom ) {\n"
"		vec3 bloomColor = texture( u_BrightMap, v_TexCoords ).rgb;\n"
"		a_Color.rgb += bloomColor;\n"
"	}\n"
"\n"
"	// exposure tone mapping\n"
"	a_Color.rgb = vec3( 1.0 ) - exp( -a_Color.rgb * u_CameraExposure );\n"
"\n"
"	// apply final gamma\n"
"	a_Color = vec4( pow( a_Color.rgb, vec3( 1.0 / u_GammaAmount ) ), 1.0 );\n"
"}\n"
;

const char *fallbackShader_generic_vp =
"in vec2 a_Position;\n"
"in uvec2 a_WorldPos;\n"
"in vec2 a_TexCoords;\n"
"in vec4 a_Color;\n"
"\n"
"out vec2 v_TexCoords;\n"
"out vec4 v_Color;\n"
"\n"
"uniform mat4 u_ModelViewProjection;\n"
"uniform vec4 u_BaseColor;\n"
"uniform vec4 u_VertColor;\n"
"\n"
"#if defined(USE_RGBAGEN)\n"
"uniform int u_ColorGen;\n"
"uniform int u_AlphaGen;\n"
"uniform vec3 u_DirectedLight;\n"
"#endif\n"
"\n"
"#if defined(USE_TCGEN)\n"
"uniform vec4 u_DiffuseTexMatrix;\n"
"uniform vec4 u_DiffuseTexOffTurb;\n"
"#endif\n"
"\n"
"#if defined(USE_TCGEN)\n"
"uniform int u_TCGen0;\n"
"uniform vec3 u_TCGen0Vector0;\n"
"uniform vec3 u_TCGen0Vector1;\n"
"uniform vec3 u_WorldPos;\n"
"#endif\n"
"\n"
"#if defined(USE_TCMOD)\n"
"vec2 ModTexCoords( vec2 st, vec3 position, vec4 texMatrix, vec4 offTurb )\n"
"{\n"
"	float amplitude = offTurb.z;\n"
"	float phase = offTurb.w * 2.0 * M_PI;\n"
"	vec2 st2;\n"
"\n"
"	st2.x = st.x * texMatrix.x + ( st.y * texMatrix.z + offTurb.x );\n"
"	st2.y = st.x * texMatrix.y + ( st.y * texMatrix.w + offTurb.y );\n"
"\n"
"	vec2 offsetPos = vec2( position.x + position.z, position.y );\n"
"\n"
"	vec2 texOffset = sin( offsetPos * ( 2.0 * M_PI / 1024.0 ) + vec2( phase ) );\n"
"\n"
"	return st2 + texOffset * amplitude;\n"
"}\n"
"#endif\n"
"\n"
"#if defined(USE_TCGEN)\n"
"vec2 GenTexCoords( int TCGen, vec3 position, vec3 normal, vec3 TCGenVector0, vec3 TCGenVector1 )\n"
"{\n"
"	vec2 tex = a_TexCoords;\n"
"\n"
"	if ( TCGen == TCGEN_LIGHTMAP ) {\n"
"		tex = a_TexCoords.st;\n"
"	}\n"
"	else if ( TCGen == TCGEN_ENVIRONMENT_MAPPED ) {\n"
"		vec3 viewer = normalize( vec3( 0.0 ) - position );\n"
"		vec2 ref = reflect( viewer, normal ).yz;\n"
"		tex.s = ref.x * -0.5 + 0.5;\n"
"		tex.t = ref.y *  0.5 + 0.5;\n"
"	}\n"
"	else if ( TCGen == TCGEN_VECTOR ) {\n"
"		tex = vec2( dot( position, TCGenVector0 ), dot( position, TCGenVector1 ) );\n"
"	}\n"
"\n"
"	return tex;\n"
"}\n"
"#endif\n"
"\n"
"void main() {\n"
"	if ( u_ColorGen == CGEN_VERTEX ) {\n"
"		v_Color = vec4( 1.0 );\n"
"	} else {\n"
"		v_Color = u_VertColor * a_Color + u_BaseColor;\n"
"	}\n"
"\n"
"#if defined(USE_TCGEN)\n"
"	vec2 texCoords = GenTexCoords( u_TCGen0, vec3( a_Position.xy, 0.0 ), vec3( 0.0 ), u_TCGen0Vector0, u_TCGen0Vector1 );\n"
"#else\n"
"	vec2 texCoords = a_TexCoords;\n"
"#endif\n"
"\n"
"#if defined(USE_TCMOD)\n"
"	v_TexCoords = ModTexCoords( texCoords, vec3( a_Position.xy, 0.0 ), u_DiffuseTexMatrix, u_DiffuseTexOffTurb );\n"
"#else\n"
"	v_TexCoords = texCoords;\n"
"#endif\n"
"\n"
"    gl_Position = u_ModelViewProjection * vec4( a_Position, 0.0, 1.0 );\n"
"}\n"
;

const char *fallbackShader_imgui_vp =
"in vec2 a_Position;\n"
"in vec2 a_TexCoords;\n"
"in vec4 a_Color;\n"
"\n"
"uniform mat4 u_ModelViewProjection;\n"
"uniform vec2 u_ScreenSize;\n"
"\n"
"out vec2 v_TexCoords;\n"
"out vec4 v_Color;\n"
"\n"
"#if defined(USE_TCGEN)\n"
"uniform vec4 u_DiffuseTexMatrix;\n"
"uniform vec4 u_DiffuseTexOffTurb;\n"
"#endif\n"
"\n"
"#if defined(USE_TCGEN)\n"
"uniform int u_TCGen0;\n"
"uniform vec3 u_TCGen0Vector0;\n"
"uniform vec3 u_TCGen0Vector1;\n"
"uniform vec3 u_WorldPos;\n"
"#endif\n"
"\n"
"#if defined(USE_TCMOD)\n"
"vec2 ModTexCoords( vec2 st, vec3 position, vec4 texMatrix, vec4 offTurb )\n"
"{\n"
"	float amplitude = offTurb.z;\n"
"	float phase = offTurb.w * 2.0 * M_PI;\n"
"	vec2 st2;\n"
"\n"
"	st2.x = st.x * texMatrix.x + ( st.y * texMatrix.z + offTurb.x );\n"
"	st2.y = st.x * texMatrix.y + ( st.y * texMatrix.w + offTurb.y );\n"
"\n"
"	vec2 offsetPos = vec2( position.x + position.z, position.y );\n"
"\n"
"	vec2 texOffset = sin( offsetPos * ( 2.0 * M_PI / 1024.0 ) + vec2( phase ) );\n"
"\n"
"	return st2 + texOffset * amplitude;\n"
"}\n"
"#endif\n"
"\n"
"float CalcLightAttenuation( float point, float normDist )\n"
"{\n"
"	// zero light at 1.0, approximating q3 style\n"
"	// also don\'t attenuate directional light\n"
"	float attenuation = ( 0.5 * normDist - 1.5 ) * point + 1.0;\n"
"\n"
"	// clamp attenuation\n"
"#if defined(NO_LIGHT_CLAMP)\n"
"	attenuation = max( attenuation, 0.0 );\n"
"#else\n"
"	attenuation = clamp( attenuation, 0.0, 1.0 );\n"
"#endif\n"
"\n"
"	return attenuation;\n"
"}\n"
"\n"
"#if defined(USE_TCGEN)\n"
"vec2 GenTexCoords( int TCGen, vec3 position, vec3 normal, vec3 TCGenVector0, vec3 TCGenVector1 )\n"
"{\n"
"	vec2 tex = a_TexCoords;\n"
"\n"
"	if ( TCGen == TCGEN_LIGHTMAP ) {\n"
"		tex = a_TexCoords.st;\n"
"	}\n"
"	else if ( TCGen == TCGEN_ENVIRONMENT_MAPPED ) {\n"
"		vec3 viewer = normalize( vec3( 0.0 ) - position );\n"
"		vec2 ref = reflect( viewer, normal ).yz;\n"
"		tex.s = ref.x * -0.5 + 0.5;\n"
"		tex.t = ref.y *  0.5 + 0.5;\n"
"	}\n"
"	else if ( TCGen == TCGEN_VECTOR ) {\n"
"		tex = vec2( dot( position, TCGenVector0 ), dot( position, TCGenVector1 ) );\n"
"	}\n"
"\n"
"	return tex;\n"
"}\n"
"#endif\n"
"\n"
"void main() {\n"
"#if defined(USE_TCGEN)\n"
"	vec2 texCoords = GenTexCoords( u_TCGen0, vec3( a_Position.xy, 0.0 ), vec3( 0.0 ), u_TCGen0Vector0, u_TCGen0Vector1 );\n"
"#else\n"
"	vec2 texCoords = a_TexCoords;\n"
"#endif\n"
"#if defined(USE_TCMOD)\n"
"	v_TexCoords = ModTexCoords( texCoords, vec3( a_Position.xy, 0.0 ), u_DiffuseTexMatrix, u_DiffuseTexOffTurb );\n"
"#else\n"
"	v_TexCoords = texCoords;\n"
"#endif\n"
"    v_Color = a_Color;\n"
"\n"
"    gl_Position = u_ModelViewProjection * vec4( a_Position.xy, 0.0, 1.0 );\n"
"}\n"
;

const char *fallbackShader_tile_fp =
"#if !defined(GLSL_LEGACY)\n"
"layout( location = 0 ) out vec4 a_Color;\n"
"layout( location = 1 ) out vec4 a_BrightColor;\n"
"#endif\n"
"\n"
"in vec2 v_TexCoords;\n"
"in vec4 v_Color;\n"
"in flat uvec2 v_WorldPos;\n"
"in vec3 v_LightingColor;\n"
"\n"
"uniform float u_GammaAmount;\n"
"uniform bool u_GamePaused;\n"
"uniform float u_CameraExposure;\n"
"\n"
"uniform bool u_WorldDrawing;\n"
"uniform mat4 u_ModelViewProjection;\n"
"uniform bool u_HardwareGamma;\n"
"uniform bool u_HDR;\n"
"uniform bool u_PBR;\n"
"uniform int u_AntiAliasing;\n"
"uniform int u_AntiAliasingQuality;\n"
"uniform int u_LightingQuality;\n"
"uniform bool u_Bloom;\n"
"uniform bool u_PostProcess;\n"
"\n"
"uniform int u_AlphaTest;\n"
"\n"
"TEXTURE2D u_DiffuseMap;\n"
"uniform vec3 u_ViewOrigin;\n"
"uniform vec4 u_SpecularScale;\n"
"uniform vec4 u_NormalScale;\n"
"\n"
"#if defined(USE_NORMALMAP)\n"
"TEXTURE2D u_NormalMap;\n"
"#endif\n"
"\n"
"#if defined(USE_SPECULARMAP)\n"
"TEXTURE2D u_SpecularMap;\n"
"#endif\n"
"\n"
"#if defined(USE_PARALLAXMAP)\n"
"TEXTURE2D u_LevelsMap;\n"
"#endif\n"
"\n"
"struct Light {\n"
"	vec4 color;\n"
"	uvec2 origin;\n"
"	float brightness;\n"
"	float range;\n"
"	float linear;\n"
"	float quadratic;\n"
"	float constant;\n"
"	int type;\n"
"};\n"
"\n"
"layout( std140, binding = 0 ) readonly buffer u_LightBuffer {\n"
"	Light u_LightData[];\n"
"};\n"
"\n"
"uniform int u_NumLights;\n"
"uniform vec3 u_AmbientColor;\n"
"\n"
"#include \"image_sharpen.glsl\"\n"
"#include \"fxaa.glsl\"\n"
"\n"
"vec3 CalcNormal() {\n"
"#if defined(USE_NORMALMAP)\n"
"	vec3 normal = texture( u_NormalMap, v_TexCoords ).rgb;\n"
"	normal = normal * 2.0 - 1.0;\n"
"	return normalize( normal );\n"
"#else\n"
"	return vec3( 0.0 );\n"
"#endif\n"
"}\n"
"\n"
"vec3 CalcSpecular() {\n"
"#if defined(USE_SPECULARMAP)\n"
"	vec3 upper = texture( u_SpecularMap, v_TexCoords ).rgb;\n"
"	vec3 lower = a_Color.rgb;\n"
"	vec3 outColor = vec3( 0.0, 0.0, 0.0 );\n"
"\n"
"	if ( upper.r > 0.5 ) {\n"
"		outColor.r = ( 1.0 - ( 1.0 - lower.r ) * ( 1.0 - 2.0 * ( upper.r - 0.5 ) ) );\n"
"	} else {\n"
"		outColor.r = lower.r * ( 2.0 * upper.r );\n"
"	}\n"
"\n"
"	if ( upper.g > 0.5 ) {\n"
"		outColor.g = ( 1.0 - ( 1.0 - lower.g ) * ( 1.0 - 2.0 * ( upper.g - 0.5 ) ) );\n"
"	} else {\n"
"		outColor.g = lower.g * ( 2.0 * upper.g );\n"
"	}\n"
"\n"
"	if ( upper.b > 0.5 ) {\n"
"		outColor.b = ( 1.0 - ( 1.0 - lower.b ) * ( 1.0 - 2.0 * ( upper.b - 0.5 ) ) );\n"
"	} else {\n"
"		outColor.b = lower.b * ( 2.0 * upper.b );\n"
"	}\n"
"\n"
"	return outColor;\n"
"#else\n"
"	return outColor;\n"
"#endif\n"
"}\n"
"\n"
"vec3 CalcPointLight( Light light ) {\n"
"	vec3 diffuse = a_Color.rgb;\n"
"	float dist = distance( v_WorldPos, light.origin );\n"
"	float diff = 0.0;\n"
"	float range = light.range;\n"
"	float attenuation = 1.0;\n"
"\n"
"	if ( dist <= light.range ) {\n"
"		diff = 1.0 - abs( dist / light.range );\n"
"	}\n"
"	diff += light.brightness;\n"
"	diffuse = min( diff * ( diffuse + vec3( light.color ) ), diffuse );\n"
"\n"
"	range = light.range * light.brightness;\n"
"\n"
"	attenuation = ( light.constant + light.linear + light.quadratic * ( light.range * light.range ) );\n"
"	switch ( u_LightingQuality ) {\n"
"	case QUALITY_NORMAL:\n"
"		const vec3 normal = CalcNormal();\n"
"		return ( mix( diffuse, normal, 0.025 ) * attenuation );\n"
"	default:\n"
"		break;\n"
"	};\n"
"\n"
"	const vec3 specular = CalcSpecular();\n"
"	const vec3 normal = CalcNormal();\n"
"	diffuse = mix( diffuse, specular, 0.025 );\n"
"	diffuse = mix( diffuse, normal, 0.025 );\n"
"\n"
"	return ( diffuse * attenuation );\n"
"}\n"
"\n"
"void ApplyLighting() {\n"
"	if ( u_LightingQuality == QUALITY_LOW ) {\n"
"		a_Color.rgb *= v_LightingColor;\n"
"		return;\n"
"	}\n"
"	for ( int i = 0; i < u_NumLights; i++ ) {\n"
"		a_Color.rgb += CalcPointLight( u_LightData[i] );\n"
"	}\n"
"	a_Color.rgb *= u_AmbientColor;\n"
"}\n"
"\n"
"void main() {\n"
"	if ( distance( u_ViewOrigin.xy, v_WorldPos.xy ) >= 16.0 ) {\n"
"		discard;\n"
"	}\n"
"\n"
"	// calculate a slight x offset, otherwise we get some black line bleeding\n"
"	// going on\n"
"	ivec2 texSize = textureSize( u_DiffuseMap, 0 );\n"
"	float sOffset = ( 1.0 / ( float( texSize.x ) ) * 0.75 );\n"
"	float tOffset = ( 1.0 / ( float( texSize.y ) ) * 0.75 );\n"
"	vec2 texCoord = vec2( v_TexCoords.x + sOffset, v_TexCoords.y + tOffset );\n"
"\n"
"	if ( !u_PostProcess ) {\n"
"		if ( u_AntiAliasing == AntiAlias_FXAA ) {\n"
"			vec2 fragCoord = texCoord * u_ScreenSize;\n"
"			a_Color = ApplyFXAA( u_DiffuseMap, fragCoord );\n"
"		} else {\n"
"			a_Color = sharpenImage( u_DiffuseMap, texCoord );\n"
"		}\n"
"	} else {\n"
"		a_Color = texture( u_DiffuseMap, texCoord );\n"
"	}\n"
"\n"
"	const float alpha = a_Color.a * v_Color.a;\n"
"	if ( u_AlphaTest == 1 ) {\n"
"		if ( alpha == 0.0 ) {\n"
"			discard;\n"
"		}\n"
"	}\n"
"	else if ( u_AlphaTest == 2 ) {\n"
"		if ( alpha >= 0.5 ) {\n"
"			discard;\n"
"		}\n"
"	}\n"
"	else if ( u_AlphaTest == 3 ) {\n"
"		if ( alpha < 0.5 ) {\n"
"			discard;\n"
"		}\n"
"	}\n"
"	a_Color.a = alpha;\n"
"\n"
"	ApplyLighting();\n"
"\n"
"	// if we have post processing active, don\'t calculate gamma until the final pass\n"
"	if ( u_HDR && u_Bloom ) {\n"
"		float brightness = dot( a_Color.rgb, vec3( 0.1, 0.1, 0.1 ) );\n"
"		if ( brightness > 0.5 ) {\n"
"			a_BrightColor = vec4( a_Color.rgb, 1.0 );\n"
"		} else {\n"
"			a_BrightColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n"
"		}\n"
"	} else {\n"
"		a_Color.rgb = pow( a_Color.rgb, vec3( 1.0 / u_GammaAmount ) );\n"
"	}\n"
"	if ( u_GamePaused ) {\n"
"		a_Color.rgb = vec3( a_Color.rg * 0.5, 0.5 );\n"
"	}\n"
"}\n"
;

const char *fallbackShader_blur_vp =
"in vec2 a_Position;\n"
"in vec2 a_TexCoords;\n"
"\n"
"out vec2 v_TexCoords;\n"
"\n"
"void main() {\n"
"    v_TexCoords = a_TexCoords;\n"
"    gl_Position = vec4( a_Position, 0.0, 1.0 );\n"
"}\n"
;

const char *fallbackShader_sprite_fp =
"layout( location = 0 ) out vec4 a_Color;\n"
"layout( location = 1 ) out vec4 a_BrightColor;\n"
"\n"
"in vec2 v_TexCoords;\n"
"in vec4 v_Color;\n"
"in vec3 v_WorldPos;\n"
"in vec3 v_Position;\n"
"\n"
"uniform float u_GammaAmount;\n"
"uniform bool u_GamePaused;\n"
"uniform float u_CameraExposure;\n"
"\n"
"uniform mat4 u_ModelViewProjection;\n"
"uniform bool u_HardwareGamma;\n"
"uniform bool u_HDR;\n"
"uniform bool u_PBR;\n"
"uniform int u_AntiAliasing;\n"
"uniform int u_AntiAliasingQuality;\n"
"uniform int u_LightingQuality;\n"
"uniform bool u_Bloom;\n"
"uniform bool u_PostProcess;\n"
"uniform int u_AlphaTest;\n"
"\n"
"TEXTURE2D u_DiffuseMap;\n"
"uniform vec3 u_ViewOrigin;\n"
"uniform vec4 u_SpecularScale;\n"
"uniform vec4 u_NormalScale;\n"
"\n"
"#if defined(USE_NORMALMAP)\n"
"TEXTURE2D u_NormalMap;\n"
"#endif\n"
"\n"
"#if defined(USE_SPECULARMAP)\n"
"TEXTURE2D u_SpecularMap;\n"
"#endif\n"
"\n"
"struct Light {\n"
"	vec4 color;\n"
"	uvec2 origin;\n"
"	float brightness;\n"
"	float range;\n"
"	float linear;\n"
"	float quadratic;\n"
"	float constant;\n"
"	int type;\n"
"};\n"
"\n"
"layout( std140, binding = 0 ) buffer u_LightBuffer {\n"
"	Light u_LightData[];\n"
"};\n"
"\n"
"uniform int u_NumLights;\n"
"uniform vec3 u_AmbientColor;\n"
"\n"
"#include \"image_sharpen.glsl\"\n"
"#include \"fxaa.glsl\"\n"
"\n"
"float CalcLightAttenuation(float point, float normDist)\n"
"{\n"
"	// zero light at 1.0, approximating q3 style\n"
"	// also don\'t attenuate directional light\n"
"	float attenuation = (0.5 * normDist - 1.5) * point + 1.0;\n"
"\n"
"	// clamp attenuation\n"
"	#if defined(NO_LIGHT_CLAMP)\n"
"	attenuation = max(attenuation, 0.0);\n"
"	#else\n"
"	attenuation = clamp(attenuation, 0.0, 1.0);\n"
"	#endif\n"
"\n"
"	return attenuation;\n"
"}\n"
"\n"
"vec3 CalcDiffuse( vec3 diffuseAlbedo, float NH, float EH, float roughness )\n"
"{\n"
"#if defined(USE_BURLEY)\n"
"	// modified from https://disney-animation.s3.amazonaws.com/library/s2012_pbs_disney_brdf_notes_v2.pdf\n"
"	float fd90 = -0.5 + EH * EH * roughness;\n"
"	float burley = 1.0 + fd90 * 0.04 / NH;\n"
"	burley *= burley;\n"
"	return diffuseAlbedo * burley;\n"
"#else\n"
"	return diffuseAlbedo;\n"
"#endif\n"
"}\n"
"\n"
"vec3 CalcNormal() {\n"
"#if defined(USE_NORMALMAP)\n"
"	vec3 normal = texture2D( u_NormalMap, v_TexCoords ).rgb;\n"
"	normal = normal * 2.0 - 1.0;\n"
"	return normalize( normal );\n"
"#else\n"
"	return vec3( 0.0 );\n"
"#endif\n"
"}\n"
"\n"
"vec3 CalcScreenSpaceNormal( vec3 position ) {\n"
"	vec3 dx = dFdx( position );\n"
"	vec3 dy = dFdy( position );\n"
"	return normalize( cross( dx, dy ) );\n"
"}\n"
"\n"
"vec3 CalcPointLight( Light light, bool isDLight ) {\n"
"	vec3 diffuse = a_Color.rgb;\n"
"	float dist = distance( v_WorldPos, vec3( light.origin, gl_FragCoord.z ) );\n"
"	float diff = 0.0;\n"
"	float range = light.range;\n"
"	vec3 specular = vec3( 0.0 );\n"
"	float attenuation = 1.0;\n"
"\n"
"	if ( dist <= light.range ) {\n"
"		diff = 1.0 - abs( dist / light.range );\n"
"	}\n"
"	diff += light.brightness;\n"
"	diffuse = min( diff * ( diffuse + vec3( light.color ) ), diffuse );\n"
"\n"
"	range = light.range * light.brightness;\n"
"\n"
"	attenuation = ( light.constant + light.linear + light.quadratic * ( light.range * light.range ) );\n"
"	if ( u_LightingQuality == 2 ) {\n"
"		vec3 lightDir = vec3( light.origin.xy, 0.0 ) - gl_FragCoord.xyz;\n"
"		vec3 viewDir = normalize( u_ViewOrigin - v_WorldPos );\n"
"		vec3 halfwayDir = normalize( lightDir + viewDir );\n"
"\n"
"		vec3 reflectDir = reflect( -lightDir, v_WorldPos );\n"
"	#if defined(USE_SPECULARMAP)\n"
"		float shininess = texture2D( u_SpecularMap, v_TexCoords ).r;\n"
"	#else\n"
"		float shininess = 16.0;\n"
"	#endif\n"
"		if ( shininess < 16.0 ) {\n"
"			// anything lower than this is barely visible\n"
"			shininess = 16.0;\n"
"		}\n"
"\n"
"		vec3 normal = CalcNormal();\n"
"		if ( normal == vec3( 1.0 ) ) {\n"
"			normal = vec3( 0.0 );\n"
"		}\n"
"		const float energyConservation = ( 8.0 + shininess ) / ( 8.0 * M_PI );\n"
"		float spec = energyConservation * pow( max( dot( normal, halfwayDir ), 0.0 ), shininess );\n"
"		specular = light.color.rgb * vec3( spec );\n"
"		specular *= attenuation;\n"
"\n"
"		diffuse = mix( diffuse, normal, 0.025 );\n"
"	}\n"
"	else if ( u_LightingQuality == 1 ) {\n"
"		const vec3 normal = CalcNormal();\n"
"		const vec3 lightDir = normalize( v_WorldPos ) - normalize( vec3( light.origin.xy, 0.0 ) );\n"
"		diffuse = mix( diffuse, normal, 0.025 );\n"
"	}\n"
"\n"
"	diffuse *= attenuation;\n"
"\n"
"	return diffuse + specular;\n"
"}\n"
"\n"
"void ApplyLighting() {\n"
"	for ( int i = 0; i < u_NumLights; i++ ) {\n"
"		switch ( u_LightData[i].type ) {\n"
"		case POINT_LIGHT:\n"
"			a_Color.rgb += CalcPointLight( u_LightData[i], i > MAX_MAP_LIGHTS );\n"
"			break;\n"
"		case DIRECTION_LIGHT:\n"
"			break;\n"
"		};\n"
"	}\n"
"	a_Color.rgb *= u_AmbientColor;\n"
"}\n"
"\n"
"void main() {\n"
"	if ( distance( u_ViewOrigin, v_WorldPos ) > 12.0 ) {\n"
"		discard;\n"
"	}\n"
"\n"
"	// calculate a slight x offset, otherwise we get some black line bleeding\n"
"	// going on\n"
"	ivec2 texSize = textureSize( u_DiffuseMap, 0 );\n"
"	float sOffset = ( 1.0 / ( float( texSize.x ) ) * 0.75 );\n"
"	float tOffset = ( 1.0 / ( float( texSize.y ) ) * 0.75 );\n"
"	vec2 texCoord = vec2( v_TexCoords.x + sOffset, v_TexCoords.y + tOffset );\n"
"\n"
"	if ( !u_PostProcess ) {\n"
"		if ( u_AntiAliasing == AntiAlias_FXAA ) {\n"
"			vec2 fragCoord = texCoord * u_ScreenSize;\n"
"			a_Color = ApplyFXAA( u_DiffuseMap, fragCoord );\n"
"		} else {\n"
"			a_Color = sharpenImage( u_DiffuseMap, texCoord );\n"
"		}\n"
"	} else {\n"
"		a_Color = texture2D( u_DiffuseMap, texCoord );\n"
"	}\n"
"\n"
"	const float alpha = a_Color.a * v_Color.a;\n"
"	if ( u_AlphaTest == 1 ) {\n"
"		if ( alpha == 0.0 ) {\n"
"			discard;\n"
"		}\n"
"	}\n"
"	else if ( u_AlphaTest == 2 ) {\n"
"		if ( alpha >= 0.5 ) {\n"
"			discard;\n"
"		}\n"
"	}\n"
"	else if ( u_AlphaTest == 3 ) {\n"
"		if ( alpha < 0.5 ) {\n"
"			discard;\n"
"		}\n"
"	}\n"
"	a_Color.a = alpha;\n"
"\n"
"	ApplyLighting();\n"
"\n"
"	// if we have post processing active, don\'t calculate gamma until the final pass\n"
"	if ( u_HDR ) {\n"
"		if ( u_Bloom ) {\n"
"			// check whether fragment output is higher than threshold, if so output as brightness color\n"
"			float brightness = dot( a_Color.rgb, vec3( 0.1, 0.1, 0.1 ) );\n"
"			if ( brightness > 0.5 ) {\n"
"				a_BrightColor = vec4( a_Color.rgb, 1.0 );\n"
"			} else {\n"
"				a_BrightColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n"
"			}\n"
"		}\n"
"	}\n"
"	if ( u_GamePaused ) {\n"
"		a_Color.rgb = vec3( a_Color.rg * 0.5, 0.5 );\n"
"	}\n"
"}\n"
;

const char *fallbackShader_sprite_vp =
"in vec3 a_Position;\n"
"in vec2 a_TexCoords;\n"
"in uvec2 a_WorldPos;\n"
"in vec4 a_Color;\n"
"in vec3 a_Normal;\n"
"in vec3 a_Tangent;\n"
"in vec3 a_Bitangent;\n"
"\n"
"out vec2 v_TexCoords;\n"
"out vec4 v_Color;\n"
"out vec3 v_WorldPos;\n"
"out vec3 v_Position;\n"
"\n"
"uniform bool u_WorldDrawing;\n"
"uniform mat4 u_ModelViewProjection;\n"
"uniform mat4 u_ModelMatrix;\n"
"uniform vec4 u_BaseColor;\n"
"uniform vec4 u_VertColor;\n"
"uniform int u_ColorGen;\n"
"uniform int u_AlphaGen;\n"
"\n"
"#if defined(USE_TCGEN)\n"
"uniform vec4 u_DiffuseTexMatrix;\n"
"uniform vec4 u_DiffuseTexOffTurb;\n"
"#endif\n"
"\n"
"#if defined(USE_TCGEN)\n"
"uniform int u_TCGen0;\n"
"uniform vec3 u_TCGen0Vector0;\n"
"uniform vec3 u_TCGen0Vector1;\n"
"uniform vec3 u_WorldPos;\n"
"#endif\n"
"\n"
"#if defined(USE_RGBAGEN)\n"
"vec4 CalcColor( vec3 a_Position, vec3 normal )\n"
"{\n"
"	vec4 color = u_VertColor * a_Color + u_BaseColor;\n"
"\n"
"	if (u_ColorGen == CGEN_LIGHTING_DIFFUSE)\n"
"	{\n"
"		float incoming = clamp(dot(normal, u_ModelLightDir), 0.0, 1.0);\n"
"\n"
"//		color.rgb = clamp(u_DirectedLight * incoming + u_AmbientLight, 0.0, 1.0);\n"
"	}\n"
"\n"
"	vec3 viewer = u_LocalViewOrigin - a_Position;\n"
"\n"
"	if (u_AlphaGen == AGEN_LIGHTING_SPECULAR)\n"
"	{\n"
"		vec3 lightDir = normalize(vec3(-960.0, 1980.0, 96.0) - a_Position);\n"
"		vec3 reflected = -reflect(lightDir, normal);\n"
"\n"
"		color.a = clamp(dot(reflected, normalize(viewer)), 0.0, 1.0);\n"
"		color.a *= color.a;\n"
"		color.a *= color.a;\n"
"	}\n"
"	else if (u_AlphaGen == AGEN_PORTAL)\n"
"	{\n"
"		color.a = clamp(length(viewer) / u_PortalRange, 0.0, 1.0);\n"
"	}\n"
"\n"
"	return color;\n"
"}\n"
"#endif\n"
"\n"
"#if defined(USE_TCMOD)\n"
"vec2 ModTexCoords( vec2 st, vec3 position, vec4 texMatrix, vec4 offTurb )\n"
"{\n"
"	float amplitude = offTurb.z;\n"
"	float phase = offTurb.w * 2.0 * M_PI;\n"
"	vec2 st2;\n"
"\n"
"	st2.x = st.x * texMatrix.x + ( st.y * texMatrix.z + offTurb.x );\n"
"	st2.y = st.x * texMatrix.y + ( st.y * texMatrix.w + offTurb.y );\n"
"\n"
"	vec2 offsetPos = vec2( position.x + position.z, position.y );\n"
"\n"
"	vec2 texOffset = sin( offsetPos * ( 2.0 * M_PI / 1024.0 ) + vec2( phase ) );\n"
"\n"
"	return st2 + texOffset * amplitude;\n"
"}\n"
"#endif\n"
"\n"
"#if defined(USE_TCGEN)\n"
"vec2 GenTexCoords( int TCGen, vec3 position, vec3 normal, vec3 TCGenVector0, vec3 TCGenVector1 )\n"
"{\n"
"	vec2 tex = texCoords[ a_TileID ];\n"
"\n"
"	if ( TCGen == TCGEN_LIGHTMAP ) {\n"
"		tex = texCoords[ a_TileID ].st;\n"
"	}\n"
"	else if ( TCGen == TCGEN_ENVIRONMENT_MAPPED ) {\n"
"		vec3 viewer = normalize( positions[ a_TileID ] - position );\n"
"		vec2 ref = reflect( viewer, normal ).yz;\n"
"		tex.s = ref.x * -0.5 + 0.5;\n"
"		tex.t = ref.y *  0.5 + 0.5;\n"
"	}\n"
"	else if ( TCGen == TCGEN_VECTOR ) {\n"
"		tex = vec2( dot( position, TCGenVector0 ), dot( position, TCGenVector1 ) );\n"
"	}\n"
"\n"
"	return tex;\n"
"}\n"
"#endif\n"
"\n"
"void main() {\n"
"	vec3 position = vec3( a_Position.xy, 0.0 );\n"
"#if defined(USE_TCGEN)\n"
"	vec2 texCoord = GenTexCoords( u_TCGen0, position, vec3( 0.0 ), u_TCGen0Vector0, u_TCGen0Vector1 );\n"
"#else\n"
"	vec2 texCoord = a_TexCoords;\n"
"#endif\n"
"\n"
"#if defined(USE_TCMOD)\n"
"	v_TexCoords = ModTexCoords( texCoord, position, u_DiffuseTexMatrix, u_DiffuseTexOffTurb );\n"
"#else\n"
"	v_TexCoords = texCoord;\n"
"#endif\n"
"	if ( u_ColorGen == CGEN_VERTEX ) {\n"
"		v_Color = vec4( 1.0 );\n"
"	} else {\n"
"		v_Color = u_VertColor * a_Color + u_BaseColor;\n"
"	}\n"
"	v_WorldPos = vec3( a_WorldPos.xy, 0.0 );\n"
"	v_Position = position;\n"
"\n"
"    gl_Position = u_ModelViewProjection * vec4( a_Position, 1.0 );\n"
"}\n"
;

const char *fallbackShader_image_sharpen =
"// -- Sharpening --\n"
"\n"
"uniform float u_SharpenAmount;\n"
"uniform vec2 u_ScreenSize;\n"
"\n"
"#define sharp_clamp 0.000  //[0.000 to 1.000] Limits maximum amount of sharpening a pixel recieves - Default is 0.035\n"
"\n"
"#define offset_bias 6.0  //[0.0 to 6.0] Offset bias adjusts the radius of the sampling pattern.\n"
"						 //I designed the pattern for offset_bias 1.0, but feel free to experiment.\n"
"\n"
"//#define CoefLuma vec3( 0.2126, 0.7152, 0.0722 )      // BT.709 & sRBG luma coefficient (Monitors and HD Television)\n"
"//#define CoefLuma vec3( 0.299, 0.587, 0.114 )       // BT.601 luma coefficient (SD Television)\n"
"#define CoefLuma vec3( 1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0 ) // Equal weight coefficient\n"
"\n"
"vec4 sharpenImage( sampler2D tex, vec2 pos )\n"
"{\n"
"	vec4 colorInput = texture( tex, pos );\n"
"\n"
"	vec3 ori = colorInput.rgb;\n"
"\n"
"	// -- Combining the strength and luma multipliers --\n"
"	vec3 sharp_strength_luma = CoefLuma * u_SharpenAmount; //I\'ll be combining even more multipliers with it later on\n"
"\n"
"	// -- Gaussian filter --\n"
"	//   [ .25, .50, .25]     [ 1 , 2 , 1 ]\n"
"	//   [ .50,   1, .50]  =  [ 2 , 4 , 2 ]\n"
" 	//   [ .25, .50, .25]     [ 1 , 2 , 1 ]\n"
"\n"
"\n"
"	float px = 1.0 / u_ScreenSize[0];\n"
"	float py = 1.0 / u_ScreenSize[1];\n"
"\n"
"	vec3 blur_ori = texture(tex, pos + vec2(px,-py) * 0.5 * offset_bias).rgb // South East\n"
"		+ texture(tex, pos + vec2(-px,-py) * 0.5 * offset_bias).rgb  // South West\n"
"		+ texture(tex, pos + vec2(px,py) * 0.5 * offset_bias).rgb // North East\n"
"		+ texture(tex, pos + vec2(-px,py) * 0.5 * offset_bias).rgb // North West\n"
"		* 0.25;  // ( /= 4) Divide by the number of texture fetches\n"
"\n"
"	// -- Calculate the sharpening --\n"
"	vec3 sharp = ori - blur_ori;  //Subtracting the blurred image from the original image\n"
"\n"
"	// -- Adjust strength of the sharpening and clamp it--\n"
"	vec4 sharp_strength_luma_clamp = vec4(sharp_strength_luma * (0.5 / sharp_clamp),0.5); //Roll part of the clamp into the dot\n"
"\n"
"	float sharp_luma = clamp((dot(vec4(sharp,1.0), sharp_strength_luma_clamp)), 0.0,1.0 ); //Calculate the luma, adjust the strength, scale up and clamp\n"
"	sharp_luma = (sharp_clamp * 2.0) * sharp_luma - sharp_clamp; //scale down\n"
"\n"
"\n"
"	// -- Combining the values to get the final sharpened pixel	--\n"
"\n"
"	colorInput.rgb = colorInput.rgb + sharp_luma;    // Add the sharpening to the input color.\n"
"	return clamp(colorInput, 0.0,1.0);\n"
"}\n"
;

const char *fallbackShader_blur_fp =
"#if !defined(GLSL_LEGACY)\n"
"layout( location = 0 ) out vec4 a_Color;\n"
"#endif\n"
"\n"
"in vec2 v_TexCoords;\n"
"\n"
"uniform sampler2D u_DiffuseMap;\n"
"uniform bool u_BlurHorizontal;\n"
"\n"
"void main() {\n"
"    const float weights[5] = float[]( 0.2270270270, 0.1945945946, 0.1216216216, 0.0540540541, 0.0162162162 );\n"
"    const vec2 texOffset = 1.0 / textureSize( u_DiffuseMap, 0 ); // gets size of single texel\n"
"    vec3 result = texture2D( u_DiffuseMap, v_TexCoords ).rgb * weights[0];\n"
"\n"
"    if ( result == vec3( 0.0, 0.0, 0.0 ) ) {\n"
"        discard;\n"
"    }\n"
"    if ( u_BlurHorizontal ) {\n"
"        for ( int i = 1; i < 5; ++i ) {\n"
"           result += texture2D( u_DiffuseMap, v_TexCoords + vec2( texOffset.x * i, 0.0 ) ).rgb * weights[i];\n"
"           result += texture2D( u_DiffuseMap, v_TexCoords - vec2( texOffset.x * i, 0.0 ) ).rgb * weights[i];\n"
"        }\n"
"    }\n"
"    else {\n"
"        for ( int i = 1; i < 5; ++i ) {\n"
"            result += texture2D( u_DiffuseMap, v_TexCoords + vec2( 0.0, texOffset.y * i ) ).rgb * weights[i];\n"
"            result += texture2D( u_DiffuseMap, v_TexCoords - vec2( 0.0, texOffset.y * i ) ).rgb * weights[i];\n"
"        }\n"
"    }\n"
"    a_Color = vec4( result, 1.0 );\n"
"}\n"
;
