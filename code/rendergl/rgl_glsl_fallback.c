
const char *fallbackShader_generic_fp =
"#if !defined(GLSL_LEGACY)\n"
"out vec4 a_Color;\n"
"#endif\n"
"\n"
"in vec2 v_TexCoords;\n"
"in vec3 v_FragPos;\n"
"in vec4 v_Color;\n"
"\n"
"uniform sampler2D u_DiffuseMap;\n"
"uniform float u_GammaAmount;\n"
"\n"
"#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"uniform vec4 u_SpecularScale;\n"
"uniform vec4 u_NormalScale;\n"
"uniform uint u_NumLights;\n"
"\n"
"uniform vec3 u_AmbientColor;\n"
"uniform float u_AmbientIntensity;\n"
"#endif\n"
"\n"
"#if defined(USE_NORMALMAP)\n"
"uniform sampler2D u_NormalMap;\n"
"#endif\n"
"\n"
"#if defined(USE_SPECULARMAP)\n"
"uniform sampler2D u_SpecularMap;\n"
"#endif\n"
"\n"
"#if defined(USE_SHADOWMAP)\n"
"uniform sampler2D u_ShadowMap;\n"
"#endif\n"
"\n"
"uniform int u_AlphaTest;\n"
"\n"
"float CalcLightAttenuation(float point, float normDist)\n"
"{\n"
"	// zero light at 1.0, approximating q3 style\n"
"	// also don't attenuate directional light\n"
"	float attenuation = (0.5 * normDist - 1.5) * point + 1.0;\n"
"\n"
"	// clamp attenuation\n"
"	#if defined(NO_LIGHT_CLAMP)\n"
"	attenuation = max(attenuation, 0.0);\n"
"	#else\n"
"	attenuation = clamp(attenuation, 0.0, 1.0);\n"
"	#endif\n"
"\n"
"	return attenuation;\n"
"}\n"
"\n"
"vec3 CalcDiffuse(vec3 diffuseAlbedo, float NH, float EH, float roughness)\n"
"{\n"
"#if defined(USE_BURLEY)\n"
"	// modified from https://disney-animation.s3.amazonaws.com/library/s2012_pbs_disney_brdf_notes_v2.pdf\n"
"	float fd90 = -0.5 + EH * EH * roughness;\n"
"	float burley = 1.0 + fd90 * 0.04 / NH;\n"
"	burley *= burley;\n"
"	return diffuseAlbedo * burley;\n"
"#else\n"
"	return diffuseAlbedo;\n"
"#endif\n"
"}\n"
"\n"
"void applyLighting() {\n"
"#if defined(USE_SPECULARMAP)\n"
"    a_Color.rgb += texture( u_SpecularMap, v_TexCoords ).rgb;\n"
"#endif\n"
"#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"    if ( u_NumLights == uint( 0 ) )\n"
"#endif\n"
"	{\n"
"        a_Color.rgb += texture2D( u_DiffuseMap, v_TexCoords ).rgb;\n"
"    }\n"
"}\n"
"\n"
"void AmbientLight() {\n"
"//    vec3 color = u_AmbientColor + u_AmbientIntensity;\n"
"}\n"
"\n"
"void main() {\n"
"    a_Color = texture2D( u_DiffuseMap, v_TexCoords );\n"
"\n"
"#if defined(USE_HDR)\n"
"	// reinhard tone mapping\n"
"	a_Color.rgb /= ( a_Color.rgb + vec3( 1.0 ) );\n"
"#endif\n"
"	a_Color.rgb = pow( a_Color.rgb, vec3( 1.0 / u_GammaAmount ) );\n"
"}\n"
;

const char *fallbackShader_imgui_fp =
"#if !defined(GLSL_LEGACY)\n"
"out vec4 a_Color;\n"
"#endif\n"
"\n"
"in vec2 v_TexCoord;\n"
"in vec4 v_Color;\n"
"\n"
"uniform sampler2D u_DiffuseMap;\n"
"uniform float u_GammaAmount;\n"
"\n"
"#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"uniform vec4 u_SpecularScale;\n"
"uniform vec4 u_NormalScale;\n"
"\n"
"uniform vec3 u_AmbientColor;\n"
"uniform float u_AmbientIntensity;\n"
"#endif\n"
"\n"
"#if defined(USE_NORMALMAP)\n"
"uniform sampler2D u_NormalMap;\n"
"#endif\n"
"\n"
"#if defined(USE_SPECULARMAP)\n"
"uniform sampler2D u_SpecularMap;\n"
"#endif\n"
"\n"
"#if defined(USE_SHADOWMAP)\n"
"uniform sampler2D u_ShadowMap;\n"
"#endif\n"
"\n"
"uniform int u_AlphaTest;\n"
"\n"
"float CalcLightAttenuation(float point, float normDist)\n"
"{\n"
"	// zero light at 1.0, approximating q3 style\n"
"	// also don't attenuate directional light\n"
"	float attenuation = (0.5 * normDist - 1.5) * point + 1.0;\n"
"\n"
"	// clamp attenuation\n"
"	#if defined(NO_LIGHT_CLAMP)\n"
"	attenuation = max(attenuation, 0.0);\n"
"	#else\n"
"	attenuation = clamp(attenuation, 0.0, 1.0);\n"
"	#endif\n"
"\n"
"	return attenuation;\n"
"}\n"
"\n"
"vec3 CalcDiffuse(vec3 diffuseAlbedo, float NH, float EH, float roughness)\n"
"{\n"
"#if defined(USE_BURLEY)\n"
"	// modified from https://disney-animation.s3.amazonaws.com/library/s2012_pbs_disney_brdf_notes_v2.pdf\n"
"	float fd90 = -0.5 + EH * EH * roughness;\n"
"	float burley = 1.0 + fd90 * 0.04 / NH;\n"
"	burley *= burley;\n"
"	return diffuseAlbedo * burley;\n"
"#else\n"
"	return diffuseAlbedo;\n"
"#endif\n"
"}\n"
"\n"
"void main() {\n"
"    a_Color = v_Color * texture2D( u_DiffuseMap, v_TexCoord );\n"
"\n"
"#if defined(USE_HDR)\n"
"	// reinhard tone mapping\n"
"	a_Color.rgb /= ( a_Color.rgb + vec3( 1.0 ) );\n"
"#endif\n"
"    a_Color.rgb = pow( a_Color.rgb, vec3( 1.0 / u_GammaAmount ) );\n"
"}\n"
;

const char *fallbackShader_bokeh_vp =
"in vec3 a_Position;\n"
"in vec4 a_TexCoord0;\n"
"\n"
"uniform mat4 u_ModelViewProjection;\n"
"\n"
"out vec2 v_TexCoords;\n"
"\n"
"void main() {\n"
"	gl_Position = u_ModelViewProjection * vec4( a_Position, 1.0 );\n"
"	v_TexCoords = a_TexCoord0.st;\n"
"}\n"
;

const char *fallbackShader_depthblur_fp =
"#if !defined(GLSL_LEGACY)\n"
"out vec4 a_Color;\n"
"#endif\n"
"\n"
"uniform sampler2D u_ScreenImageMap;\n"
"uniform sampler2D u_ScreenDepthMap;\n"
"\n"
"uniform vec4 u_ViewInfo; // zfar / znear, zfar, 1/width, 1/height\n"
"varying vec2 v_ScreenTex;\n"
"\n"
"//float gauss[8] = float[8](0.17, 0.17, 0.16, 0.14, 0.12, 0.1, 0.08, 0.06);\n"
"//float gauss[5] = float[5](0.30, 0.23, 0.097, 0.024, 0.0033);\n"
"//float gauss[4] = float[4](0.40, 0.24, 0.054, 0.0044);\n"
"//float gauss[3] = float[3](0.60, 0.19, 0.0066);\n"
"#define BLUR_SIZE 4\n"
"\n"
"#if !defined(USE_DEPTH)\n"
"//#define USE_GAUSS\n"
"#endif\n"
"\n"
"float getLinearDepth(sampler2D depthMap, const vec2 tex, const float zFarDivZNear) {\n"
"	float sampleZDivW = texture2D(depthMap, tex).r;\n"
"	return 1.0 / mix(zFarDivZNear, 1.0, sampleZDivW);\n"
"}\n"
"\n"
"vec4 depthGaussian1D(sampler2D imageMap, sampler2D depthMap, vec2 tex, float zFarDivZNear, float zFar, vec2 scale)\n"
"{\n"
"	float gauss[4];\n"
"\n"
"	gauss[0] = 0.40;\n"
"	gauss[1] = 0.24;\n"
"	gauss[2] = 0.054;\n"
"	gauss[3] = 0.0044;\n"
"\n"
"#if defined(USE_DEPTH)\n"
"	float depthCenter = getLinearDepth(depthMap, tex, zFarDivZNear);\n"
"	vec2 slope = vec2(dFdx(depthCenter), dFdy(depthCenter)) / vec2(dFdx(tex.x), dFdy(tex.y));\n"
"	scale /= clamp(zFarDivZNear * depthCenter / 32.0, 1.0, 2.0);\n"
"#endif\n"
"\n"
"#if defined(USE_HORIZONTAL_BLUR)\n"
"	vec2 direction = vec2(scale.x * 2.0, 0.0);\n"
"	vec2 nudge = vec2(0.0, scale.y * 0.5);\n"
"#else // if defined(USE_VERTICAL_BLUR)\n"
"	vec2 direction = vec2(0.0, scale.y * 2.0);\n"
"	vec2 nudge = vec2(-scale.x * 0.5, 0.0);\n"
"#endif\n"
"\n"
"#if defined(USE_GAUSS)\n"
"	vec4 result = texture2D(imageMap, tex) * gauss[0];\n"
"	float total = gauss[0];\n"
"#else\n"
"	vec4 result = texture2D(imageMap, tex);\n"
"	float total = 1.0;\n"
"#endif\n"
"\n"
"	float zLimit = 5.0 / zFar;\n"
"	int i, j;\n"
"	for (i = 0; i < 2; i++)\n"
"	{\n"
"		for (j = 1; j < BLUR_SIZE; j++)\n"
"		{\n"
"			vec2 offset = direction * (float(j) - 0.25) + nudge;\n"
"#if defined(USE_DEPTH)\n"
"			float depthSample = getLinearDepth(depthMap, tex + offset, zFarDivZNear);\n"
"			float depthExpected = depthCenter + dot(slope, offset);\n"
"			float useSample = float(abs(depthSample - depthExpected) < zLimit);\n"
"#else\n"
"			float useSample = 1.0;\n"
"#endif\n"
"#if defined(USE_GAUSS)\n"
"			result += texture2D(imageMap, tex + offset) * (gauss[j] * useSample);\n"
"			total += gauss[j] * useSample;\n"
"#else\n"
"			result += texture2D(imageMap, tex + offset) * useSample;\n"
"			total += useSample;\n"
"#endif\n"
"			nudge = -nudge;\n"
"		}\n"
"\n"
"		direction = -direction;\n"
"		nudge = -nudge;\n"
"	}\n"
"\n"
"	return result / total;\n"
"}\n"
"\n"
"void main() {\n"
"	a_Color = depthGaussian1D(u_ScreenImageMap, u_ScreenDepthMap, v_ScreenTex, u_ViewInfo.x, u_ViewInfo.y, u_ViewInfo.zw);\n"
"}\n"
;

const char *fallbackShader_bokeh_fp =
"#if !defined(GLSL_LEGACY)\n"
"out vec4 a_Color;\n"
"#endif\n"
"\n"
"uniform sampler2D u_TextureMap;\n"
"\n"
"uniform vec4 u_Color;\n"
"uniform vec2 u_InvTexRes;\n"
"\n"
"in vec2 v_TexCoords;\n"
"\n"
"void main()\n"
"{\n"
"	vec4 color;\n"
"	vec2 tc;\n"
"\n"
"#if 0\n"
"	float c[7];\n"
"\n"
"	c[0] = 1.0;\n"
"	c[1] = 0.9659258263;\n"
"	c[2] = 0.8660254038;\n"
"	c[3] = 0.7071067812;\n"
"	c[4] = 0.5;\n"
"	c[5] = 0.2588190451;\n"
"	c[6] = 0.0;\n"
"\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[0],  c[6]);  color =  texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[1],  c[5]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[2],  c[4]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[3],  c[3]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[4],  c[2]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[5],  c[1]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[6],  c[0]);  color += texture2D(u_TextureMap, tc);\n"
"\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[1], -c[5]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[2], -c[4]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[3], -c[3]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[4], -c[2]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[5], -c[1]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[6], -c[0]);  color += texture2D(u_TextureMap, tc);\n"
"\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( -c[0],  c[6]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( -c[1],  c[5]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( -c[2],  c[4]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( -c[3],  c[3]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( -c[4],  c[2]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( -c[5],  c[1]);  color += texture2D(u_TextureMap, tc);\n"
"\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( -c[1], -c[5]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( -c[2], -c[4]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( -c[3], -c[3]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( -c[4], -c[2]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( -c[5], -c[1]);  color += texture2D(u_TextureMap, tc);\n"
"\n"
"	a_Color = color * 0.04166667 * u_Color;\n"
"#endif\n"
"\n"
"	float c[5];\n"
"\n"
"	c[0] = 1.0;\n"
"	c[1] = 0.9238795325;\n"
"	c[2] = 0.7071067812;\n"
"	c[3] = 0.3826834324;\n"
"	c[4] = 0.0;\n"
"\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[0],  c[4]);  color =  texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[1],  c[3]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[2],  c[2]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[3],  c[1]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[4],  c[0]);  color += texture2D(u_TextureMap, tc);\n"
"\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[1], -c[3]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[2], -c[2]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[3], -c[1]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(  c[4], -c[0]);  color += texture2D(u_TextureMap, tc);\n"
"\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( -c[0],  c[4]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( -c[1],  c[3]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( -c[2],  c[2]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( -c[3],  c[1]);  color += texture2D(u_TextureMap, tc);\n"
"\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( -c[1], -c[3]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( -c[2], -c[2]);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( -c[3], -c[1]);  color += texture2D(u_TextureMap, tc);\n"
"\n"
"	a_Color = color * 0.0625 * u_Color;\n"
"}\n"
;

const char *fallbackShader_calclevels4x_fp =
"#if !defined(GLSL_LEGACY)\n"
"out vec4 a_Color;\n"
"#endif\n"
"\n"
"uniform sampler2D u_TextureMap;\n"
"\n"
"uniform vec4 u_Color;\n"
"uniform vec2 u_InvTexRes;\n"
"\n"
"varying vec2 v_TexCoords;\n"
"\n"
"const vec3 LUMINANCE_VECTOR = vec3(0.2125, 0.7154, 0.0721); //vec3(0.299, 0.587, 0.114);\n"
"\n"
"vec3 GetValues( vec2 offset, vec3 current )\n"
"{\n"
"	vec2 tc = v_TexCoords + u_InvTexRes * offset;\n"
"	vec3 minAvgMax = texture2D( u_TextureMap, tc ).rgb;\n"
"\n"
"#ifdef FIRST_PASS\n"
"  #if defined(USE_PBR)\n"
"	minAvgMax *= minAvgMax;\n"
"  #endif\n"
"\n"
"	float lumi = max(dot(LUMINANCE_VECTOR, minAvgMax), 0.000001);\n"
"	float loglumi = clamp(log2(lumi), -10.0, 10.0);\n"
"	minAvgMax = vec3(loglumi * 0.05 + 0.5);\n"
"#endif\n"
"\n"
"	return vec3(min(current.x, minAvgMax.x), current.y + minAvgMax.y, max(current.z, minAvgMax.z));\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"	vec3 current = vec3(1.0, 0.0, 0.0);\n"
"\n"
"#ifdef FIRST_PASS\n"
"	current = GetValues(vec2( 0.0,  0.0), current);\n"
"#else\n"
"	current = GetValues(vec2(-1.5, -1.5), current);\n"
"	current = GetValues(vec2(-0.5, -1.5), current);\n"
"	current = GetValues(vec2( 0.5, -1.5), current);\n"
"	current = GetValues(vec2( 1.5, -1.5), current);\n"
"\n"
"	current = GetValues(vec2(-1.5, -0.5), current);\n"
"	current = GetValues(vec2(-0.5, -0.5), current);\n"
"	current = GetValues(vec2( 0.5, -0.5), current);\n"
"	current = GetValues(vec2( 1.5, -0.5), current);\n"
"\n"
"	current = GetValues(vec2(-1.5,  0.5), current);\n"
"	current = GetValues(vec2(-0.5,  0.5), current);\n"
"	current = GetValues(vec2( 0.5,  0.5), current);\n"
"	current = GetValues(vec2( 1.5,  0.5), current);\n"
"\n"
"	current = GetValues(vec2(-1.5,  1.5), current);\n"
"	current = GetValues(vec2(-0.5,  1.5), current);\n"
"	current = GetValues(vec2( 0.5,  1.5), current);\n"
"	current = GetValues(vec2( 1.5,  1.5), current);\n"
"\n"
"	current.y *= 0.0625;\n"
"#endif\n"
"\n"
"	a_Color = vec4(current, 1.0);\n"
"}\n"
;

const char *fallbackShader_tile_vp =
"in vec3 a_Position;\n"
"in vec2 a_TexCoords;\n"
"in vec4 a_Color;\n"
"in vec3 a_WorldPos;\n"
"\n"
"out vec2 v_TexCoords;\n"
"out vec3 v_FragPos;\n"
"out vec4 v_Color;\n"
"out vec3 v_WorldPos;\n"
"\n"
"uniform mat4 u_ModelViewProjection;\n"
"uniform vec4 u_BaseColor;\n"
"uniform vec4 u_VertColor;\n"
"\n"
"uniform mat4 u_ModelMatrix;\n"
"\n"
"#if defined(USE_RGBAGEN)\n"
"uniform int u_ColorGen;\n"
"uniform int u_AlphaGen;\n"
"uniform vec3 u_DirectedLight;\n"
"#endif\n"
"\n"
"#if defined(USE_TCGEN)\n"
"uniform vec4 u_DiffuseTexMatrix;\n"
"uniform vec4 u_DiffuseTexOffTurb;\n"
"#endif\n"
"\n"
"#if defined(USE_TCGEN)\n"
"uniform int u_TCGen0;\n"
"uniform vec3 u_TCGen0Vector0;\n"
"uniform vec3 u_TCGen0Vector1;\n"
"uniform vec3 u_WorldPos;\n"
"#endif\n"
"\n"
"#if defined(USE_RGBAGEN)\n"
"vec4 CalcColor(vec3 position, vec3 normal)\n"
"{\n"
"	vec4 color = u_VertColor * a_Color + u_BaseColor;\n"
"\n"
"	if (u_ColorGen == CGEN_LIGHTING_DIFFUSE)\n"
"	{\n"
"		float incoming = clamp(dot(normal, u_ModelLightDir), 0.0, 1.0);\n"
"\n"
"//		color.rgb = clamp(u_DirectedLight * incoming + u_AmbientLight, 0.0, 1.0);\n"
"	}\n"
"\n"
"	vec3 viewer = u_LocalViewOrigin - position;\n"
"\n"
"	if (u_AlphaGen == AGEN_LIGHTING_SPECULAR)\n"
"	{\n"
"		vec3 lightDir = normalize(vec3(-960.0, 1980.0, 96.0) - position);\n"
"		vec3 reflected = -reflect(lightDir, normal);\n"
"\n"
"		color.a = clamp(dot(reflected, normalize(viewer)), 0.0, 1.0);\n"
"		color.a *= color.a;\n"
"		color.a *= color.a;\n"
"	}\n"
"	else if (u_AlphaGen == AGEN_PORTAL)\n"
"	{\n"
"		color.a = clamp(length(viewer) / u_PortalRange, 0.0, 1.0);\n"
"	}\n"
"\n"
"	return color;\n"
"}\n"
"#endif\n"
"\n"
"#if defined(USE_TCMOD)\n"
"vec2 ModTexCoords( vec2 st, vec3 position, vec4 texMatrix, vec4 offTurb )\n"
"{\n"
"	float amplitude = offTurb.z;\n"
"	float phase = offTurb.w * 2.0 * M_PI;\n"
"	vec2 st2;\n"
"\n"
"	st2.x = st.x * texMatrix.x + ( st.y * texMatrix.z + offTurb.x );\n"
"	st2.y = st.x * texMatrix.y + ( st.y * texMatrix.w + offTurb.y );\n"
"\n"
"	vec2 offsetPos = vec2( position.x + position.z, position.y );\n"
"\n"
"	vec2 texOffset = sin( offsetPos * ( 2.0 * M_PI / 1024.0 ) + vec2( phase ) );\n"
"\n"
"	return st2 + texOffset * amplitude;\n"
"}\n"
"#endif\n"
"\n"
"float CalcLightAttenuation( float point, float normDist )\n"
"{\n"
"	// zero light at 1.0, approximating q3 style\n"
"	// also don't attenuate directional light\n"
"	float attenuation = ( 0.5 * normDist - 1.5 ) * point + 1.0;\n"
"\n"
"	// clamp attenuation\n"
"#if defined(NO_LIGHT_CLAMP)\n"
"	attenuation = max( attenuation, 0.0 );\n"
"#else\n"
"	attenuation = clamp( attenuation, 0.0, 1.0 );\n"
"#endif\n"
"\n"
"	return attenuation;\n"
"}\n"
"\n"
"#if defined(USE_TCGEN)\n"
"vec2 GenTexCoords( int TCGen, vec3 position, vec3 normal, vec3 TCGenVector0, vec3 TCGenVector1 )\n"
"{\n"
"	vec2 tex = a_TexCoords;\n"
"\n"
"	if ( TCGen == TCGEN_LIGHTMAP ) {\n"
"	//	tex = a_TexCoord1.st;\n"
"	}\n"
"	else if ( TCGen == TCGEN_ENVIRONMENT_MAPPED ) {\n"
"		vec3 viewer = normalize( u_WorldPos - position );\n"
"		vec2 ref = reflect( viewer, normal ).yz;\n"
"		tex.s = ref.x * -0.5 + 0.5;\n"
"		tex.t = ref.y *  0.5 + 0.5;\n"
"	}\n"
"	else if ( TCGen == TCGEN_VECTOR ) {\n"
"		tex = vec2( dot( position, TCGenVector0 ), dot( position, TCGenVector1 ) );\n"
"	}\n"
"\n"
"	return tex;\n"
"}\n"
"#endif\n"
"\n"
"void main()\n"
"{\n"
"//\n"
"//#if defined(USE_TCGEN)\n"
"//	vec2 texCoords = GenTexCoords( u_TCGen0, a_Position, vec3( 0.0 ), u_TCGen0Vector0, u_TCGen0Vector1 );\n"
"//#else\n"
"//	vec2 texCoords = a_TexCoords;\n"
"//#endif\n"
"//\n"
"//#if defined(USE_TCMOD)\n"
"//	v_TexCoords = ModTexCoords( texCoords, a_Position, u_DiffuseTexMatrix, u_DiffuseTexOffTurb );\n"
"//#else\n"
"//	v_TexCoords = texCoords;\n"
"//#endif\n"
"    v_Color = a_Color;\n"
"	v_TexCoords = a_TexCoords;\n"
"	v_WorldPos = a_WorldPos;\n"
"\n"
"	v_FragPos = vec4( u_ModelViewProjection * vec4( a_Position, 1.0 ) ).xyz;\n"
"\n"
"    gl_Position = u_ModelViewProjection * vec4( a_Position, 1.0 );\n"
"}\n"
;

const char *fallbackShader_down4x_vp =
"in vec3 a_Position;\n"
"in vec4 a_TexCoord0;\n"
"\n"
"uniform mat4 u_ModelViewProjection;\n"
"\n"
"out vec2 v_TexCoords;\n"
"\n"
"void main() {\n"
"	gl_Position = u_ModelViewProjection * vec4(a_Position, 1.0);\n"
"	v_TexCoords = a_TexCoord0.st;\n"
"}\n"
;

const char *fallbackShader_tonemap_vp =
"in vec3 a_Position;\n"
"in vec4 a_TexCoord0;\n"
"\n"
"uniform mat4 u_ModelViewProjection;\n"
"uniform vec3 u_ToneMinAvgMaxLinear;\n"
"\n"
"out vec2 v_TexCoords;\n"
"out float v_InvWhite;\n"
"\n"
"float FilmicTonemap(float x)\n"
"{\n"
"	const float SS  = 0.22; // Shoulder Strength\n"
"	const float LS  = 0.30; // Linear Strength\n"
"	const float LA  = 0.10; // Linear Angle\n"
"	const float TS  = 0.20; // Toe Strength\n"
"	const float TAN = 0.01; // Toe Angle Numerator\n"
"	const float TAD = 0.30; // Toe Angle Denominator\n"
"\n"
"	return ((x*(SS*x+LA*LS)+TS*TAN)/(x*(SS*x+LS)+TS*TAD)) - TAN/TAD;\n"
"}\n"
"\n"
"void main() {\n"
"	gl_Position = u_ModelViewProjection * vec4(a_Position, 1.0);\n"
"	v_TexCoords = a_TexCoord0.st;\n"
"	v_InvWhite = 1.0 / FilmicTonemap(u_ToneMinAvgMaxLinear.z - u_ToneMinAvgMaxLinear.x);\n"
"}\n"
;

const char *fallbackShader_ssao_vp =
"in vec4 a_Position;\n"
"in vec4 a_TexCoord0;\n"
"\n"
"out vec2 v_ScreenTex;\n"
"\n"
"void main() {\n"
"	gl_Position = a_Position;\n"
"	v_ScreenTex = a_TexCoord0.xy;\n"
"	//vec2 screenCoords = gl_Position.xy / gl_Position.w;\n"
"	//var_ScreenTex = screenCoords * 0.5 + 0.5;\n"
"}\n"
;

const char *fallbackShader_down4x_fp =
"#if !defined(GLSL_LEGACY)\n"
"out vec4 a_Color;\n"
"#endif\n"
"\n"
"uniform sampler2D u_TextureMap;\n"
"\n"
"uniform vec2 u_InvTexRes;\n"
"in vec2 v_TexCoords;\n"
"\n"
"void main()\n"
"{\n"
"	vec4 color;\n"
"	vec2 tc;\n"
"\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(-1.5, -1.5);  color  = texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(-0.5, -1.5);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( 0.5, -1.5);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( 1.5, -1.5);  color += texture2D(u_TextureMap, tc);\n"
"\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(-1.5, -0.5); color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(-0.5, -0.5); color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( 0.5, -0.5); color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( 1.5, -0.5); color += texture2D(u_TextureMap, tc);\n"
"\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(-1.5,  0.5); color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(-0.5,  0.5); color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( 0.5,  0.5); color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( 1.5,  0.5); color += texture2D(u_TextureMap, tc);\n"
"\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(-1.5,  1.5);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2(-0.5,  1.5);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( 0.5,  1.5);  color += texture2D(u_TextureMap, tc);\n"
"	tc = v_TexCoords + u_InvTexRes * vec2( 1.5,  1.5);  color += texture2D(u_TextureMap, tc);\n"
"\n"
"	color *= 0.0625;\n"
"\n"
"	a_Color = color;\n"
"}\n"
;

const char *fallbackShader_generic_vp =
"in vec3 a_Position;\n"
"in vec2 a_TexCoords;\n"
"in vec4 a_Color;\n"
"\n"
"out vec2 v_TexCoords;\n"
"out vec3 v_FragPos;\n"
"out vec4 v_Color;\n"
"\n"
"uniform mat4 u_ModelViewProjection;\n"
"uniform vec4 u_BaseColor;\n"
"uniform vec4 u_VertColor;\n"
"\n"
"uniform mat4 u_ModelMatrix;\n"
"\n"
"#if defined(USE_RGBAGEN)\n"
"uniform int u_ColorGen;\n"
"uniform int u_AlphaGen;\n"
"uniform vec3 u_DirectedLight;\n"
"#endif\n"
"\n"
"#if defined(USE_TCGEN)\n"
"uniform vec4 u_DiffuseTexMatrix;\n"
"uniform vec4 u_DiffuseTexOffTurb;\n"
"#endif\n"
"\n"
"#if defined(USE_TCGEN)\n"
"uniform int u_TCGen0;\n"
"uniform vec3 u_TCGen0Vector0;\n"
"uniform vec3 u_TCGen0Vector1;\n"
"uniform vec3 u_WorldPos;\n"
"#endif\n"
"\n"
"#if defined(USE_RGBAGEN)\n"
"vec4 CalcColor(vec3 position, vec3 normal)\n"
"{\n"
"	vec4 color = u_VertColor * a_Color + u_BaseColor;\n"
"\n"
"	if (u_ColorGen == CGEN_LIGHTING_DIFFUSE)\n"
"	{\n"
"		float incoming = clamp(dot(normal, u_ModelLightDir), 0.0, 1.0);\n"
"\n"
"//		color.rgb = clamp(u_DirectedLight * incoming + u_AmbientLight, 0.0, 1.0);\n"
"	}\n"
"\n"
"	vec3 viewer = u_LocalViewOrigin - position;\n"
"\n"
"	if (u_AlphaGen == AGEN_LIGHTING_SPECULAR)\n"
"	{\n"
"		vec3 lightDir = normalize(vec3(-960.0, 1980.0, 96.0) - position);\n"
"		vec3 reflected = -reflect(lightDir, normal);\n"
"\n"
"		color.a = clamp(dot(reflected, normalize(viewer)), 0.0, 1.0);\n"
"		color.a *= color.a;\n"
"		color.a *= color.a;\n"
"	}\n"
"	else if (u_AlphaGen == AGEN_PORTAL)\n"
"	{\n"
"		color.a = clamp(length(viewer) / u_PortalRange, 0.0, 1.0);\n"
"	}\n"
"\n"
"	return color;\n"
"}\n"
"#endif\n"
"\n"
"#if defined(USE_TCMOD)\n"
"vec2 ModTexCoords( vec2 st, vec3 position, vec4 texMatrix, vec4 offTurb )\n"
"{\n"
"	float amplitude = offTurb.z;\n"
"	float phase = offTurb.w * 2.0 * M_PI;\n"
"	vec2 st2;\n"
"\n"
"	st2.x = st.x * texMatrix.x + ( st.y * texMatrix.z + offTurb.x );\n"
"	st2.y = st.x * texMatrix.y + ( st.y * texMatrix.w + offTurb.y );\n"
"\n"
"	vec2 offsetPos = vec2( position.x + position.z, position.y );\n"
"\n"
"	vec2 texOffset = sin( offsetPos * ( 2.0 * M_PI / 1024.0 ) + vec2( phase ) );\n"
"\n"
"	return st2 + texOffset * amplitude;\n"
"}\n"
"#endif\n"
"\n"
"float CalcLightAttenuation( float point, float normDist )\n"
"{\n"
"	// zero light at 1.0, approximating q3 style\n"
"	// also don't attenuate directional light\n"
"	float attenuation = ( 0.5 * normDist - 1.5 ) * point + 1.0;\n"
"\n"
"	// clamp attenuation\n"
"#if defined(NO_LIGHT_CLAMP)\n"
"	attenuation = max( attenuation, 0.0 );\n"
"#else\n"
"	attenuation = clamp( attenuation, 0.0, 1.0 );\n"
"#endif\n"
"\n"
"	return attenuation;\n"
"}\n"
"\n"
"#if defined(USE_TCGEN)\n"
"vec2 GenTexCoords( int TCGen, vec3 position, vec3 normal, vec3 TCGenVector0, vec3 TCGenVector1 )\n"
"{\n"
"	vec2 tex = a_TexCoords;\n"
"\n"
"	if ( TCGen == TCGEN_LIGHTMAP ) {\n"
"	//	tex = a_TexCoord1.st;\n"
"	}\n"
"	else if ( TCGen == TCGEN_ENVIRONMENT_MAPPED ) {\n"
"		vec3 viewer = normalize( u_WorldPos - position );\n"
"		vec2 ref = reflect( viewer, normal ).yz;\n"
"		tex.s = ref.x * -0.5 + 0.5;\n"
"		tex.t = ref.y *  0.5 + 0.5;\n"
"	}\n"
"	else if ( TCGen == TCGEN_VECTOR ) {\n"
"		tex = vec2( dot( position, TCGenVector0 ), dot( position, TCGenVector1 ) );\n"
"	}\n"
"\n"
"	return tex;\n"
"}\n"
"#endif\n"
"\n"
"void main()\n"
"{\n"
"	v_Color = a_Color;\n"
"//\n"
"//#if defined(USE_TCGEN)\n"
"//	vec2 texCoords = GenTexCoords( u_TCGen0, a_Position, vec3( 0.0 ), u_TCGen0Vector0, u_TCGen0Vector1 );\n"
"//#else\n"
"//	vec2 texCoords = a_TexCoords;\n"
"//#endif\n"
"//\n"
"//#if defined(USE_TCMOD)\n"
"//	v_TexCoords = ModTexCoords( texCoords, a_Position, u_DiffuseTexMatrix, u_DiffuseTexOffTurb );\n"
"//#else\n"
"//	v_TexCoords = texCoords;\n"
"//#endif\n"
"	v_TexCoords = a_TexCoords;\n"
"\n"
"	v_FragPos = vec4( u_ModelViewProjection * vec4( a_Position, 1.0 ) ).xyz;\n"
"\n"
"    gl_Position = u_ModelViewProjection * vec4( a_Position, 1.0 );\n"
"}\n"
;

const char *fallbackShader_imgui_vp =
"in vec3 a_Position;\n"
"in vec2 a_TexCoord;\n"
"in vec4 a_Color;\n"
"\n"
"uniform mat4 u_ModelViewProjection;\n"
"\n"
"out vec2 v_TexCoord;\n"
"out vec4 v_Color;\n"
"\n"
"uniform vec4 u_BaseColor;\n"
"uniform vec4 u_VertColor;\n"
"\n"
"uniform mat4 u_ModelMatrix;\n"
"\n"
"#if defined(USE_RGBAGEN)\n"
"uniform int u_ColorGen;\n"
"uniform int u_AlphaGen;\n"
"uniform vec3 u_DirectedLight;\n"
"#endif\n"
"\n"
"#if defined(USE_TCGEN)\n"
"uniform vec4 u_DiffuseTexMatrix;\n"
"uniform vec4 u_DiffuseTexOffTurb;\n"
"#endif\n"
"\n"
"#if defined(USE_TCGEN)\n"
"uniform int u_TCGen0;\n"
"uniform vec3 u_TCGen0Vector0;\n"
"uniform vec3 u_TCGen0Vector1;\n"
"uniform vec3 u_WorldPos;\n"
"#endif\n"
"\n"
"#if defined(USE_RGBAGEN)\n"
"vec4 CalcColor(vec3 position, vec3 normal)\n"
"{\n"
"	vec4 color = u_VertColor * a_Color + u_BaseColor;\n"
"\n"
"	if (u_ColorGen == CGEN_LIGHTING_DIFFUSE)\n"
"	{\n"
"		float incoming = clamp(dot(normal, u_ModelLightDir), 0.0, 1.0);\n"
"\n"
"//		color.rgb = clamp(u_DirectedLight * incoming + u_AmbientLight, 0.0, 1.0);\n"
"	}\n"
"\n"
"	vec3 viewer = u_LocalViewOrigin - position;\n"
"\n"
"	if (u_AlphaGen == AGEN_LIGHTING_SPECULAR)\n"
"	{\n"
"		vec3 lightDir = normalize(vec3(-960.0, 1980.0, 96.0) - position);\n"
"		vec3 reflected = -reflect(lightDir, normal);\n"
"\n"
"		color.a = clamp(dot(reflected, normalize(viewer)), 0.0, 1.0);\n"
"		color.a *= color.a;\n"
"		color.a *= color.a;\n"
"	}\n"
"	else if (u_AlphaGen == AGEN_PORTAL)\n"
"	{\n"
"		color.a = clamp(length(viewer) / u_PortalRange, 0.0, 1.0);\n"
"	}\n"
"\n"
"	return color;\n"
"}\n"
"#endif\n"
"\n"
"#if defined(USE_TCMOD)\n"
"vec2 ModTexCoords( vec2 st, vec3 position, vec4 texMatrix, vec4 offTurb )\n"
"{\n"
"	float amplitude = offTurb.z;\n"
"	float phase = offTurb.w * 2.0 * M_PI;\n"
"	vec2 st2;\n"
"\n"
"	st2.x = st.x * texMatrix.x + ( st.y * texMatrix.z + offTurb.x );\n"
"	st2.y = st.x * texMatrix.y + ( st.y * texMatrix.w + offTurb.y );\n"
"\n"
"	vec2 offsetPos = vec2( position.x + position.z, position.y );\n"
"\n"
"	vec2 texOffset = sin( offsetPos * ( 2.0 * M_PI / 1024.0 ) + vec2( phase ) );\n"
"\n"
"	return st2 + texOffset * amplitude;\n"
"}\n"
"#endif\n"
"\n"
"float CalcLightAttenuation( float point, float normDist )\n"
"{\n"
"	// zero light at 1.0, approximating q3 style\n"
"	// also don't attenuate directional light\n"
"	float attenuation = ( 0.5 * normDist - 1.5 ) * point + 1.0;\n"
"\n"
"	// clamp attenuation\n"
"#if defined(NO_LIGHT_CLAMP)\n"
"	attenuation = max( attenuation, 0.0 );\n"
"#else\n"
"	attenuation = clamp( attenuation, 0.0, 1.0 );\n"
"#endif\n"
"\n"
"	return attenuation;\n"
"}\n"
"\n"
"#if defined(USE_TCGEN)\n"
"vec2 GenTexCoords( int TCGen, vec3 position, vec3 normal, vec3 TCGenVector0, vec3 TCGenVector1 )\n"
"{\n"
"	vec2 tex = a_TexCoord;\n"
"\n"
"	if ( TCGen == TCGEN_LIGHTMAP ) {\n"
"	//	tex = a_TexCoord1.st;\n"
"	}\n"
"	else if ( TCGen == TCGEN_ENVIRONMENT_MAPPED ) {\n"
"		vec3 viewer = normalize( u_WorldPos - position );\n"
"		vec2 ref = reflect( viewer, normal ).yz;\n"
"		tex.s = ref.x * -0.5 + 0.5;\n"
"		tex.t = ref.y *  0.5 + 0.5;\n"
"	}\n"
"	else if ( TCGen == TCGEN_VECTOR ) {\n"
"		tex = vec2( dot( position, TCGenVector0 ), dot( position, TCGenVector1 ) );\n"
"	}\n"
"\n"
"	return tex;\n"
"}\n"
"#endif\n"
"\n"
"void main()\n"
"{\n"
"#if defined(USE_RGBAGEN)\n"
"    v_Color = CalcColor( a_Position, a_Normal );\n"
"#else\n"
"    v_Color = u_VertColor * a_Color + u_BaseColor;\n"
"#endif\n"
"\n"
"#if defined(USE_TCGEN)\n"
"	vec2 texCoords = GenTexCoords( u_TCGen0, a_Position, vec3( 0.0 ), u_TCGen0Vector0, u_TCGen0Vector1 );\n"
"#else\n"
"	vec2 texCoords = a_TexCoord;\n"
"#endif\n"
"\n"
"#if defined(USE_TCMOD)\n"
"	v_TexCoord = ModTexCoords( texCoords, position, u_DiffuseTexMatrix, u_DiffuseTexOffTurb );\n"
"#else\n"
"	v_TexCoord = texCoords;\n"
"#endif\n"
"    v_Color = a_Color;\n"
"    gl_Position = u_ModelViewProjection * vec4( a_Position.xy, 0, 1 );\n"
"}\n"
;

const char *fallbackShader_tile_fp =
"#if !defined(GLSL_LEGACY)\n"
"out vec4 a_Color;\n"
"#endif\n"
"\n"
"in vec2 v_TexCoords;\n"
"in vec3 v_FragPos;\n"
"in vec4 v_Color;\n"
"in vec3 v_WorldPos;\n"
"\n"
"uniform sampler2D u_DiffuseMap;\n"
"uniform float u_GammaAmount;\n"
"\n"
"#if defined(USE_LIGHT)\n"
"uniform vec3 u_AmbientColor;\n"
"uniform float u_AmbientIntensity;\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"uniform vec4 u_SpecularScale;\n"
"uniform vec4 u_NormalScale;\n"
"uniform uint u_NumLights;\n"
"#endif\n"
"\n"
"#if defined(USE_NORMALMAP)\n"
"uniform sampler2D u_NormalMap;\n"
"#endif\n"
"\n"
"#if defined(USE_SPECULARMAP)\n"
"uniform sampler2D u_SpecularMap;\n"
"#endif\n"
"\n"
"#if defined(USE_SHADOWMAP)\n"
"uniform sampler2D u_ShadowMap;\n"
"#endif\n"
"\n"
"uniform int u_AlphaTest;\n"
"\n"
"float CalcLightAttenuation(float point, float normDist)\n"
"{\n"
"	// zero light at 1.0, approximating q3 style\n"
"	// also don't attenuate directional light\n"
"	float attenuation = (0.5 * normDist - 1.5) * point + 1.0;\n"
"\n"
"	// clamp attenuation\n"
"	#if defined(NO_LIGHT_CLAMP)\n"
"	attenuation = max(attenuation, 0.0);\n"
"	#else\n"
"	attenuation = clamp(attenuation, 0.0, 1.0);\n"
"	#endif\n"
"\n"
"	return attenuation;\n"
"}\n"
"\n"
"vec3 CalcDiffuse(vec3 diffuseAlbedo, float NH, float EH, float roughness)\n"
"{\n"
"#if defined(USE_BURLEY)\n"
"	// modified from https://disney-animation.s3.amazonaws.com/library/s2012_pbs_disney_brdf_notes_v2.pdf\n"
"	float fd90 = -0.5 + EH * EH * roughness;\n"
"	float burley = 1.0 + fd90 * 0.04 / NH;\n"
"	burley *= burley;\n"
"	return diffuseAlbedo * burley;\n"
"#else\n"
"	return diffuseAlbedo;\n"
"#endif\n"
"}\n"
"\n"
"#if defined(USE_NORMALMAP)\n"
"void CalcNormal() {\n"
"    vec3 normal = texture2D( u_NormalMap, v_TexCoords ).rgb;\n"
"    normal = normalize( normal * 2.0 - 1.0 );\n"
"    a_Color.rgb *= normal * 0.5 + 0.5;\n"
"}\n"
"#endif\n"
"\n"
"void applyLighting() {\n"
"#if defined(USE_NORMALMAP)\n"
"    CalcNormal();\n"
"#endif\n"
"#if defined(USE_SPECULARMAP)\n"
"    a_Color.rgb += texture2D( u_SpecularMap, v_TexCoords ).rgb;\n"
"#endif\n"
"#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"    if ( u_NumLights == uint( 0 ) )\n"
"#endif\n"
"	{\n"
"        a_Color.rgb += texture2D( u_DiffuseMap, v_TexCoords ).rgb;\n"
"    }\n"
"\n"
"#if defined(USE_LIGHT)\n"
"    a_Color.rgb *= u_AmbientColor;\n"
"#endif\n"
"}\n"
"\n"
"void main() {\n"
"    a_Color = texture2D( u_DiffuseMap, v_TexCoords );\n"
"\n"
"    applyLighting();\n"
"\n"
"#if defined(USE_BLOOM) && !defined(USE_FAST_LIGHT)\n"
"	const float brightness = dot( a_Color.rgb, vec3( 0.2126, 0.7152, 0.0722 ) );\n"
"	if ( brightness > 1.0 ) {\n"
"		a_BrightColor = vec4( a_Color.rgb, 1.0 );\n"
"	} else {\n"
"		a_BrightColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n"
"	}\n"
"#endif\n"
"#if defined(USE_HDR)\n"
"	// reinhard tone mapping\n"
"	a_Color.rgb /= ( a_Color.rgb + vec3( 1.0 ) );\n"
"#endif\n"
"    a_Color.rgb = pow( a_Color.rgb, vec3( 1.0 / u_GammaAmount ) );\n"
"}\n"
;

const char *fallbackShader_tonemap_fp =
"#if !defined(GLSL_LEGACY)\n"
"out vec4 a_Color;\n"
"#endif\n"
"\n"
"uniform sampler2D u_TextureMap;\n"
"uniform sampler2D u_LevelsMap;\n"
"\n"
"uniform vec4 u_Color;\n"
"\n"
"\n"
"uniform vec2 u_AutoExposureMinMax;\n"
"uniform vec3 u_ToneMinAvgMaxLinear;\n"
"\n"
"in vec2 v_TexCoords;\n"
"in float v_InvWhite;\n"
"\n"
"const vec3  LUMINANCE_VECTOR =   vec3(0.2125, 0.7154, 0.0721); //vec3(0.299, 0.587, 0.114);\n"
"\n"
"float FilmicTonemap(float x)\n"
"{\n"
"	const float SS  = 0.22; // Shoulder Strength\n"
"	const float LS  = 0.30; // Linear Strength\n"
"	const float LA  = 0.10; // Linear Angle\n"
"	const float TS  = 0.20; // Toe Strength\n"
"	const float TAN = 0.01; // Toe Angle Numerator\n"
"	const float TAD = 0.30; // Toe Angle Denominator\n"
"\n"
"	return ((x*(SS*x+LA*LS)+TS*TAN)/(x*(SS*x+LS)+TS*TAD)) - TAN/TAD;\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"	vec4 color = texture2D(u_TextureMap, v_TexCoords) * u_Color;\n"
"\n"
"#if defined(USE_PBR)\n"
"	color.rgb *= color.rgb;\n"
"#endif\n"
"\n"
"	vec3 minAvgMax = texture2D(u_LevelsMap, v_TexCoords).rgb;\n"
"	vec3 logMinAvgMaxLum = clamp(minAvgMax * 20.0 - 10.0, -u_AutoExposureMinMax.y, -u_AutoExposureMinMax.x);\n"
"\n"
"	float invAvgLum = u_ToneMinAvgMaxLinear.y * exp2(-logMinAvgMaxLum.y);\n"
"\n"
"	color.rgb = color.rgb * invAvgLum - u_ToneMinAvgMaxLinear.xxx;\n"
"	color.rgb = max(vec3(0.0), color.rgb);\n"
"\n"
"	color.r = FilmicTonemap(color.r);\n"
"	color.g = FilmicTonemap(color.g);\n"
"	color.b = FilmicTonemap(color.b);\n"
"\n"
"	color.rgb = clamp(color.rgb * var_InvWhite, 0.0, 1.0);\n"
"\n"
"#if defined(USE_PBR)\n"
"	color.rgb = sqrt(color.rgb);\n"
"#endif\n"
"\n"
"	// add a bit of dither to reduce banding\n"
"	color.rgb += vec3(1.0/510.0 * mod(gl_FragCoord.x + gl_FragCoord.y, 2.0) - 1.0/1020.0);\n"
"\n"
"	a_Color = color;\n"
"}\n"
;

const char *fallbackShader_calclevels4x_vp =
"in vec3 a_Position;\n"
"in vec4 a_TexCoord0;\n"
"\n"
"uniform mat4 u_ModelViewProjection;\n"
"\n"
"out vec2 v_TexCoords;\n"
"\n"
"void main() {\n"
"	gl_Position = u_ModelViewProjection * vec4( a_Position, 1.0 );\n"
"	v_TexCoords = a_TexCoord0.st;\n"
"}\n"
;

const char *fallbackShader_depthblur_vp =
"in vec4 a_Position;\n"
"in vec4 a_TexCoord0;\n"
"\n"
"uniform vec4 u_ViewInfo; // zfar / znear, zfar, 1/width, 1/height\n"
"\n"
"out vec2 v_ScreenTex;\n"
"\n"
"void main() {\n"
"	gl_Position = a_Position;\n"
"	vec2 wh = vec2( 1.0 ) / u_ViewInfo.zw - vec2( 1.0 );\n"
"	v_ScreenTex = ( floor( a_TexCoord0.xy * wh ) + vec2( 0.5 ) ) * u_ViewInfo.zw;\n"
"\n"
"	//vec2 screenCoords = gl_Position.xy / gl_Position.w;\n"
"	//var_ScreenTex = screenCoords * 0.5 + 0.5;\n"
"}\n"
;

const char *fallbackShader_ssao_fp =
"#if !defined(GLSL_LEGACY)\n"
"out vec4 a_Color;\n"
"#endif\n"
"\n"
"uniform sampler2D u_ScreenDepthMap;\n"
"uniform vec4 u_ViewInfo; // zfar / znear, zfar, 1/width, 1/height\n"
"\n"
"varying vec2 v_ScreenTex;\n"
"\n"
"#if 0\n"
"vec2 poissonDisc[9] = vec2[9](\n"
"vec2(-0.7055767, 0.196515),    vec2(0.3524343, -0.7791386),\n"
"vec2(0.2391056, 0.9189604),    vec2(-0.07580382, -0.09224417),\n"
"vec2(0.5784913, -0.002528916), vec2(0.192888, 0.4064181),\n"
"vec2(-0.6335801, -0.5247476),  vec2(-0.5579782, 0.7491854),\n"
"vec2(0.7320465, 0.6317794)\n"
");\n"
"#endif\n"
"\n"
"#define NUM_SAMPLES 3\n"
"\n"
"// Input: It uses texture coords as the random number seed.\n"
"// Output: Random number: [0,1), that is between 0.0 and 0.999999... inclusive.\n"
"// Author: Michael Pohoreski\n"
"// Copyright: Copyleft 2012 :-)\n"
"// Source: http://stackoverflow.com/questions/5149544/can-i-generate-a-random-number-inside-a-pixel-shader\n"
"\n"
"float random( const vec2 p )\n"
"{\n"
"  // We need irrationals for pseudo randomness.\n"
"  // Most (all?) known transcendental numbers will (generally) work.\n"
"  const vec2 r = vec2(\n"
"    23.1406926327792690,  // e^pi (Gelfond's constant)\n"
"     2.6651441426902251); // 2^sqrt(2) (Gelfond-Schneider constant)\n"
"  //return fract( cos( mod( 123456789., 1e-7 + 256. * dot(p,r) ) ) );\n"
"  return mod( 123456789., 1e-7 + 256. * dot(p,r) );\n"
"}\n"
"\n"
"mat2 randomRotation( const vec2 p )\n"
"{\n"
"	float r = random(p);\n"
"	float sinr = sin(r);\n"
"	float cosr = cos(r);\n"
"	return mat2(cosr, sinr, -sinr, cosr);\n"
"}\n"
"\n"
"float getLinearDepth(sampler2D depthMap, const vec2 tex, const float zFarDivZNear)\n"
"{\n"
"	float sampleZDivW = texture2D(depthMap, tex).r;\n"
"	return 1.0 / mix(zFarDivZNear, 1.0, sampleZDivW);\n"
"}\n"
"\n"
"float ambientOcclusion(sampler2D depthMap, const vec2 tex, const float zFarDivZNear, const float zFar, const vec2 scale)\n"
"{\n"
"	vec2 poissonDisc[9];\n"
"\n"
"	poissonDisc[0] = vec2(-0.7055767, 0.196515);\n"
"	poissonDisc[1] = vec2(0.3524343, -0.7791386);\n"
"	poissonDisc[2] = vec2(0.2391056, 0.9189604);\n"
"	poissonDisc[3] = vec2(-0.07580382, -0.09224417);\n"
"	poissonDisc[4] = vec2(0.5784913, -0.002528916);\n"
"	poissonDisc[5] = vec2(0.192888, 0.4064181);\n"
"	poissonDisc[6] = vec2(-0.6335801, -0.5247476);\n"
"	poissonDisc[7] = vec2(-0.5579782, 0.7491854);\n"
"	poissonDisc[8] = vec2(0.7320465, 0.6317794);\n"
"\n"
"	float result = 0.0;\n"
"\n"
"	float sampleZ = getLinearDepth(depthMap, tex, zFarDivZNear);\n"
"	float scaleZ = zFarDivZNear * sampleZ;\n"
"\n"
"	vec2 slope = vec2(dFdx(sampleZ), dFdy(sampleZ)) / vec2(dFdx(tex.x), dFdy(tex.y));\n"
"\n"
"	if (length(slope) * zFar > 5000.0)\n"
"		return 1.0;\n"
"\n"
"	vec2 offsetScale = vec2(scale * 1024.0 / scaleZ);\n"
"\n"
"	mat2 rmat = randomRotation(tex);\n"
"\n"
"	float invZFar = 1.0 / zFar;\n"
"	float zLimit = 20.0 * invZFar;\n"
"	int i;\n"
"	for (i = 0; i < NUM_SAMPLES; i++)\n"
"	{\n"
"		vec2 offset = rmat * poissonDisc[i] * offsetScale;\n"
"		float sampleDiff = getLinearDepth(depthMap, tex + offset, zFarDivZNear) - sampleZ;\n"
"\n"
"		bool s1 = abs(sampleDiff) > zLimit;\n"
"		bool s2 = sampleDiff + invZFar > dot(slope, offset);\n"
"		result += float(s1 || s2);\n"
"	}\n"
"\n"
"	result *= 1.0 / float(NUM_SAMPLES);\n"
"\n"
"	return result;\n"
"}\n"
"\n"
"void main() {\n"
"	float result = ambientOcclusion(u_ScreenDepthMap, v_ScreenTex, u_ViewInfo.x, u_ViewInfo.y, u_ViewInfo.wz);\n"
"\n"
"    a_Color = vec4(vec3(result), 1.0);\n"
"}\n"
;
